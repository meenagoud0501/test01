webpackJsonp([1],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var d = __webpack_require__(9)
  , defaultSettings = __webpack_require__(33)
  , EventManager = __webpack_require__(34)
  , guid = __webpack_require__(35)
  , h = __webpack_require__(4);

var instances = {};

function Instance(element) {
  var i = this;

  i.settings = h.clone(defaultSettings);
  i.containerWidth = null;
  i.containerHeight = null;
  i.contentWidth = null;
  i.contentHeight = null;

  i.isRtl = d.css(element, 'direction') === "rtl";
  i.event = new EventManager();
  i.ownerDocument = element.ownerDocument || document;

  i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
  i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
  i.scrollbarXActive = null;
  i.scrollbarXWidth = null;
  i.scrollbarXLeft = null;
  i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
  i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
  // Set rail to display:block to calculate margins
  d.css(i.scrollbarXRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  d.css(i.scrollbarXRail, 'display', '');
  i.railXWidth = null;
  i.railXRatio = null;

  i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
  i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
  i.scrollbarYActive = null;
  i.scrollbarYHeight = null;
  i.scrollbarYTop = null;
  i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
  i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
  i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
  d.css(i.scrollbarYRail, 'display', '');
  i.railYHeight = null;
  i.railYRatio = null;
}

function getId(element) {
  if (typeof element.dataset === 'undefined') {
    return element.getAttribute('data-ps-id');
  } else {
    return element.dataset.psId;
  }
}

function setId(element, id) {
  if (typeof element.dataset === 'undefined') {
    element.setAttribute('data-ps-id', id);
  } else {
    element.dataset.psId = id;
  }
}

function removeId(element) {
  if (typeof element.dataset === 'undefined') {
    element.removeAttribute('data-ps-id');
  } else {
    delete element.dataset.psId;
  }
}

exports.add = function (element) {
  var newId = guid();
  setId(element, newId);
  instances[newId] = new Instance(element);
  return instances[newId];
};

exports.remove = function (element) {
  delete instances[getId(element)];
  removeId(element);
};

exports.get = function (element) {
  return instances[getId(element)];
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var cls = __webpack_require__(12)
  , d = __webpack_require__(9);

exports.toInt = function (x) {
  return parseInt(x, 10) || 0;
};

exports.clone = function (obj) {
  if (obj === null) {
    return null;
  } else if (typeof obj === 'object') {
    var result = {};
    for (var key in obj) {
      result[key] = this.clone(obj[key]);
    }
    return result;
  } else {
    return obj;
  }
};

exports.extend = function (original, source) {
  var result = this.clone(original);
  for (var key in source) {
    result[key] = this.clone(source[key]);
  }
  return result;
};

exports.isEditable = function (el) {
  return d.matches(el, "input,[contenteditable]") ||
         d.matches(el, "select,[contenteditable]") ||
         d.matches(el, "textarea,[contenteditable]") ||
         d.matches(el, "button,[contenteditable]");
};

exports.removePsClasses = function (element) {
  var clsList = cls.list(element);
  for (var i = 0; i < clsList.length; i++) {
    var className = clsList[i];
    if (className.indexOf('ps-') === 0) {
      cls.remove(element, className);
    }
  }
};

exports.outerWidth = function (element) {
  return this.toInt(d.css(element, 'width')) +
         this.toInt(d.css(element, 'paddingLeft')) +
         this.toInt(d.css(element, 'paddingRight')) +
         this.toInt(d.css(element, 'borderLeftWidth')) +
         this.toInt(d.css(element, 'borderRightWidth'));
};

exports.startScrolling = function (element, axis) {
  cls.add(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.add(element, 'ps-' + axis);
  } else {
    cls.add(element, 'ps-x');
    cls.add(element, 'ps-y');
  }
};

exports.stopScrolling = function (element, axis) {
  cls.remove(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.remove(element, 'ps-' + axis);
  } else {
    cls.remove(element, 'ps-x');
    cls.remove(element, 'ps-y');
  }
};

exports.env = {
  isWebKit: 'WebkitAppearance' in document.documentElement.style,
  supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: window.navigator.msMaxTouchPoints !== null
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var cls = __webpack_require__(12)
  , d = __webpack_require__(9)
  , h = __webpack_require__(4)
  , instances = __webpack_require__(3);

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = {width: i.railXWidth};
  if (i.isRtl) {
    xRailOffset.left = element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
  }
  d.css(i.scrollbarXRail, xRailOffset);

  var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - element.scrollLeft - i.scrollbarYRight - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  d.css(i.scrollbarYRail, yRailOffset);

  d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
  d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
}

module.exports = function (element) {
  var i = instances.get(element);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  if (!element.contains(i.scrollbarXRail)) {
    d.appendTo(i.scrollbarXRail, element);
  }
  if (!element.contains(i.scrollbarYRail)) {
    d.appendTo(i.scrollbarYRail, element);
  }

  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = h.toInt(element.scrollLeft * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }

  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
  cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
};


/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


exports.e = function (tagName, className) {
  var element = document.createElement(tagName);
  element.className = className;
  return element;
};

exports.appendTo = function (child, parent) {
  parent.appendChild(child);
  return child;
};

function cssGet(element, styleName) {
  return window.getComputedStyle(element)[styleName];
}

function cssSet(element, styleName, styleValue) {
  if (typeof styleValue === 'number') {
    styleValue = styleValue.toString() + 'px';
  }
  element.style[styleName] = styleValue;
  return element;
}

function cssMultiSet(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val.toString() + 'px';
    }
    element.style[key] = val;
  }
  return element;
}

exports.css = function (element, styleNameOrObject, styleValue) {
  if (typeof styleNameOrObject === 'object') {
    // multiple set with object
    return cssMultiSet(element, styleNameOrObject);
  } else {
    if (typeof styleValue === 'undefined') {
      return cssGet(element, styleNameOrObject);
    } else {
      return cssSet(element, styleNameOrObject, styleValue);
    }
  }
};

exports.matches = function (element, query) {
  if (typeof element.matches !== 'undefined') {
    return element.matches(query);
  } else {
    if (typeof element.matchesSelector !== 'undefined') {
      return element.matchesSelector(query);
    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
      return element.webkitMatchesSelector(query);
    } else if (typeof element.mozMatchesSelector !== 'undefined') {
      return element.mozMatchesSelector(query);
    } else if (typeof element.msMatchesSelector !== 'undefined') {
      return element.msMatchesSelector(query);
    }
  }
};

exports.remove = function (element) {
  if (typeof element.remove !== 'undefined') {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
};


/***/ }),
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


function oldAdd(element, className) {
  var classes = element.className.split(' ');
  if (classes.indexOf(className) < 0) {
    classes.push(className);
  }
  element.className = classes.join(' ');
}

function oldRemove(element, className) {
  var classes = element.className.split(' ');
  var idx = classes.indexOf(className);
  if (idx >= 0) {
    classes.splice(idx, 1);
  }
  element.className = classes.join(' ');
}

exports.add = function (element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    oldAdd(element, className);
  }
};

exports.remove = function (element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    oldRemove(element, className);
  }
};

exports.list = function (element) {
  if (element.classList) {
    return element.classList;
  } else {
    return element.className.split(' ');
  }
};


/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global require, module, window */

var eventemitter = __webpack_require__(20);
var EventEmitter2 = eventemitter.EventEmitter2 || eventemitter;
module.exports = window.events = window.events || new EventEmitter2();


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global ga */

var _ = __webpack_require__(2);
var URI = __webpack_require__(8);

var helpers = __webpack_require__(6);

function trackerExists() {
  if (typeof ga !== 'undefined') {
    return true;
  }
}

/* Initialize a non Digital Analytics Program GA tracker
 * This tracker's name is "nonDAP", so all commands will need to be prefixed
*/
function init() {
  if (!trackerExists()) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }

  ga('create', 'UA-48605964-22', 'auto', 'notDAP');
  ga('notDAP.set', 'forceSSL', true);
  ga('notDAP.set', 'anonymizeIp', true);
}

function pageView() {
  if (typeof ga === 'undefined') { return; }
  var path = document.location.pathname;
  if (document.location.search) {
    var query = helpers.sanitizeQueryParams(URI.parseQuery(document.location.search));
    path += '?' + sortQuery(query);
  }
  ga('notDAP.send', 'pageview', path);
}

function sortQuery(query) {
  return _.chain(query)
    .pairs()
    .map(function(pair) {
      return [pair[0], _.isArray(pair[1]) ? pair[1] : [pair[1]]];
    })
    .reduce(function(memo, pair) {
      return memo.concat(_.map(pair[1], function(value) {
        return [pair[0], value];
      }));
    }, [])
    .sort()
    .map(function(pair) {
      return pair.join('=');
    })
    .join('&')
    .value();
}

module.exports = {
  init: init,
  pageView: pageView,
  sortQuery: sortQuery,
  trackerExists: trackerExists
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(51);

module.exports = function (value) {
	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),
/* 17 */,
/* 18 */,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
var URI = __webpack_require__(8);
var _ = __webpack_require__(2);
var Handlebars = __webpack_require__(68);
var helpers = __webpack_require__(6);

// Hack: Append jQuery to `window` for use by typeahead.js
window.$ = window.jQuery = $;

__webpack_require__(45);
var Bloodhound = __webpack_require__(49);

var events = __webpack_require__(14);

var officeMap = {
  H: 'House',
  S: 'Senate',
  P: 'President'
};

function formatCandidate(result) {
  return {
    name: result.name,
    id: result.id,
    type: 'candidate',
    office: officeMap[result.office_sought]
  };
}

function formatCommittee(result) {
  return {
    name: result.name,
    id: result.id,
    type: 'committee'
  };
}

function getUrl(resource) {
  return URI(window.API_LOCATION)
    .path([window.API_VERSION, 'names', resource, ''].join('/'))
    .query({
      q: '%QUERY',
      api_key: window.API_KEY
    })
    .readable();
}

var engineOpts = {
  datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
  queryTokenizer: Bloodhound.tokenizers.whitespace,
  limit: 10
};

function createEngine(opts) {
  return new Bloodhound(_.extend({}, engineOpts, opts));
}

var candidateEngine = createEngine({
  remote: {
    url: getUrl('candidates'),
    wildcard: '%QUERY',
    transform: function(response) {
      return _.map(response.results, formatCandidate);
    }
  }
});

var committeeEngine = createEngine({
  remote: {
    url: getUrl('committees'),
    wildcard: '%QUERY',
    transform: function(response) {
      return _.map(response.results, formatCommittee);
    },
  }
});

var candidateDataset = {
  name: 'candidate',
  display: 'name',
  limit: 5,
  source: candidateEngine,
  templates: {
    header: '<span class="tt-suggestion__header">Select a candidate:</span>',
    pending: '<span class="tt-suggestion__loading">Loading candidates...</span>',
    notFound: Handlebars.compile(''), // This has to be empty to not show anything
    suggestion: Handlebars.compile(
      '<span>' +
      '<span class="tt-suggestion__name">{{ name }} ({{ id }})</span>' +
      '<span class="tt-suggestion__office">{{ office }}</span>' +
      '</span>'
    )
  }
};

var committeeDataset = {
  name: 'committee',
  display: 'name',
  limit: 10,
  source: committeeEngine,
  templates: {
    header: '<span class="tt-suggestion__header">Select a committee:</span>',
    pending: '<span class="tt-suggestion__loading">Loading committees...</span>',
    notFound: Handlebars.compile(''), // This has to be empty to not show anything
    suggestion: Handlebars.compile(
      '<span class="tt-suggestion__name">{{ name }} ({{ id }})</span>'
    )
  }
};

/* This is a fake dataset for showing an empty option with the query
 * when clicked, this will load the receipts page,
 * filtered to contributions from this person
 */
var individualDataset = {
  display: 'id',
  source: function(query, syncResults) {
    syncResults([{
      id: helpers.sanitizeValue(query),
      type: 'individual'
    }]);
  },
  templates: {
    suggestion: function(datum) {
      return '<span><strong>Search individual contributions from:</strong> "' + datum.id + '"</span>';
    }
  }
};

/* This is a fake dataset for showing an empty option with the query
 * when clicked, this will submit the form to the DigitalGov search site
 */
var siteDataset = {
  display: 'id',
  source: function(query, syncResults) {
    syncResults([{
      id: helpers.sanitizeValue(query),
      type: 'site'
    }]);
  },
  templates: {
    suggestion: function(datum) {
      return '<span><strong>Search other pages:</strong> "' + datum.id + '"</span>';
    }
  }
};

var datasets = {
  candidates: candidateDataset,
  committees: committeeDataset,
  allData: [candidateDataset, committeeDataset],
  all: [candidateDataset, committeeDataset, individualDataset, siteDataset]
};

var typeaheadOpts = {
  minLength: 3,
  highlight: true,
  hint: false
};

function Typeahead(selector, type, url) {
  this.$input = $(selector);
  this.url = url || '/';
  this.typeahead = null;

  this.dataset = datasets[type];

  this.init();

  events.on('searchTypeChanged', this.handleChangeEvent.bind(this));
}

Typeahead.prototype.init = function() {
  if (this.typeahead) {
    this.$input.typeahead('destroy');
  }
  this.typeahead = this.$input.typeahead(typeaheadOpts, this.dataset);
  this.$element = this.$input.parent('.twitter-typeahead');
  this.$element.css('display', 'block');
  this.$element.find('.tt-menu').attr('aria-live', 'polite');
  this.$input.on('typeahead:select', this.select.bind(this));
};

Typeahead.prototype.handleChangeEvent = function(data) {
  this.init(data.type);
};

Typeahead.prototype.select = function(event, datum) {
  if (datum.type === 'individual') {
    window.location = this.url + 'receipts/individual-contributions/?contributor_name=' + datum.id;
  } else if (datum.type === 'site') {
    this.searchSite(datum.id);
  } else {
    window.location = this.url + datum.type + '/' + datum.id;
  }
};

Typeahead.prototype.searchSite = function(query) {
  /* If the site search option is selected, this function handles submitting
   * a new search on /search
   */

  var $form = this.$input.closest('form');
  var action = $form.attr('action');
  this.$input.val(query);
  $form.attr('action', action);
  $form.submit();
};

module.exports = {
  Typeahead: Typeahead,
  datasets: datasets
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {

      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    configure.call(this, conf);
  }

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else if(typeof tree._listeners === 'function') {
          tree._listeners = [tree._listeners, listener];
        }
        else if (isArray(tree._listeners)) {

          tree._listeners.push(listener);

          if (!tree._listeners.warned) {

            var m = defaultMaxListeners;

            if (typeof this._events.maxListeners !== 'undefined') {
              m = this._events.maxListeners;
            }

            if (m > 0 && tree._listeners.length > m) {

              tree._listeners.warned = true;
              console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            tree._listeners.length);
              console.trace();
            }
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    this._events || init.call(this);
    this._events.maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) { return false; }
    }

    // Loop through the *_all* functions and invoke them.
    if (this._all) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        this._all[i].apply(this, args);
      }
    }

    // If there is no 'error' event listener then throw.
    if (type === 'error') {

      if (!this._all &&
        !this._events.error &&
        !(this.wildcard && this.listenerTree.error)) {

        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    var handler;

    if(this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    }
    else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      if (arguments.length === 1) {
        handler.call(this);
      }
      else if (arguments.length > 1)
        switch (arguments.length) {
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      return true;
    }
    else if (handler) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        this.event = type;
        listeners[i].apply(this, args);
      }
      return (listeners.length > 0) || !!this._all;
    }
    else {
      return !!this._all;
    }

  };

  EventEmitter.prototype.on = function(type, listener) {

    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if(this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else if(typeof this._events[type] === 'function') {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
    else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (!this._events[type].warned) {

        var m = defaultMaxListeners;

        if (typeof this._events.maxListeners !== 'undefined') {
          m = this._events.maxListeners;
        }

        if (m > 0 && this._events[type].length > m) {

          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          console.trace();
        }
      }
    }
    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {

    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if(!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          return this;
        }
      }
    } else {
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else {
      if (!this._events[type]) return this;
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if(this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (true) {
     // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return EventEmitter;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    // CommonJS
    exports.EventEmitter2 = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
__webpack_require__(29)($);

var listeners = __webpack_require__(24);

var KEYCODE_ESC = 27;
var KEYCODE_ENTER = 13;

var defaultOpts = {
  checkboxes: true,
};

/**
 * Dropdown toggles
 * @constructor
 * @param {string} selector - CSS selector for the fieldset that contains everything
 * @param {object} opts - Options
 */
function Dropdown(selector, opts) {
  this.opts = $.extend({}, defaultOpts, opts);

  this.isOpen = false;

  this.$body = $(selector);
  this.$button = this.$body.find('.dropdown__button');
  this.$panel = this.$body.find('.dropdown__panel');

  if (this.opts.checkboxes) {
    this.$selected = this.$body.find('.dropdown__selected');
    this.$panel.on('keyup', 'input[type="checkbox"]', this.handleCheckKeyup.bind(this));
    this.$panel.on('change', 'input[type="checkbox"]', this.handleCheck.bind(this));
    this.$panel.on('click', '.dropdown__item--selected', this.handleDropdownItemClick.bind(this));

    this.$selected.on('click', 'input[type="checkbox"]', this.handleSelectedInputClick.bind(this));
    this.$selected.on('click', '.dropdown__remove', this.handleRemoveClick.bind(this));

    if (this.isEmpty()) {
      this.removePanel();
    }
  }

  $(document.body).on('tag:removeAll', this.handleClearFilters.bind(this));

  this.$button.on('click', this.toggle.bind(this));

  this.events = new listeners.Listeners();
  this.events.on(document.body, 'click', this.handleClickAway.bind(this));
  this.events.on(document.body, 'focusin', this.handleFocusAway.bind(this));
  this.events.on(document.body, 'keyup', this.handleKeyup.bind(this));

  // Set ARIA attributes
  this.$button.attr('aria-haspopup', 'true');
  this.$panel.attr('aria-label','More options');
}

Dropdown.prototype.toggle = function(e) {
  e.preventDefault();
  var method = this.isOpen ? this.hide : this.show;
  method.apply(this);

  return false;
};

Dropdown.prototype.show = function() {
  this.$panel.attr('aria-hidden', 'false');
  this.$panel.perfectScrollbar({suppressScrollX: true});
  this.$panel.find('input[type="checkbox"]:first').focus();
  this.$button.addClass('is-active');
  this.isOpen = true;
};

Dropdown.prototype.hide = function() {
  this.$panel.attr('aria-hidden', 'true');
  this.$button.removeClass('is-active');
  this.isOpen = false;
};

Dropdown.prototype.handleClickAway = function(e) {
  var $target = $(e.target);
  if (!this.$body.has($target).length) {
    this.hide();
  }
};

Dropdown.prototype.handleFocusAway = function(e) {
  var $target = $(e.target);
  if (this.isOpen && !this.$panel.has($target).length &&
      !this.$panel.is($target) && !$target.is(this.$button)) {
    this.hide();
  }
};

Dropdown.prototype.handleKeyup = function(e) {
  if (e.keyCode === KEYCODE_ESC) {
    if (this.isOpen) {
      this.hide();
      this.$button.focus();
    }
  }
};

Dropdown.prototype.handleCheckKeyup = function(e) {
  if (e.keyCode === KEYCODE_ENTER) {
    $(e.target).prop('checked', true).change();
  }
};

Dropdown.prototype.handleCheck = function(e) {
  var $input = $(e.target);
  if ($input.is(':checked')) {
    this.selectItem($input);
  }
};

Dropdown.prototype.handleDropdownItemClick = function(e) {
  var $button = $(e.target);
  var $input = this.$selected.find('#' + $button.data('label'));

  if (!$button.hasClass('is-checked')) {
    $input.click();
  }
};

Dropdown.prototype.handleSelectedInputClick = function(e) {
  var $button = this.$panel.find('button[data-label=' + e.target.id + ']');

  $button.toggleClass('is-checked');
};

Dropdown.prototype.handleCheckboxRemoval = function($input) {
  var $item = $input.parent();
  var $label = $input.parent().find('label');
  var $button = this.$panel.find('button[data-label="' + $input.attr('id') +'"]');

  if ($button.length > 0) {
    $button.parent().append($input);
    $button.parent().append($label);
    $button.remove();

    $item.remove();
  }
};

Dropdown.prototype.handleRemoveClick = function(e, opts) {
  var $input = $(e.target).parent().find('input');

  // tag removal
  if (opts) {
    $input = this.$selected.find('#' + opts.key);
  }

  this.handleCheckboxRemoval($input);
};

// "Clear all filters" will remove unchecked dropdown checkboxes
Dropdown.prototype.handleClearFilters = function() {
  var self = this;
  if (this.$selected) {
    this.$selected.find('input:checkbox:not(:checked)').each(function () {
      self.handleCheckboxRemoval($(this));
    });
  }
};

Dropdown.prototype.selectItem = function($input) {
  var $item = $input.parent('.dropdown__item');
  var $label = $item.find('label');
  var prev = $item.prevAll('.dropdown__item');
  var next = $item.nextAll('.dropdown__item');

  $item.after('<li class="dropdown__item">' +
    '<button class="dropdown__item--selected is-checked"' +
    ' data-label="' + $label.attr('for') + '" >' +
    $label.text() + '</button></li>');

  this.$selected.append($item);

  $item.append('<button class="dropdown__remove">' +
    '<span class="u-visually-hidden">Remove</span></button>');

  if (!this.isEmpty()) {
    if (next.length) {
      $(next[0]).find('input[type="checkbox"]').focus();
    } else if (prev.length) {
      $(prev[0]).find('input[type="checkbox"]').focus();
    }
  } else {
    this.removePanel();
    this.$selected.find('input[type="checkbox"]').focus();
  }
};

Dropdown.prototype.removePanel = function() {
  this.$panel.remove();
  this.$button.remove();
};

Dropdown.prototype.isEmpty = function() {
  return this.$panel.find('input').length === 0;
};

Dropdown.prototype.destroy = function() {
  this.events.clear();
};

module.exports = {Dropdown: Dropdown};


/***/ }),
/* 23 */,
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
var _ = __webpack_require__(2);

function Listeners() {
  this.listeners = [];
}

Listeners.prototype.on = function(elm) {
  var $elm = $(elm);
  var args = _.toArray(arguments).slice(1);
  this.listeners = this._listeners || [];
  this.listeners.push({$elm: $elm, args: args});
  $elm.on.apply($elm, args);
};

Listeners.prototype.clear = function() {
  this.listeners.forEach(function(listener) {
    var $elm = listener.$elm;
    var args = listener.args;
    $elm.off.apply($elm, args);
  });
};

module.exports = {Listeners: Listeners};


/***/ }),
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global require, module */

var $ = __webpack_require__(0);

/**
 * Utilities for setting or removing tabindex on all focusable elements
 * in a parent div. Useful for hiding elements off-canvas without setting
 * display:none, while still removing from the tab order
 */

function removeTabindex($elm) {
  $elm
    .find('a, button, :input, [tabindex]')
    .attr('tabindex', '-1');
}

function restoreTabindex($elm) {
  $elm
    .find('a, button, :input, [tabindex]')
    .attr('tabindex', '0');
}

module.exports = {
  removeTabindex: removeTabindex,
  restoreTabindex: restoreTabindex
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


module.exports = __webpack_require__(30);


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var ps = __webpack_require__(31)
  , psInstances = __webpack_require__(3);

function mountJQuery(jQuery) {
  jQuery.fn.perfectScrollbar = function (settingOrCommand) {
    return this.each(function () {
      if (typeof settingOrCommand === 'object' ||
          typeof settingOrCommand === 'undefined') {
        // If it's an object or none, initialize.
        var settings = settingOrCommand;

        if (!psInstances.get(this)) {
          ps.initialize(this, settings);
        }
      } else {
        // Unless, it may be a command.
        var command = settingOrCommand;

        if (command === 'update') {
          ps.update(this);
        } else if (command === 'destroy') {
          ps.destroy(this);
        }
      }

      return jQuery(this);
    });
  };
}

if (true) {
  // AMD. Register as an anonymous module.
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mountJQuery),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  var jq = window.jQuery ? window.jQuery : window.$;
  if (typeof jq !== 'undefined') {
    mountJQuery(jq);
  }
}

module.exports = mountJQuery;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var destroy = __webpack_require__(32)
  , initialize = __webpack_require__(36)
  , update = __webpack_require__(44);

module.exports = {
  initialize: initialize,
  update: update,
  destroy: destroy
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var d = __webpack_require__(9)
  , h = __webpack_require__(4)
  , instances = __webpack_require__(3);

module.exports = function (element) {
  var i = instances.get(element);

  i.event.unbindAll();
  d.remove(i.scrollbarX);
  d.remove(i.scrollbarY);
  d.remove(i.scrollbarXRail);
  d.remove(i.scrollbarYRail);
  h.removePsClasses(element);

  instances.remove(element);
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


module.exports = {
  wheelSpeed: 1,
  wheelPropagation: false,
  swipePropagation: true,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  useBothWheelAxes: false,
  useKeyboard: true,
  suppressScrollX: false,
  suppressScrollY: false,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var EventElement = function (element) {
  this.element = element;
  this.events = {};
};

EventElement.prototype.bind = function (eventName, handler) {
  if (typeof this.events[eventName] === 'undefined') {
    this.events[eventName] = [];
  }
  this.events[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function (eventName, handler) {
  var isHandlerProvided = (typeof handler !== 'undefined');
  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
    if (isHandlerProvided && hdlr !== handler) {
      return true;
    }
    this.element.removeEventListener(eventName, hdlr, false);
    return false;
  }, this);
};

EventElement.prototype.unbindAll = function () {
  for (var name in this.events) {
    this.unbind(name);
  }
};

var EventManager = function () {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function (element) {
  var ee = this.eventElements.filter(function (eventElement) {
    return eventElement.element === element;
  })[0];
  if (typeof ee === 'undefined') {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function (element, eventName, handler) {
  this.eventElement(element).unbind(eventName, handler);
};

EventManager.prototype.unbindAll = function () {
  for (var i = 0; i < this.eventElements.length; i++) {
    this.eventElements[i].unbindAll();
  }
};

EventManager.prototype.once = function (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (e) {
    ee.unbind(eventName, onceHandler);
    handler(e);
  };
  ee.bind(eventName, onceHandler);
};

module.exports = EventManager;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


module.exports = (function () {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }
  return function () {
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
           s4() + '-' + s4() + s4() + s4();
  };
})();


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var cls = __webpack_require__(12)
  , h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

// Handlers
var clickRailHandler = __webpack_require__(37)
  , dragScrollbarHandler = __webpack_require__(38)
  , keyboardHandler = __webpack_require__(39)
  , mouseWheelHandler = __webpack_require__(40)
  , nativeScrollHandler = __webpack_require__(41)
  , selectionHandler = __webpack_require__(42)
  , touchHandler = __webpack_require__(43);

module.exports = function (element, userSettings) {
  userSettings = typeof userSettings === 'object' ? userSettings : {};

  cls.add(element, 'ps-container');

  // Create a plugin instance.
  var i = instances.add(element);

  i.settings = h.extend(i.settings, userSettings);

  clickRailHandler(element);
  dragScrollbarHandler(element);
  mouseWheelHandler(element);
  nativeScrollHandler(element);
  selectionHandler(element);

  if (h.env.supportsTouch || h.env.supportsIePointer) {
    touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
  }
  if (i.settings.useKeyboard) {
    keyboardHandler(element);
  }

  updateGeometry(element);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindClickRailHandler(element, i) {
  function pageOffset(el) {
    return el.getBoundingClientRect();
  }
  var stopPropagation = window.Event.prototype.stopPropagation.bind;

  i.event.bind(i.scrollbarY, 'click', stopPropagation);
  i.event.bind(i.scrollbarYRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
    var positionTop = i.railYRatio * (e.pageY - window.scrollY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
    var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
    var positionRatio = positionTop / maxPositionTop;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    element.scrollTop = (i.contentHeight - i.containerHeight) * positionRatio;
    updateGeometry(element);

    e.stopPropagation();
  });

  i.event.bind(i.scrollbarX, 'click', stopPropagation);
  i.event.bind(i.scrollbarXRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
    var positionLeft = i.railXRatio * (e.pageX - window.scrollX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
    var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
    var positionRatio = positionLeft / maxPositionLeft;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    element.scrollLeft = (i.contentWidth - i.containerWidth) * positionRatio;
    updateGeometry(element);

    e.stopPropagation();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindClickRailHandler(element, i);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var d = __webpack_require__(9)
  , h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindMouseScrollXHandler(element, i) {
  var currentLeft = null;
  var currentPageX = null;

  function updateScrollLeft(deltaX) {
    var newLeft = currentLeft + (deltaX * i.railXRatio);
    var maxLeft = i.scrollbarXRail.getBoundingClientRect().left + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

    if (newLeft < 0) {
      i.scrollbarXLeft = 0;
    } else if (newLeft > maxLeft) {
      i.scrollbarXLeft = maxLeft;
    } else {
      i.scrollbarXLeft = newLeft;
    }

    var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth)));
    element.scrollLeft = scrollLeft;
  }

  var mouseMoveHandler = function (e) {
    updateScrollLeft(e.pageX - currentPageX);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'x');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
    currentPageX = e.pageX;
    currentLeft = h.toInt(d.css(i.scrollbarX, 'left')) * i.railXRatio;
    h.startScrolling(element, 'x');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

function bindMouseScrollYHandler(element, i) {
  var currentTop = null;
  var currentPageY = null;

  function updateScrollTop(deltaY) {
    var newTop = currentTop + (deltaY * i.railYRatio);
    var maxTop = i.scrollbarYRail.getBoundingClientRect().top + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

    if (newTop < 0) {
      i.scrollbarYTop = 0;
    } else if (newTop > maxTop) {
      i.scrollbarYTop = maxTop;
    } else {
      i.scrollbarYTop = newTop;
    }

    var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
    element.scrollTop = scrollTop;
  }

  var mouseMoveHandler = function (e) {
    updateScrollTop(e.pageY - currentPageY);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'y');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
    currentPageY = e.pageY;
    currentTop = h.toInt(d.css(i.scrollbarY, 'top')) * i.railYRatio;
    h.startScrolling(element, 'y');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseScrollXHandler(element, i);
  bindMouseScrollYHandler(element, i);
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindKeyboardHandler(element, i) {
  var hovered = false;
  i.event.bind(element, 'mouseenter', function () {
    hovered = true;
  });
  i.event.bind(element, 'mouseleave', function () {
    hovered = false;
  });

  var shouldPrevent = false;
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
      return;
    }

    if (!hovered) {
      return;
    }

    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      // go deeper if element is a webcomponent
      while (activeElement.shadowRoot) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      if (h.isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
    case 37: // left
      deltaX = -30;
      break;
    case 38: // up
      deltaY = 30;
      break;
    case 39: // right
      deltaX = 30;
      break;
    case 40: // down
      deltaY = -30;
      break;
    case 33: // page up
      deltaY = 90;
      break;
    case 32: // space bar
    case 34: // page down
      deltaY = -90;
      break;
    case 35: // end
      if (e.ctrlKey) {
        deltaY = -i.contentHeight;
      } else {
        deltaY = -i.containerHeight;
      }
      break;
    case 36: // home
      if (e.ctrlKey) {
        deltaY = element.scrollTop;
      } else {
        deltaY = i.containerHeight;
      }
      break;
    default:
      return;
    }

    element.scrollTop = element.scrollTop - deltaY;
    element.scrollLeft = element.scrollLeft + deltaX;
    updateGeometry(element);

    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent) {
      e.preventDefault();
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindKeyboardHandler(element, i);
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindMouseWheelHandler(element, i) {
  var shouldPrevent = false;

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    return [deltaX, deltaY];
  }

  function shouldBeConsumedByTextarea(deltaX, deltaY) {
    var hoveredTextarea = element.querySelector('textarea:hover');
    if (hoveredTextarea) {
      var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
      if (maxScrollTop > 0) {
        if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
            !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
          return true;
        }
      }
      var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
      if (maxScrollLeft > 0) {
        if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
            !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
          return true;
        }
      }
    }
    return false;
  }

  function mousewheelHandler(e) {
    // FIXME: this is a quick fix for the select problem in FF and IE.
    // If there comes an effective way to deal with the problem,
    // this lines should be removed.
    if (!h.env.isWebKit && element.querySelector('select:focus')) {
      return;
    }

    var delta = getDeltaFromEvent(e);

    var deltaX = delta[0];
    var deltaY = delta[1];

    if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
      return;
    }

    shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
      element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
      } else {
        element.scrollTop = element.scrollTop + (deltaX * i.settings.wheelSpeed);
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
      } else {
        element.scrollLeft = element.scrollLeft - (deltaY * i.settings.wheelSpeed);
      }
      shouldPrevent = true;
    }

    updateGeometry(element);

    shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
    if (shouldPrevent) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseWheelHandler(element, i);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindNativeScrollHandler(element, i) {
  i.event.bind(element, 'scroll', function () {
    updateGeometry(element);
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindNativeScrollHandler(element, i);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindSelectionHandler(element, i) {
  function getRangeNode() {
    var selection = window.getSelection ? window.getSelection() :
                    document.getSelection ? document.getSelection() : '';
    if (selection.toString().length === 0) {
      return null;
    } else {
      return selection.getRangeAt(0).commonAncestorContainer;
    }
  }

  var scrollingLoop = null;
  var scrollDiff = {top: 0, left: 0};
  function startScrolling() {
    if (!scrollingLoop) {
      scrollingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(scrollingLoop);
          return;
        }

        element.scrollTop = element.scrollTop + scrollDiff.top;
        element.scrollLeft = element.scrollLeft + scrollDiff.left;
        updateGeometry(element);
      }, 50); // every .1 sec
    }
  }
  function stopScrolling() {
    if (scrollingLoop) {
      clearInterval(scrollingLoop);
      scrollingLoop = null;
    }
    h.stopScrolling(element);
  }

  var isSelected = false;
  i.event.bind(i.ownerDocument, 'selectionchange', function () {
    if (element.contains(getRangeNode())) {
      isSelected = true;
    } else {
      isSelected = false;
      stopScrolling();
    }
  });
  i.event.bind(window, 'mouseup', function () {
    if (isSelected) {
      isSelected = false;
      stopScrolling();
    }
  });

  i.event.bind(window, 'mousemove', function (e) {
    if (isSelected) {
      var mousePosition = {x: e.pageX, y: e.pageY};
      var containerGeometry = {
        left: element.offsetLeft,
        right: element.offsetLeft + element.offsetWidth,
        top: element.offsetTop,
        bottom: element.offsetTop + element.offsetHeight
      };

      if (mousePosition.x < containerGeometry.left + 3) {
        scrollDiff.left = -5;
        h.startScrolling(element, 'x');
      } else if (mousePosition.x > containerGeometry.right - 3) {
        scrollDiff.left = 5;
        h.startScrolling(element, 'x');
      } else {
        scrollDiff.left = 0;
      }

      if (mousePosition.y < containerGeometry.top + 3) {
        if (containerGeometry.top + 3 - mousePosition.y < 5) {
          scrollDiff.top = -5;
        } else {
          scrollDiff.top = -20;
        }
        h.startScrolling(element, 'y');
      } else if (mousePosition.y > containerGeometry.bottom - 3) {
        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
          scrollDiff.top = 5;
        } else {
          scrollDiff.top = 20;
        }
        h.startScrolling(element, 'y');
      } else {
        scrollDiff.top = 0;
      }

      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
        stopScrolling();
      } else {
        startScrolling();
      }
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindSelectionHandler(element, i);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
          ((deltaY > 0) && (scrollTop === 0))) {
        return !i.settings.swipePropagation;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
          ((deltaX > 0) && (scrollLeft === 0))) {
        return !i.settings.swipePropagation;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop = element.scrollTop - differenceY;
    element.scrollLeft = element.scrollLeft - differenceX;

    updateGeometry(element);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  var inGlobalTouch = false;
  var inLocalTouch = false;

  function globalTouchStart() {
    inGlobalTouch = true;
  }
  function globalTouchEnd() {
    inGlobalTouch = false;
  }

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (shouldHandle(e)) {
      inLocalTouch = true;

      var touch = getTouch(e);

      startOffset.pageX = touch.pageX;
      startOffset.pageY = touch.pageY;

      startTime = (new Date()).getTime();

      if (easingLoop !== null) {
        clearInterval(easingLoop);
      }

      e.stopPropagation();
    }
  }
  function touchMove(e) {
    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = (new Date()).getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPreventDefault(differenceX, differenceY)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (!inGlobalTouch && inLocalTouch) {
      inLocalTouch = false;

      clearInterval(easingLoop);
      easingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (supportsTouch) {
    i.event.bind(window, 'touchstart', globalTouchStart);
    i.event.bind(window, 'touchend', globalTouchEnd);
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  }

  if (supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(window, 'pointerdown', globalTouchStart);
      i.event.bind(window, 'pointerup', globalTouchEnd);
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(window, 'MSPointerDown', globalTouchStart);
      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
}

module.exports = function (element, supportsTouch, supportsIePointer) {
  var i = instances.get(element);
  bindTouchHandler(element, i, supportsTouch, supportsIePointer);
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */


var d = __webpack_require__(9)
  , h = __webpack_require__(4)
  , instances = __webpack_require__(3)
  , updateGeometry = __webpack_require__(5);

module.exports = function (element) {
  var i = instances.get(element);

  // Recalculate rail margins
  d.css(i.scrollbarXRail, 'display', 'block');
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  d.css(i.scrollbarXRail, 'display', 'none');
  d.css(i.scrollbarYRail, 'display', 'none');

  updateGeometry(element);

  d.css(i.scrollbarXRail, 'display', '');
  d.css(i.scrollbarYRail, 'display', '');
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * typeahead.js 0.11.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
 */

(function(root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(a0) {
            return factory(a0);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(this, function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            isElement: function(obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function(obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function(x) {
                return x;
            },
            clone: function(obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function(val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function() {}
        };
    }();
    var WWW = function() {
        "use strict";
        var defaultClassNames = {
            wrapper: "twitter-typeahead",
            input: "tt-input",
            hint: "tt-hint",
            menu: "tt-menu",
            dataset: "tt-dataset",
            suggestion: "tt-suggestion",
            selectable: "tt-selectable",
            empty: "tt-empty",
            open: "tt-open",
            cursor: "tt-cursor",
            highlight: "tt-highlight"
        };
        return build;
        function build(o) {
            var www, classes;
            classes = _.mixin({}, defaultClassNames, o);
            www = {
                css: buildCss(),
                classes: classes,
                html: buildHtml(classes),
                selectors: buildSelectors(classes)
            };
            return {
                css: www.css,
                html: www.html,
                classes: www.classes,
                selectors: www.selectors,
                mixin: function(o) {
                    _.mixin(o, www);
                }
            };
        }
        function buildHtml(c) {
            return {
                wrapper: '<span class="' + c.wrapper + '"></span>',
                menu: '<div class="' + c.menu + '"></div>'
            };
        }
        function buildSelectors(classes) {
            var selectors = {};
            _.each(classes, function(v, k) {
                selectors[k] = "." + v;
            });
            return selectors;
        }
        function buildCss() {
            var css = {
                wrapper: {
                    position: "relative",
                    display: "inline-block"
                },
                hint: {
                    position: "absolute",
                    top: "0",
                    left: "0",
                    borderColor: "transparent",
                    boxShadow: "none",
                    opacity: "1"
                },
                input: {
                    position: "relative",
                    verticalAlign: "top",
                    backgroundColor: "transparent"
                },
                inputWithNoHint: {
                    position: "relative",
                    verticalAlign: "top"
                },
                menu: {
                    position: "absolute",
                    top: "100%",
                    left: "0",
                    zIndex: "100",
                    display: "none"
                },
                ltr: {
                    left: "0",
                    right: "auto"
                },
                rtl: {
                    left: "auto",
                    right: " 0"
                }
            };
            if (_.isMsie()) {
                _.mixin(css.input, {
                    backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                });
            }
            return css;
        }
    }();
    var EventBus = function() {
        "use strict";
        var namespace, deprecationMap;
        namespace = "typeahead:";
        deprecationMap = {
            render: "rendered",
            cursorchange: "cursorchanged",
            select: "selected",
            autocomplete: "autocompleted"
        };
        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        _.mixin(EventBus.prototype, {
            _trigger: function(type, args) {
                var $e;
                $e = $.Event(namespace + type);
                (args = args || []).unshift($e);
                this.$el.trigger.apply(this.$el, args);
                return $e;
            },
            before: function(type) {
                var args, $e;
                args = [].slice.call(arguments, 1);
                $e = this._trigger("before" + type, args);
                return $e.isDefaultPrevented();
            },
            trigger: function(type) {
                var deprecatedType;
                this._trigger(type, [].slice.call(arguments, 1));
                if (deprecatedType = deprecationMap[type]) {
                    this._trigger(deprecatedType, [].slice.call(arguments, 1));
                }
            }
        });
        return EventBus;
    }();
    var EventEmitter = function() {
        "use strict";
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };
        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }
        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }
        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }
        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }
        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }
        function getFlush(callbacks, context, args) {
            return flush;
            function flush() {
                var cancelled;
                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }
        function getNextTick() {
            var nextTickFn;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function() {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function() {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }
        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function() {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function(doc) {
        "use strict";
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);
            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }
            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };
        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [], regexStr;
            for (var i = 0, len = patterns.length; i < len; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function() {
        "use strict";
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };
        function Input(o, www) {
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            www.mixin(this);
            this.$hint = $(o.hint);
            this.$input = $(o.input);
            this.query = this.$input.val();
            this.queryWhenFocused = this.hasFocus() ? this.query : null;
            this.$overflowHelper = buildOverflowHelper(this.$input);
            this._checkLanguageDirection();
            if (this.$hint.length === 0) {
                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
            }
        }
        Input.normalizeQuery = function(str) {
            return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur() {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus() {
                this.queryWhenFocused = this.query;
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput() {
                this._setQuery(this.getInputValue());
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault;
                switch (keyName) {
                  case "up":
                  case "down":
                    preventDefault = !withModifier($e);
                    break;

                  default:
                    preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                  case "tab":
                    trigger = !withModifier($e);
                    break;

                  default:
                    trigger = true;
                }
                return trigger;
            },
            _checkLanguageDirection: function checkLanguageDirection() {
                var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.$hint.attr("dir", dir);
                    this.trigger("langDirChanged", dir);
                }
            },
            _setQuery: function setQuery(val, silent) {
                var areEquivalent, hasDifferentWhitespace;
                areEquivalent = areQueriesEquivalent(val, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                this.query = val;
                if (!silent && !areEquivalent) {
                    this.trigger("queryChanged", this.query);
                } else if (!silent && hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            bind: function() {
                var that = this, onBlur, onFocus, onKeydown, onInput;
                onBlur = _.bind(this._onBlur, this);
                onFocus = _.bind(this._onFocus, this);
                onKeydown = _.bind(this._onKeydown, this);
                onInput = _.bind(this._onInput, this);
                this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                if (!_.isMsie() || _.isMsie() > 9) {
                    this.$input.on("input.tt", onInput);
                } else {
                    this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                        if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                            return;
                        }
                        _.defer(_.bind(that._onInput, that, $e));
                    });
                }
                return this;
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getLangDir: function getLangDir() {
                return this.dir;
            },
            getQuery: function getQuery() {
                return this.query || "";
            },
            setQuery: function setQuery(val, silent) {
                this.setInputValue(val);
                this._setQuery(val, silent);
            },
            hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                return this.query !== this.queryWhenFocused;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value) {
                this.$input.val(value);
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            resetInputValue: function resetInputValue() {
                this.setInputValue(this.query);
            },
            getHint: function getHint() {
                return this.$hint.val();
            },
            setHint: function setHint(value) {
                this.$hint.val(value);
            },
            clearHint: function clearHint() {
                this.setHint("");
            },
            clearHintIfInvalid: function clearHintIfInvalid() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue();
                hint = this.getHint();
                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                !isValid && this.clearHint();
            },
            hasFocus: function hasFocus() {
                return this.$input.is(":focus");
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function() {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$overflowHelper.remove();
                this.$hint = this.$input = this.$overflowHelper = $("<div>");
            }
        });
        return Input;
        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }
        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function() {
        "use strict";
        var keys, nameGenerator;
        keys = {
            val: "tt-selectable-display",
            obj: "tt-selectable-object"
        };
        nameGenerator = _.getIdGenerator();
        function Dataset(o, www) {
            o = o || {};
            o.templates = o.templates || {};
            o.templates.notFound = o.templates.notFound || o.templates.empty;
            if (!o.source) {
                $.error("missing source");
            }
            if (!o.node) {
                $.error("missing node");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            www.mixin(this);
            this.highlight = !!o.highlight;
            this.name = o.name || nameGenerator();
            this.limit = o.limit || 5;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
            this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
            this._resetLastSuggestion();
            this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
        }
        Dataset.extractData = function extractData(el) {
            var $el = $(el);
            if ($el.data(keys.obj)) {
                return {
                    val: $el.data(keys.val) || "",
                    obj: $el.data(keys.obj) || null
                };
            }
            return null;
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _overwrite: function overwrite(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (this.async && this.templates.pending) {
                    this._renderPending(query);
                } else if (!this.async && this.templates.notFound) {
                    this._renderNotFound(query);
                } else {
                    this._empty();
                }
                this.trigger("rendered", this.name, suggestions, false);
            },
            _append: function append(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length && this.$lastSuggestion.length) {
                    this._appendSuggestions(query, suggestions);
                } else if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                    this._renderNotFound(query);
                }
                this.trigger("rendered", this.name, suggestions, true);
            },
            _renderSuggestions: function renderSuggestions(query, suggestions) {
                var $fragment;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                this.$lastSuggestion = $fragment.children().last();
                this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
            },
            _appendSuggestions: function appendSuggestions(query, suggestions) {
                var $fragment, $lastSuggestion;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                $lastSuggestion = $fragment.children().last();
                this.$lastSuggestion.after($fragment);
                this.$lastSuggestion = $lastSuggestion;
            },
            _renderPending: function renderPending(query) {
                var template = this.templates.pending;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _renderNotFound: function renderNotFound(query) {
                var template = this.templates.notFound;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _empty: function empty() {
                this.$el.empty();
                this._resetLastSuggestion();
            },
            _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                var that = this, fragment;
                fragment = document.createDocumentFragment();
                _.each(suggestions, function getSuggestionNode(suggestion) {
                    var $el, context;
                    context = that._injectQuery(query, suggestion);
                    $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                    fragment.appendChild($el[0]);
                });
                this.highlight && highlight({
                    className: this.classes.highlight,
                    node: fragment,
                    pattern: query
                });
                return $(fragment);
            },
            _getFooter: function getFooter(query, suggestions) {
                return this.templates.footer ? this.templates.footer({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _getHeader: function getHeader(query, suggestions) {
                return this.templates.header ? this.templates.header({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _resetLastSuggestion: function resetLastSuggestion() {
                this.$lastSuggestion = $();
            },
            _injectQuery: function injectQuery(query, obj) {
                return _.isObject(obj) ? _.mixin({
                    _query: query
                }, obj) : obj;
            },
            update: function update(query) {
                var that = this, canceled = false, syncCalled = false, rendered = 0;
                this.cancel();
                this.cancel = function cancel() {
                    canceled = true;
                    that.cancel = $.noop;
                    that.async && that.trigger("asyncCanceled", query);
                };
                this.source(query, sync, async);
                !syncCalled && sync([]);
                function sync(suggestions) {
                    if (syncCalled) {
                        return;
                    }
                    syncCalled = true;
                    suggestions = (suggestions || []).slice(0, that.limit);
                    rendered = suggestions.length;
                    that._overwrite(query, suggestions);
                    if (rendered < that.limit && that.async) {
                        that.trigger("asyncRequested", query);
                    }
                }
                function async(suggestions) {
                    suggestions = suggestions || [];
                    if (!canceled && rendered < that.limit) {
                        that.cancel = $.noop;
                        rendered += suggestions.length;
                        that._append(query, suggestions.slice(0, that.limit - rendered));
                        that.async && that.trigger("asyncReceived", query);
                    }
                }
            },
            cancel: $.noop,
            clear: function clear() {
                this._empty();
                this.cancel();
                this.trigger("cleared");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = $("<div>");
            }
        });
        return Dataset;
        function getDisplayFn(display) {
            display = display || _.stringify;
            return _.isFunction(display) ? display : displayFn;
            function displayFn(obj) {
                return obj[display];
            }
        }
        function getTemplates(templates, displayFn) {
            return {
                notFound: templates.notFound && _.templatify(templates.notFound),
                pending: templates.pending && _.templatify(templates.pending),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };
            function suggestionTemplate(context) {
                return $("<div>").text(displayFn(context));
            }
        }
        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Menu = function() {
        "use strict";
        function Menu(o, www) {
            var that = this;
            o = o || {};
            if (!o.node) {
                $.error("node is required");
            }
            www.mixin(this);
            this.$node = $(o.node);
            this.query = null;
            this.datasets = _.map(o.datasets, initializeDataset);
            function initializeDataset(oDataset) {
                var node = that.$node.find(oDataset.node).first();
                oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                return new Dataset(oDataset, www);
            }
        }
        _.mixin(Menu.prototype, EventEmitter, {
            _onSelectableClick: function onSelectableClick($e) {
                this.trigger("selectableClicked", $($e.currentTarget));
            },
            _onRendered: function onRendered(type, dataset, suggestions, async) {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetRendered", dataset, suggestions, async);
            },
            _onCleared: function onCleared() {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetCleared");
            },
            _propagate: function propagate() {
                this.trigger.apply(this, arguments);
            },
            _allDatasetsEmpty: function allDatasetsEmpty() {
                return _.every(this.datasets, isDatasetEmpty);
                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _getSelectables: function getSelectables() {
                return this.$node.find(this.selectors.selectable);
            },
            _removeCursor: function _removeCursor() {
                var $selectable = this.getActiveSelectable();
                $selectable && $selectable.removeClass(this.classes.cursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, nodeScrollTop, nodeHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                nodeScrollTop = this.$node.scrollTop();
                nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$node.scrollTop(nodeScrollTop + elTop);
                } else if (nodeHeight < elBottom) {
                    this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                }
            },
            bind: function() {
                var that = this, onSelectableClick;
                onSelectableClick = _.bind(this._onSelectableClick, this);
                this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                _.each(this.datasets, function(dataset) {
                    dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                });
                return this;
            },
            isOpen: function isOpen() {
                return this.$node.hasClass(this.classes.open);
            },
            open: function open() {
                this.$node.addClass(this.classes.open);
            },
            close: function close() {
                this.$node.removeClass(this.classes.open);
                this._removeCursor();
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.attr("dir", dir);
            },
            selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                var $selectables, $oldCursor, oldIndex, newIndex;
                $oldCursor = this.getActiveSelectable();
                $selectables = this._getSelectables();
                oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                newIndex = oldIndex + delta;
                newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                return newIndex === -1 ? null : $selectables.eq(newIndex);
            },
            setCursor: function setCursor($selectable) {
                this._removeCursor();
                if ($selectable = $selectable && $selectable.first()) {
                    $selectable.addClass(this.classes.cursor);
                    this._ensureVisible($selectable);
                }
            },
            getSelectableData: function getSelectableData($el) {
                return $el && $el.length ? Dataset.extractData($el) : null;
            },
            getActiveSelectable: function getActiveSelectable() {
                var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                return $selectable.length ? $selectable : null;
            },
            getTopSelectable: function getTopSelectable() {
                var $selectable = this._getSelectables().first();
                return $selectable.length ? $selectable : null;
            },
            update: function update(query) {
                var isValidUpdate = query !== this.query;
                if (isValidUpdate) {
                    this.query = query;
                    _.each(this.datasets, updateDataset);
                }
                return isValidUpdate;
                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.query = null;
                this.$node.addClass(this.classes.empty);
                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            destroy: function destroy() {
                this.$node.off(".tt");
                this.$node = $("<div>");
                _.each(this.datasets, destroyDataset);
                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Menu;
    }();
    var DefaultMenu = function() {
        "use strict";
        var s = Menu.prototype;
        function DefaultMenu() {
            Menu.apply(this, [].slice.call(arguments, 0));
        }
        _.mixin(DefaultMenu.prototype, Menu.prototype, {
            open: function open() {
                !this._allDatasetsEmpty() && this._show();
                return s.open.apply(this, [].slice.call(arguments, 0));
            },
            close: function close() {
                this._hide();
                return s.close.apply(this, [].slice.call(arguments, 0));
            },
            _onRendered: function onRendered() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onRendered.apply(this, [].slice.call(arguments, 0));
            },
            _onCleared: function onCleared() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onCleared.apply(this, [].slice.call(arguments, 0));
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
            },
            _hide: function hide() {
                this.$node.hide();
            },
            _show: function show() {
                this.$node.css("display", "block");
            }
        });
        return DefaultMenu;
    }();
    var Typeahead = function() {
        "use strict";
        function Typeahead(o, www) {
            var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            if (!o.menu) {
                $.error("missing menu");
            }
            if (!o.eventBus) {
                $.error("missing event bus");
            }
            www.mixin(this);
            this.eventBus = o.eventBus;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.input = o.input;
            this.menu = o.menu;
            this.enabled = true;
            this.active = false;
            this.input.hasFocus() && this.activate();
            this.dir = this.input.getLangDir();
            this._hacks();
            this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
            onFocused = c(this, "activate", "open", "_onFocused");
            onBlurred = c(this, "deactivate", "_onBlurred");
            onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
            onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
            onEscKeyed = c(this, "isActive", "_onEscKeyed");
            onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
            onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
            onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
            onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
            onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
            onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
            this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
        }
        _.mixin(Typeahead.prototype, {
            _hacks: function hacks() {
                var $input, $menu;
                $input = this.input.$input || $("<div>");
                $menu = this.menu.$node || $("<div>");
                $input.on("blur.tt", function($e) {
                    var active, isActive, hasActive;
                    active = document.activeElement;
                    isActive = $menu.is(active);
                    hasActive = $menu.has(active).length > 0;
                    if (_.isMsie() && (isActive || hasActive)) {
                        $e.preventDefault();
                        $e.stopImmediatePropagation();
                        _.defer(function() {
                            $input.focus();
                        });
                    }
                });
                $menu.on("mousedown.tt", function($e) {
                    $e.preventDefault();
                });
            },
            _onSelectableClicked: function onSelectableClicked(type, $el) {
                this.select($el);
            },
            _onDatasetCleared: function onDatasetCleared() {
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                this._updateHint();
                this.eventBus.trigger("render", suggestions, async, dataset);
            },
            _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                this.eventBus.trigger("asyncrequest", query, dataset);
            },
            _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                this.eventBus.trigger("asynccancel", query, dataset);
            },
            _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                this.eventBus.trigger("asyncreceive", query, dataset);
            },
            _onFocused: function onFocused() {
                this._minLengthMet() && this.menu.update(this.input.getQuery());
            },
            _onBlurred: function onBlurred() {
                if (this.input.hasQueryChangedSinceLastFocus()) {
                    this.eventBus.trigger("change", this.input.getQuery());
                }
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                } else if ($selectable = this.menu.getTopSelectable()) {
                    this.autocomplete($selectable) && $e.preventDefault();
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.close();
            },
            _onUpKeyed: function onUpKeyed() {
                this.moveCursor(-1);
            },
            _onDownKeyed: function onDownKeyed() {
                this.moveCursor(+1);
            },
            _onLeftKeyed: function onLeftKeyed() {
                if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onRightKeyed: function onRightKeyed() {
                if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
            },
            _onLangDirChanged: function onLangDirChanged(e, dir) {
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.menu.setLanguageDirection(dir);
                }
            },
            _openIfActive: function openIfActive() {
                this.isActive() && this.open();
            },
            _minLengthMet: function minLengthMet(query) {
                query = _.isString(query) ? query : this.input.getQuery() || "";
                return query.length >= this.minLength;
            },
            _updateHint: function updateHint() {
                var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                $selectable = this.menu.getTopSelectable();
                data = this.menu.getSelectableData($selectable);
                val = this.input.getInputValue();
                if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                    query = Input.normalizeQuery(val);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                    match = frontMatchRegEx.exec(data.val);
                    match && this.input.setHint(val + match[1]);
                } else {
                    this.input.clearHint();
                }
            },
            isEnabled: function isEnabled() {
                return this.enabled;
            },
            enable: function enable() {
                this.enabled = true;
            },
            disable: function disable() {
                this.enabled = false;
            },
            isActive: function isActive() {
                return this.active;
            },
            activate: function activate() {
                if (this.isActive()) {
                    return true;
                } else if (!this.isEnabled() || this.eventBus.before("active")) {
                    return false;
                } else {
                    this.active = true;
                    this.eventBus.trigger("active");
                    return true;
                }
            },
            deactivate: function deactivate() {
                if (!this.isActive()) {
                    return true;
                } else if (this.eventBus.before("idle")) {
                    return false;
                } else {
                    this.active = false;
                    this.close();
                    this.eventBus.trigger("idle");
                    return true;
                }
            },
            isOpen: function isOpen() {
                return this.menu.isOpen();
            },
            open: function open() {
                if (!this.isOpen() && !this.eventBus.before("open")) {
                    this.menu.open();
                    this._updateHint();
                    this.eventBus.trigger("open");
                }
                return this.isOpen();
            },
            close: function close() {
                if (this.isOpen() && !this.eventBus.before("close")) {
                    this.menu.close();
                    this.input.clearHint();
                    this.input.resetInputValue();
                    this.eventBus.trigger("close");
                }
                return !this.isOpen();
            },
            setVal: function setVal(val) {
                this.input.setQuery(_.toStr(val));
            },
            getVal: function getVal() {
                return this.input.getQuery();
            },
            select: function select($selectable) {
                var data = this.menu.getSelectableData($selectable);
                if (data && !this.eventBus.before("select", data.obj)) {
                    this.input.setQuery(data.val, true);
                    this.eventBus.trigger("select", data.obj);
                    this.close();
                    return true;
                }
                return false;
            },
            autocomplete: function autocomplete($selectable) {
                var query, data, isValid;
                query = this.input.getQuery();
                data = this.menu.getSelectableData($selectable);
                isValid = data && query !== data.val;
                if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                    this.input.setQuery(data.val);
                    this.eventBus.trigger("autocomplete", data.obj);
                    return true;
                }
                return false;
            },
            moveCursor: function moveCursor(delta) {
                var query, $candidate, data, payload, cancelMove;
                query = this.input.getQuery();
                $candidate = this.menu.selectableRelativeToCursor(delta);
                data = this.menu.getSelectableData($candidate);
                payload = data ? data.obj : null;
                cancelMove = this._minLengthMet() && this.menu.update(query);
                if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                    this.menu.setCursor($candidate);
                    if (data) {
                        this.input.setInputValue(data.val);
                    } else {
                        this.input.resetInputValue();
                        this._updateHint();
                    }
                    this.eventBus.trigger("cursorchange", payload);
                    return true;
                }
                return false;
            },
            destroy: function destroy() {
                this.input.destroy();
                this.menu.destroy();
            }
        });
        return Typeahead;
        function c(ctx) {
            var methods = [].slice.call(arguments, 1);
            return function() {
                var args = [].slice.call(arguments);
                _.each(methods, function(method) {
                    return ctx[method].apply(ctx, args);
                });
            };
        }
    }();
    (function() {
        "use strict";
        var old, keys, methods;
        old = $.fn.typeahead;
        keys = {
            www: "tt-www",
            attrs: "tt-attrs",
            typeahead: "tt-typeahead"
        };
        methods = {
            initialize: function initialize(o, datasets) {
                var www;
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                www = WWW(o.classNames);
                return this.each(attach);
                function attach() {
                    var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
                    _.each(datasets, function(d) {
                        d.highlight = !!o.highlight;
                    });
                    $input = $(this);
                    $wrapper = $(www.html.wrapper);
                    $hint = $elOrNull(o.hint);
                    $menu = $elOrNull(o.menu);
                    defaultHint = o.hint !== false && !$hint;
                    defaultMenu = o.menu !== false && !$menu;
                    defaultHint && ($hint = buildHintFromInput($input, www));
                    defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                    $hint && $hint.val("");
                    $input = prepInput($input, www);
                    if (defaultHint || defaultMenu) {
                        $wrapper.css(www.css.wrapper);
                        $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                        $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                    }
                    MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                    eventBus = new EventBus({
                        el: $input
                    });
                    input = new Input({
                        hint: $hint,
                        input: $input
                    }, www);
                    menu = new MenuConstructor({
                        node: $menu,
                        datasets: datasets
                    }, www);
                    typeahead = new Typeahead({
                        input: input,
                        menu: menu,
                        eventBus: eventBus,
                        minLength: o.minLength
                    }, www);
                    $input.data(keys.www, www);
                    $input.data(keys.typeahead, typeahead);
                }
            },
            isEnabled: function isEnabled() {
                var enabled;
                ttEach(this.first(), function(t) {
                    enabled = t.isEnabled();
                });
                return enabled;
            },
            enable: function enable() {
                ttEach(this, function(t) {
                    t.enable();
                });
                return this;
            },
            disable: function disable() {
                ttEach(this, function(t) {
                    t.disable();
                });
                return this;
            },
            isActive: function isActive() {
                var active;
                ttEach(this.first(), function(t) {
                    active = t.isActive();
                });
                return active;
            },
            activate: function activate() {
                ttEach(this, function(t) {
                    t.activate();
                });
                return this;
            },
            deactivate: function deactivate() {
                ttEach(this, function(t) {
                    t.deactivate();
                });
                return this;
            },
            isOpen: function isOpen() {
                var open;
                ttEach(this.first(), function(t) {
                    open = t.isOpen();
                });
                return open;
            },
            open: function open() {
                ttEach(this, function(t) {
                    t.open();
                });
                return this;
            },
            close: function close() {
                ttEach(this, function(t) {
                    t.close();
                });
                return this;
            },
            select: function select(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function(t) {
                    success = t.select($el);
                });
                return success;
            },
            autocomplete: function autocomplete(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function(t) {
                    success = t.autocomplete($el);
                });
                return success;
            },
            moveCursor: function moveCursoe(delta) {
                var success = false;
                ttEach(this.first(), function(t) {
                    success = t.moveCursor(delta);
                });
                return success;
            },
            val: function val(newVal) {
                var query;
                if (!arguments.length) {
                    ttEach(this.first(), function(t) {
                        query = t.getVal();
                    });
                    return query;
                } else {
                    ttEach(this, function(t) {
                        t.setVal(newVal);
                    });
                    return this;
                }
            },
            destroy: function destroy() {
                ttEach(this, function(typeahead, $input) {
                    revert($input);
                    typeahead.destroy();
                });
                return this;
            }
        };
        $.fn.typeahead = function(method) {
            if (methods[method]) {
                return methods[method].apply(this, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };
        function ttEach($els, fn) {
            $els.each(function() {
                var $input = $(this), typeahead;
                (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
            });
        }
        function buildHintFromInput($input, www) {
            return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            });
        }
        function prepInput($input, www) {
            $input.data(keys.attrs, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass(www.classes.input).attr({
                autocomplete: "off",
                spellcheck: false
            });
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input;
        }
        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }
        function revert($input) {
            var www, $wrapper;
            www = $input.data(keys.www);
            $wrapper = $input.parent().filter(www.selectors.wrapper);
            _.each($input.data(keys.attrs), function(val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
            if ($wrapper.length) {
                $input.detach().insertAfter($wrapper);
                $wrapper.remove();
            }
        }
        function $elOrNull(obj) {
            var isValid, $el;
            isValid = _.isJQuery(obj) || _.isElement(obj);
            $el = isValid ? $(obj).first() : [];
            return $el.length ? $el : null;
        }
    })();
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46).setImmediate))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(47);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50), __webpack_require__(48)))

/***/ }),
/* 48 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * typeahead.js 0.11.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
 */

(function(root, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(a0) {
            return root["Bloodhound"] = factory(a0);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        root["Bloodhound"] = factory(jQuery);
    }
})(this, function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            isElement: function(obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function(obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function(x) {
                return x;
            },
            clone: function(obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function(val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function() {}
        };
    }();
    var VERSION = "0.11.1";
    var tokenizers = function() {
        "use strict";
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };
        function whitespace(str) {
            str = _.toStr(str);
            return str ? str.split(/\s+/) : [];
        }
        function nonword(str) {
            str = _.toStr(str);
            return str ? str.split(/\W+/) : [];
        }
        function getObjTokenizer(tokenizer) {
            return function setKey(keys) {
                keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                return function tokenize(o) {
                    var tokens = [];
                    _.each(keys, function(k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    });
                    return tokens;
                };
            };
        }
    }();
    var LruCache = function() {
        "use strict";
        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
            this.reset();
            if (this.maxSize <= 0) {
                this.set = this.get = $.noop;
            }
        }
        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail, node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                    this.size--;
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            },
            reset: function reset() {
                this.size = 0;
                this.hash = {};
                this.list = new List();
            }
        });
        function List() {
            this.head = this.tail = null;
        }
        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function(node) {
                this.remove(node);
                this.add(node);
            }
        });
        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }
        return LruCache;
    }();
    var PersistentStorage = function() {
        "use strict";
        var LOCAL_STORAGE;
        try {
            LOCAL_STORAGE = window.localStorage;
            LOCAL_STORAGE.setItem("~~~", "!");
            LOCAL_STORAGE.removeItem("~~~");
        } catch (err) {
            LOCAL_STORAGE = null;
        }
        function PersistentStorage(namespace, override) {
            this.prefix = [ "__", namespace, "__" ].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
            this.ls = override || LOCAL_STORAGE;
            !this.ls && this._noop();
        }
        _.mixin(PersistentStorage.prototype, {
            _prefix: function(key) {
                return this.prefix + key;
            },
            _ttlKey: function(key) {
                return this._prefix(key) + this.ttlKey;
            },
            _noop: function() {
                this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
            },
            _safeSet: function(key, val) {
                try {
                    this.ls.setItem(key, val);
                } catch (err) {
                    if (err.name === "QuotaExceededError") {
                        this.clear();
                        this._noop();
                    }
                }
            },
            get: function(key) {
                if (this.isExpired(key)) {
                    this.remove(key);
                }
                return decode(this.ls.getItem(this._prefix(key)));
            },
            set: function(key, val, ttl) {
                if (_.isNumber(ttl)) {
                    this._safeSet(this._ttlKey(key), encode(now() + ttl));
                } else {
                    this.ls.removeItem(this._ttlKey(key));
                }
                return this._safeSet(this._prefix(key), encode(val));
            },
            remove: function(key) {
                this.ls.removeItem(this._ttlKey(key));
                this.ls.removeItem(this._prefix(key));
                return this;
            },
            clear: function() {
                var i, keys = gatherMatchingKeys(this.keyMatcher);
                for (i = keys.length; i--; ) {
                    this.remove(keys[i]);
                }
                return this;
            },
            isExpired: function(key) {
                var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                return _.isNumber(ttl) && now() > ttl ? true : false;
            }
        });
        return PersistentStorage;
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return $.parseJSON(val);
        }
        function gatherMatchingKeys(keyMatcher) {
            var i, key, keys = [], len = LOCAL_STORAGE.length;
            for (i = 0; i < len; i++) {
                if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                    keys.push(key.replace(keyMatcher, ""));
                }
            }
            return keys;
        }
    }();
    var Transport = function() {
        "use strict";
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
        function Transport(o) {
            o = o || {};
            this.cancelled = false;
            this.lastReq = null;
            this._send = o.transport;
            this._get = o.limiter ? o.limiter(this._get) : this._get;
            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
        }
        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function resetCache() {
            sharedCache.reset();
        };
        _.mixin(Transport.prototype, {
            _fingerprint: function fingerprint(o) {
                o = o || {};
                return o.url + o.type + $.param(o.data || {});
            },
            _get: function(o, cb) {
                var that = this, fingerprint, jqXhr;
                fingerprint = this._fingerprint(o);
                if (this.cancelled || fingerprint !== this.lastReq) {
                    return;
                }
                if (jqXhr = pendingRequests[fingerprint]) {
                    jqXhr.done(done).fail(fail);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }
                function done(resp) {
                    cb(null, resp);
                    that._cache.set(fingerprint, resp);
                }
                function fail() {
                    cb(true);
                }
                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[fingerprint];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function(o, cb) {
                var resp, fingerprint;
                cb = cb || $.noop;
                o = _.isString(o) ? {
                    url: o
                } : o || {};
                fingerprint = this._fingerprint(o);
                this.cancelled = false;
                this.lastReq = fingerprint;
                if (resp = this._cache.get(fingerprint)) {
                    cb(null, resp);
                } else {
                    this._get(o, cb);
                }
            },
            cancel: function() {
                this.cancelled = true;
            }
        });
        return Transport;
    }();
    var SearchIndex = window.SearchIndex = function() {
        "use strict";
        var CHILDREN = "c", IDS = "i";
        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.identify = o.identify || _.stringify;
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.reset();
        }
        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function(data) {
                var that = this;
                data = _.isArray(data) ? data : [ data ];
                _.each(data, function(datum) {
                    var id, tokens;
                    that.datums[id = that.identify(datum)] = datum;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function(token) {
                        var node, chars, ch;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                            node[IDS].push(id);
                        }
                    });
                });
            },
            get: function get(ids) {
                var that = this;
                return _.map(ids, function(id) {
                    return that.datums[id];
                });
            },
            search: function search(query) {
                var that = this, tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function(token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node[CHILDREN][ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node[IDS].slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function(id) {
                    return that.datums[id];
                }) : [];
            },
            all: function all() {
                var values = [];
                for (var key in this.datums) {
                    values.push(this.datums[key]);
                }
                return values;
            },
            reset: function reset() {
                this.datums = {};
                this.trie = newNode();
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;
        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function(token) {
                return !!token;
            });
            tokens = _.map(tokens, function(token) {
                return token.toLowerCase();
            });
            return tokens;
        }
        function newNode() {
            var node = {};
            node[IDS] = [];
            node[CHILDREN] = {};
            return node;
        }
        function unique(array) {
            var seen = {}, uniques = [];
            for (var i = 0, len = array.length; i < len; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }
        function getIntersection(arrayA, arrayB) {
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort();
            arrayB = arrayB.sort();
            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
            while (ai < lenArrayA && bi < lenArrayB) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;
        }
    }();
    var Prefetch = function() {
        "use strict";
        var keys;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };
        function Prefetch(o) {
            this.url = o.url;
            this.ttl = o.ttl;
            this.cache = o.cache;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = o.transport;
            this.thumbprint = o.thumbprint;
            this.storage = new PersistentStorage(o.cacheKey);
        }
        _.mixin(Prefetch.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            store: function store(data) {
                if (!this.cache) {
                    return;
                }
                this.storage.set(keys.data, data, this.ttl);
                this.storage.set(keys.protocol, location.protocol, this.ttl);
                this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
            },
            fromCache: function fromCache() {
                var stored = {}, isExpired;
                if (!this.cache) {
                    return null;
                }
                stored.data = this.storage.get(keys.data);
                stored.protocol = this.storage.get(keys.protocol);
                stored.thumbprint = this.storage.get(keys.thumbprint);
                isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            fromNetwork: function(cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                settings = this.prepare(this._settings());
                this.transport(settings).fail(onError).done(onResponse);
                function onError() {
                    cb(true);
                }
                function onResponse(resp) {
                    cb(null, that.transform(resp));
                }
            },
            clear: function clear() {
                this.storage.clear();
                return this;
            }
        });
        return Prefetch;
    }();
    var Remote = function() {
        "use strict";
        function Remote(o) {
            this.url = o.url;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = new Transport({
                cache: o.cache,
                limiter: o.limiter,
                transport: o.transport
            });
        }
        _.mixin(Remote.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            get: function get(query, cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                query = query || "";
                settings = this.prepare(query, this._settings());
                return this.transport.get(settings, onResponse);
                function onResponse(err, resp) {
                    err ? cb([]) : cb(that.transform(resp));
                }
            },
            cancelLastRequest: function cancelLastRequest() {
                this.transport.cancel();
            }
        });
        return Remote;
    }();
    var oParser = function() {
        "use strict";
        return function parse(o) {
            var defaults, sorter;
            defaults = {
                initialize: true,
                identify: _.stringify,
                datumTokenizer: null,
                queryTokenizer: null,
                sufficient: 5,
                sorter: null,
                local: [],
                prefetch: null,
                remote: null
            };
            o = _.mixin(defaults, o || {});
            !o.datumTokenizer && $.error("datumTokenizer is required");
            !o.queryTokenizer && $.error("queryTokenizer is required");
            sorter = o.sorter;
            o.sorter = sorter ? function(x) {
                return x.sort(sorter);
            } : _.identity;
            o.local = _.isFunction(o.local) ? o.local() : o.local;
            o.prefetch = parsePrefetch(o.prefetch);
            o.remote = parseRemote(o.remote);
            return o;
        };
        function parsePrefetch(o) {
            var defaults;
            if (!o) {
                return null;
            }
            defaults = {
                url: null,
                ttl: 24 * 60 * 60 * 1e3,
                cache: true,
                cacheKey: null,
                thumbprint: "",
                prepare: _.identity,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("prefetch requires url to be set");
            o.transform = o.filter || o.transform;
            o.cacheKey = o.cacheKey || o.url;
            o.thumbprint = VERSION + o.thumbprint;
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            return o;
        }
        function parseRemote(o) {
            var defaults;
            if (!o) {
                return;
            }
            defaults = {
                url: null,
                cache: true,
                prepare: null,
                replace: null,
                wildcard: null,
                limiter: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("remote requires url to be set");
            o.transform = o.filter || o.transform;
            o.prepare = toRemotePrepare(o);
            o.limiter = toLimiter(o);
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            delete o.replace;
            delete o.wildcard;
            delete o.rateLimitBy;
            delete o.rateLimitWait;
            return o;
        }
        function toRemotePrepare(o) {
            var prepare, replace, wildcard;
            prepare = o.prepare;
            replace = o.replace;
            wildcard = o.wildcard;
            if (prepare) {
                return prepare;
            }
            if (replace) {
                prepare = prepareByReplace;
            } else if (o.wildcard) {
                prepare = prepareByWildcard;
            } else {
                prepare = idenityPrepare;
            }
            return prepare;
            function prepareByReplace(query, settings) {
                settings.url = replace(settings.url, query);
                return settings;
            }
            function prepareByWildcard(query, settings) {
                settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                return settings;
            }
            function idenityPrepare(query, settings) {
                return settings;
            }
        }
        function toLimiter(o) {
            var limiter, method, wait;
            limiter = o.limiter;
            method = o.rateLimitBy;
            wait = o.rateLimitWait;
            if (!limiter) {
                limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
            }
            return limiter;
            function debounce(wait) {
                return function debounce(fn) {
                    return _.debounce(fn, wait);
                };
            }
            function throttle(wait) {
                return function throttle(fn) {
                    return _.throttle(fn, wait);
                };
            }
        }
        function callbackToDeferred(fn) {
            return function wrapper(o) {
                var deferred = $.Deferred();
                fn(o, onSuccess, onError);
                return deferred;
                function onSuccess(resp) {
                    _.defer(function() {
                        deferred.resolve(resp);
                    });
                }
                function onError(err) {
                    _.defer(function() {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var Bloodhound = function() {
        "use strict";
        var old;
        old = window && window.Bloodhound;
        function Bloodhound(o) {
            o = oParser(o);
            this.sorter = o.sorter;
            this.identify = o.identify;
            this.sufficient = o.sufficient;
            this.local = o.local;
            this.remote = o.remote ? new Remote(o.remote) : null;
            this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
            this.index = new SearchIndex({
                identify: this.identify,
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            o.initialize !== false && this.initialize();
        }
        Bloodhound.noConflict = function noConflict() {
            window && (window.Bloodhound = old);
            return Bloodhound;
        };
        Bloodhound.tokenizers = tokenizers;
        _.mixin(Bloodhound.prototype, {
            __ttAdapter: function ttAdapter() {
                var that = this;
                return this.remote ? withAsync : withoutAsync;
                function withAsync(query, sync, async) {
                    return that.search(query, sync, async);
                }
                function withoutAsync(query, sync) {
                    return that.search(query, sync);
                }
            },
            _loadPrefetch: function loadPrefetch() {
                var that = this, deferred, serialized;
                deferred = $.Deferred();
                if (!this.prefetch) {
                    deferred.resolve();
                } else if (serialized = this.prefetch.fromCache()) {
                    this.index.bootstrap(serialized);
                    deferred.resolve();
                } else {
                    this.prefetch.fromNetwork(done);
                }
                return deferred.promise();
                function done(err, data) {
                    if (err) {
                        return deferred.reject();
                    }
                    that.add(data);
                    that.prefetch.store(that.index.serialize());
                    deferred.resolve();
                }
            },
            _initialize: function initialize() {
                var that = this, deferred;
                this.clear();
                (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                return this.initPromise;
                function addLocalToIndex() {
                    that.add(that.local);
                }
            },
            initialize: function initialize(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function add(data) {
                this.index.add(data);
                return this;
            },
            get: function get(ids) {
                ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                return this.index.get(ids);
            },
            search: function search(query, sync, async) {
                var that = this, local;
                local = this.sorter(this.index.search(query));
                sync(this.remote ? local.slice() : local);
                if (this.remote && local.length < this.sufficient) {
                    this.remote.get(query, processRemote);
                } else if (this.remote) {
                    this.remote.cancelLastRequest();
                }
                return this;
                function processRemote(remote) {
                    var nonDuplicates = [];
                    _.each(remote, function(r) {
                        !_.some(local, function(l) {
                            return that.identify(r) === that.identify(l);
                        }) && nonDuplicates.push(r);
                    });
                    async && async(nonDuplicates);
                }
            },
            all: function all() {
                return this.index.all();
            },
            clear: function clear() {
                this.index.reset();
                return this;
            },
            clearPrefetchCache: function clearPrefetchCache() {
                this.prefetch && this.prefetch.clear();
                return this;
            },
            clearRemoteCache: function clearRemoteCache() {
                Transport.resetCache();
                return this;
            },
            ttAdapter: function ttAdapter() {
                return this.__ttAdapter();
            }
        });
        return Bloodhound;
    }();
    return Bloodhound;
});

/***/ }),
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _undefined = __webpack_require__(111)(); // Support ES3 engines

module.exports = function (val) {
 return (val !== _undefined) && (val !== null);
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(197)()
	? Object.assign
	: __webpack_require__(198);


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(211)() ? Symbol : __webpack_require__(212);


/***/ }),
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/* Accessible tab interface
/* Courtesy of http://heydonworks.com/practical_aria_examples/
-----------------------------------------------------------------------------------------
*/

var $ = __webpack_require__(0);
var URI = __webpack_require__(8);
var _ = __webpack_require__(2);

var events = __webpack_require__(14);

var analytics = __webpack_require__(15);

// The class for the container div

var $container = '.tab-interface';

function show($target, push) {
  // Toggle tabs
  $('[role="tab"]').attr({
    'aria-selected': null
  });
  $target.attr({
    'aria-selected': 'true',
  });

  // Toggle panels
  $($container + ' [role="tabpanel"]').attr('aria-hidden', 'true');
  var $panel = $('#' + $target.attr('href').substring(1));
  $panel.attr('aria-hidden', null);

  var name = $target.closest('[role="tablist"]').attr('data-name');
  var value = $target.attr('data-name');

  if (push) {
    var query = _.extend(
      URI.parseQuery(window.location.search),
      _.object([[name, value]])
    );
    var search = URI('').query(query).toString();
    window.history.pushState(query, search, search || window.location.pathname);
    analytics.pageView();
  }

  events.emit('tabs.show.' + value, {$tab: $target, $panel: $panel});
}

function refreshTabs() {
  var query = URI.parseQuery(window.location.search);
  $('ul[role="tablist"]').each(function(index, tabs) {
    var $tabs = $(tabs);
    var name = $tabs.attr('data-name');
    var $target = query[name] ?
      $tabs.find('[role="tab"][data-name="' + query[name] + '"]') :
      $tabs.find('[role="tab"]').eq(0);
    if ($target.length) {
      show($target);
    } else {
      $('[role="tabpanel"]').attr('aria-hidden', null);
    }
  });
}

function onShow($elm, callback) {
  var $panel = $elm.closest('[role="tabpanel"]');
  if ($panel.is(':visible')) {
    callback();
  } else {
    var $trigger = $('[href="#' + $panel.attr('id') + '"]');
    var event = 'tabs.show.' + $trigger.attr('data-name');
    events.once(event, callback);
  }
}

function init() {
  // Handle click on tab to show + focus tabpanel
  $('[role="tab"]').on('click', function(e) {
    e.preventDefault();
    show($(this), true);
  });

  $(window).on('popstate', refreshTabs);
  refreshTabs();
}

module.exports = {
  onShow: onShow,
  init: init,
};


/***/ }),
/* 62 */,
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(51);

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
module.exports = function (opts1 /*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(202)()
	? String.prototype.contains
	: __webpack_require__(203);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString
  , id = objToString.call(
	(function () {
		return arguments;
	})()
);

module.exports = function (value) {
	return objToString.call(value) === id;
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString, id = objToString.call("");

module.exports = function (value) {
	return (
		typeof value === "string" ||
		(value &&
			typeof value === "object" &&
			(value instanceof String || objToString.call(value) === id)) ||
		false
	);
};


/***/ }),
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(108)()
	? Object.setPrototypeOf
	: __webpack_require__(109);


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Deprecated



module.exports = function (obj) {
 return typeof obj === "function";
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(52)
  , normalizeOpts = __webpack_require__(63)
  , isCallable    = __webpack_require__(85)
  , contains      = __webpack_require__(64)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 87 */
/***/ (function(module, exports) {

/**
 * @module Icicle
 */
module.exports = {
	freeze: lock,
	unfreeze: unlock,
	isFrozen: isLocked
};


/** Set of targets  */
var lockCache = new WeakMap;


/**
 * Set flag on target with the name passed
 *
 * @return {bool} Whether lock succeeded
 */
function lock(target, name){
	var locks = lockCache.get(target);
	if (locks && locks[name]) return false;

	//create lock set for a target, if none
	if (!locks) {
		locks = {};
		lockCache.set(target, locks);
	}

	//set a new lock
	locks[name] = true;

	//return success
	return true;
}


/**
 * Unset flag on the target with the name passed.
 *
 * Note that if to return new value from the lock/unlock,
 * then unlock will always return false and lock will always return true,
 * which is useless for the user, though maybe intuitive.
 *
 * @param {*} target Any object
 * @param {string} name A flag name
 *
 * @return {bool} Whether unlock failed.
 */
function unlock(target, name){
	var locks = lockCache.get(target);
	if (!locks || !locks[name]) return false;

	locks[name] = null;

	return true;
}


/**
 * Return whether flag is set
 *
 * @param {*} target Any object to associate lock with
 * @param {string} name A flag name
 *
 * @return {Boolean} Whether locked or not
 */
function isLocked(target, name){
	var locks = lockCache.get(target);
	return (locks && locks[name]);
}

/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * A storage of per-target callbacks.
 * WeakMap is the most safe solution.
 *
 * @module emmy/listeners
 */


/**
 * Property name to provide on targets.
 *
 * Cant use global WeakMap -
 * it is impossible to provide singleton global cache of callbacks for targets
 * not polluting global scope. So it is better to pollute target scope than the global.
 *
 * Otherwise, each emmy instance will create its own cache, which leads to mess.
 *
 * Also cant use `._events` property on targets, as it is done in `events` module,
 * because it is incompatible. Emmy targets universal events wrapper, not the native implementation.
 *
 */
//FIXME: new npm forces flat modules structure, so weakmaps are better providing that theres the one emmy across the project.
var cbPropName = '_callbacks';


/**
 * Get listeners for the target/evt (optionally).
 *
 * @param {object} target a target object
 * @param {string}? evt an evt name, if undefined - return object with events
 *
 * @return {(object|array)} List/set of listeners
 */
function listeners(target, evt, tags){
	var cbs = target[cbPropName];
	var result;

	if (!evt) {
		result = cbs || {};

		//filter cbs by tags
		if (tags) {
			var filteredResult = {};
			for (var evt in result) {
				filteredResult[evt] = result[evt].filter(function (cb) {
					return hasTags(cb, tags);
				});
			}
			result = filteredResult;
		}

		return result;
	}

	if (!cbs || !cbs[evt]) {
		return [];
	}

	result = cbs[evt];

	//if there are evt namespaces specified - filter callbacks
	if (tags && tags.length) {
		result = result.filter(function (cb) {
			return hasTags(cb, tags);
		});
	}

	return result;
}


/**
 * Remove listener, if any
 */
listeners.remove = function(target, evt, cb, tags){
	//get callbacks for the evt
	var evtCallbacks = target[cbPropName];
	if (!evtCallbacks || !evtCallbacks[evt]) return false;

	var callbacks = evtCallbacks[evt];

	//if tags are passed - make sure callback has some tags before removing
	if (tags && tags.length && !hasTags(cb, tags)) return false;

	//remove specific handler
	for (var i = 0; i < callbacks.length; i++) {
		//once method has original callback in .cb
		if (callbacks[i] === cb || callbacks[i].fn === cb) {
			callbacks.splice(i, 1);
			break;
		}
	}
};


/**
 * Add a new listener
 */
listeners.add = function(target, evt, cb, tags){
	if (!cb) return;

	var targetCallbacks = target[cbPropName];

	//ensure set of callbacks for the target exists
	if (!targetCallbacks) {
		targetCallbacks = {};
		Object.defineProperty(target, cbPropName, {
			value: targetCallbacks
		});
	}

	//save a new callback
	(targetCallbacks[evt] = targetCallbacks[evt] || []).push(cb);

	//save ns for a callback, if any
	if (tags && tags.length) {
		cb._ns = tags;
	}
};


/** Detect whether an cb has at least one tag from the list */
function hasTags(cb, tags){
	if (cb._ns) {
		//if cb is tagged with a ns and includes one of the ns passed - keep it
		for (var i = tags.length; i--;){
			if (cb._ns.indexOf(tags[i]) >= 0) return true;
		}
	}
}


module.exports = listeners;

/***/ }),
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

module.exports = function (/* CustomCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== "function") return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-proto: "off" */

// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject        = __webpack_require__(110)
  , value           = __webpack_require__(16)
  , objIsPrototypOf = Object.prototype.isPrototypeOf
  , defineProperty  = Object.defineProperty
  , nullDesc        = {
	configurable: true,
	enumerable: false,
	writable: true,
	value: undefined
}
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if (prototype === null || isObject(prototype)) return obj;
	throw new TypeError("Prototype must be null or an object");
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self (obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = objIsPrototypOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, "level", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: status.level
	});
}(
	(function () {
		var tmpObj1 = Object.create(null)
		  , tmpObj2 = {}
		  , set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(tmpObj1, tmpObj2);
			} catch (ignore) {}
			if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
		}

		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

		tmpObj1 = {};
		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

		return false;
	})()
));

__webpack_require__(193);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(51);

var map = { function: true, object: true };

module.exports = function (value) {
	return (isValue(value) && map[typeof value]) || false;
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// eslint-disable-next-line no-empty-function
module.exports = function () {};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(65)
  , isString       = __webpack_require__(66)
  , ArrayIterator  = __webpack_require__(204)
  , StringIterator = __webpack_require__(225)
  , iterable       = __webpack_require__(226)
  , iteratorSymbol = __webpack_require__(53).iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(205)
  , assign   = __webpack_require__(52)
  , callable = __webpack_require__(21)
  , value    = __webpack_require__(16)
  , d        = __webpack_require__(86)
  , autoBind = __webpack_require__(206)
  , Symbol   = __webpack_require__(53)

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var extend = __webpack_require__(230).extend;

var defaultOpts = {
  collapseOthers: false,
  customHiding: false,
  contentPrefix: 'accordion',
  openFirst: false
};

var defaultSelectors = {
  trigger: 'button'
};

/**
 * Creates a new accordion component
 * @constructor
 * @param {Element} elm - The element that contains the entire accordion
 * @param {object} selectors - Selectors for locating DOM elements
 * @param {object} opts - Options for configuring behavior
 */

var Accordion = function(elm, selectors, opts) {
  this.elm = elm;
  this.selectors = extend({}, defaultSelectors, selectors);
  this.opts = extend({}, defaultOpts, opts);

  this.triggers = this.findTriggers();

  this.listeners = [];
  this.addEventListener(this.elm, 'click', this.handleClickElm.bind(this));

  if (this.opts.openFirst) {
    this.expand(this.triggers[0]);
  }
};

Accordion.prototype.handleClickElm = function(e) {
  // If the target is the button, toggle the button
  // Else see if the target is a child of a button
  if (this.triggers.indexOf(e.target) > -1) {
    this.toggle(e.target);
  } else {
    var self = this;
    this.triggers.forEach(function(trigger){
      if (e.target.parentElement === trigger) {
        self.toggle(trigger);
      }
    });
  }
};

Accordion.prototype.findTriggers = function() {
  var self = this;
  var triggers = [].slice.call(this.elm.querySelectorAll(this.selectors.trigger));
  triggers.forEach(function(trigger, index) {
    self.setAria(trigger, index);
  });
  return triggers;
};

Accordion.prototype.setAria = function(trigger, index) {
  var content = trigger.nextElementSibling;
  var contentID;

  if (content.hasAttribute('id')) {
    contentID = content.getAttribute('id');
  } else {
    contentID = this.opts.contentPrefix + '-' + 'content-' + index;
    content.setAttribute('id', contentID);
  }

  trigger.setAttribute('aria-controls', contentID);
  trigger.setAttribute('aria-expanded', 'false');
  content.setAttribute('aria-hidden', 'true');
  this.setStyles(content);
};

Accordion.prototype.toggle = function(elm) {
  var f = elm.getAttribute('aria-expanded') === 'true' ? this.collapse : this.expand;
  f.call(this, elm);
};

Accordion.prototype.expand = function(button) {
  if (this.opts.collapseOthers) {
    this.collapseAll();
  }
  var content = document.getElementById(button.getAttribute('aria-controls'));
  button.setAttribute('aria-expanded', 'true');
  content.setAttribute('aria-hidden', 'false');
  this.setStyles(content);
};

Accordion.prototype.collapse = function(button) {
  var content = document.getElementById(button.getAttribute('aria-controls'));
  button.setAttribute('aria-expanded', 'false');
  content.setAttribute('aria-hidden', 'true');
  this.setStyles(content);
};

Accordion.prototype.collapseAll = function() {
  var self = this;
  this.triggers.forEach(function(trigger) {
    self.collapse(trigger);
  });
};

Accordion.prototype.expandAll = function() {
  var self = this;
  this.triggers.forEach(function(trigger) {
    self.expand(trigger);
  });
};

Accordion.prototype.setStyles = function(content) {
  var prop = content.getAttribute('aria-hidden') === 'true' ? 'none' : 'block';

  if (!this.opts.customHiding) {
    content.style.display = prop;
  }
};

Accordion.prototype.addEventListener = function(elm, event, callback) {
  if (elm) {
    elm.addEventListener(event, callback);
    this.listeners.push({
      elm: elm,
      event: event,
      callback: callback
    });
  }
};

Accordion.prototype.destroy = function() {
  this.listeners.forEach(function(listener) {
    listener.elm.removeEventListener(listener.event, listener.callback);
  });
};

module.exports = { Accordion: Accordion };


/***/ }),
/* 115 */
/***/ (function(module, exports) {

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};


/***/ }),
/* 116 */
/***/ (function(module, exports) {

/**
 * Source: https://github.com/timoxley/to-array
 *
 * Convert an array-like object into an `Array`.
 * If `collection` is already an `Array`, then will return a clone of `collection`.
 *
 * @param {Array | Mixed} collection An `Array` or array-like object to convert e.g. `arguments` or `NodeList`
 * @return {Array} Naive conversion of `collection` to a new `Array`.
 * @api public
 */

module.exports = function toArray(collection) {
  if (typeof collection === 'undefined') return [];
  if (collection === null) return [null];
  if (collection === window) return [window];
  if (typeof collection === 'string') return [collection];
  if (isArray(collection)) return collection;
  if (typeof collection.length != 'number') return [collection];
  if (typeof collection === 'function' && collection instanceof Function) return [collection];

  var arr = [];
  for (var i = 0; i < collection.length; i++) {
    if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
      arr.push(collection[i]);
    }
  }
  if (!arr.length) return [];
  return arr;
};

function isArray(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
}


/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function(list) {
  return function(initValues, element, notCreate) {
    var item = this;

    this._values = {};

    this.found = false; // Show if list.searched == true and this.found == true
    this.filtered = false;// Show if list.filtered == true and this.filtered == true

    var init = function(initValues, element, notCreate) {
      if (element === undefined) {
        if (notCreate) {
          item.values(initValues, notCreate);
        } else {
          item.values(initValues);
        }
      } else {
        item.elm = element;
        var values = list.templater.get(item, initValues);
        item.values(values);
      }
    };

    this.values = function(newValues, notCreate) {
      if (newValues !== undefined) {
        for(var name in newValues) {
          item._values[name] = newValues[name];
        }
        if (notCreate !== true) {
          list.templater.set(item, item.values());
        }
      } else {
        return item._values;
      }
    };

    this.show = function() {
      list.templater.show(item);
    };

    this.hide = function() {
      list.templater.hide(item);
    };

    this.matching = function() {
      return (
        (list.filtered && list.searched && item.found && item.filtered) ||
        (list.filtered && !list.searched && item.filtered) ||
        (!list.filtered && list.searched && item.found) ||
        (!list.filtered && !list.searched)
      );
    };

    this.visible = function() {
      return (item.elm && (item.elm.parentNode == list.list)) ? true : false;
    };

    init(initValues, element, notCreate);
  };
};


/***/ }),
/* 118 */
/***/ (function(module, exports) {


/**
 * An Array.prototype.slice.call(arguments) alternative
 *
 * @param {Object} args something with a length
 * @param {Number} slice
 * @param {Number} sliceEnd
 * @api public
 */

module.exports = function (args, slice, sliceEnd) {
  var ret = [];
  var len = args.length;

  if (0 === len) return ret;

  var start = slice < 0
    ? Math.max(0, slice + len)
    : slice || 0;

  if (sliceEnd !== undefined) {
    len = sliceEnd < 0
      ? sliceEnd + len
      : sliceEnd
  }

  while (len-- > start) {
    ret[len - start] = args[len];
  }

  return ret;
}



/***/ }),
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!__webpack_require__(190)()) {
	Object.defineProperty(__webpack_require__(191), 'WeakMap',
		{ value: __webpack_require__(192), configurable: true, enumerable: false,
			writable: true });
}


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var weakMap, x;
	if (typeof WeakMap !== 'function') return false;
	try {
		// WebKit doesn't support arguments and crashes
		weakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);
	} catch (e) {
		return false;
	}
	if (String(weakMap) !== '[object WeakMap]') return false;
	if (typeof weakMap.set !== 'function') return false;
	if (weakMap.set({}, 1) !== weakMap) return false;
	if (typeof weakMap.delete !== 'function') return false;
	if (typeof weakMap.has !== 'function') return false;
	if (weakMap.get(x) !== 'one') return false;

	return true;
};


/***/ }),
/* 191 */
/***/ (function(module, exports) {

/* eslint strict: "off" */

module.exports = (function () {
	return this;
}());


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf    = __webpack_require__(84)
  , object            = __webpack_require__(194)
  , value             = __webpack_require__(16)
  , randomUniq        = __webpack_require__(195)
  , d                 = __webpack_require__(196)
  , getIterator       = __webpack_require__(112)
  , forOf             = __webpack_require__(228)
  , toStringTagSymbol = __webpack_require__(53).toStringTag
  , isNative          = __webpack_require__(229)

  , isArray = Array.isArray, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf
  , WeakMapPoly;

module.exports = WeakMapPoly = function (/*iterable*/) {
	var iterable = arguments[0], self;
	if (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {
		self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) {
		if (!isArray(iterable)) iterable = getIterator(iterable);
	}
	defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
	if (!iterable) return self;
	forOf(iterable, function (val) {
		value(val);
		self.set(val[0], val[1]);
	});
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
	WeakMapPoly.prototype = Object.create(WeakMap.prototype, {
		constructor: d(WeakMapPoly)
	});
}

Object.defineProperties(WeakMapPoly.prototype, {
	delete: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			delete key[this.__weakMapData__];
			return true;
		}
		return false;
	}),
	get: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			return key[this.__weakMapData__];
		}
	}),
	has: d(function (key) {
		return hasOwnProperty.call(object(key), this.__weakMapData__);
	}),
	set: d(function (key, value) {
		defineProperty(object(key), this.__weakMapData__, d('c', value));
		return this;
	}),
	toString: d(function () { return '[object WeakMap]'; })
});
defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(108)()) {
	shim = __webpack_require__(109);
}

module.exports = (function () {
	var nullObject, polyProps, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	polyProps = {};
	desc = {
		configurable: false,
		enumerable: false,
		writable: true,
		value: undefined
	};
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === "__proto__") {
			polyProps[name] = {
				configurable: true,
				enumerable: false,
				writable: true,
				value: undefined
			};
			return;
		}
		polyProps[name] = desc;
	});
	Object.defineProperties(nullObject, polyProps);

	Object.defineProperty(shim, "nullPolyfill", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: nullObject
	});

	return function (prototype, props) {
		return create(prototype === null ? nullObject : prototype, props);
	};
}());


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(110);

module.exports = function (value) {
	if (!isObject(value)) throw new TypeError(value + " is not an Object");
	return value;
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generated = Object.create(null)

  , random = Math.random;

module.exports = function () {
	var str;
	do {
 str = random().toString(36).slice(2);
} while (generated[str]);
	return str;
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(52)
  , normalizeOpts = __webpack_require__(63)
  , isCallable    = __webpack_require__(85)
  , contains      = __webpack_require__(64)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(199)
  , value = __webpack_require__(16)
  , max   = Math.max;

module.exports = function (dest, src /*, srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(200)()
	? Object.keys
	: __webpack_require__(201);


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
 return false;
}
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(51);

var keys = Object.keys;

module.exports = function (object) {
	return keys(isValue(object) ? Object(object) : object);
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = "razdwatrzy";

module.exports = function () {
	if (typeof str.contains !== "function") return false;
	return (str.contains("dwa") === true) && (str.contains("foo") === false);
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(84)
  , contains       = __webpack_require__(64)
  , d              = __webpack_require__(86)
  , Iterator       = __webpack_require__(113)

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(16);

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copy             = __webpack_require__(207)
  , normalizeOptions = __webpack_require__(63)
  , ensureCallable   = __webpack_require__(21)
  , map              = __webpack_require__(222)
  , callable         = __webpack_require__(21)
  , validValue       = __webpack_require__(16)

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, options) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, options*/) {
	var options = normalizeOptions(arguments[1]);
	if (options.resolveContext != null) ensureCallable(options.resolveContext);
	return map(props, function (desc, name) { return define(name, desc, options); });
};


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFrom  = __webpack_require__(208)
  , assign = __webpack_require__(52)
  , value  = __webpack_require__(16);

module.exports = function (obj/*, propertyNames, options*/) {
	var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
	if (copy !== obj && !propertyNames) return copy;
	var result = {};
	if (propertyNames) {
		aFrom(propertyNames, function (propertyName) {
			if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
		});
	} else {
		assign(result, obj);
	}
	return result;
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(209)()
	? Array.from
	: __webpack_require__(210);


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var from = Array.from, arr, result;
	if (typeof from !== "function") return false;
	arr = ["raz", "dwa"];
	result = from(arr);
	return Boolean(result && (result !== arr) && (result[1] === "dwa"));
};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var iteratorSymbol = __webpack_require__(53).iterator
  , isArguments    = __webpack_require__(65)
  , isFunction     = __webpack_require__(216)
  , toPosInt       = __webpack_require__(217)
  , callable       = __webpack_require__(21)
  , validValue     = __webpack_require__(16)
  , isValue        = __webpack_require__(51)
  , isString       = __webpack_require__(66)
  , isArray        = Array.isArray
  , call           = Function.prototype.call
  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
  , defineProperty = Object.defineProperty;

// eslint-disable-next-line complexity
module.exports = function (arrayLike /*, mapFn, thisArg*/) {
	var mapFn = arguments[1]
	  , thisArg = arguments[2]
	  , Context
	  , i
	  , j
	  , arr
	  , length
	  , code
	  , iterator
	  , result
	  , getIterator
	  , value;

	arrayLike = Object(validValue(arrayLike));

	if (isValue(mapFn)) callable(mapFn);
	if (!this || this === Array || !isFunction(this)) {
		// Result: Plain array
		if (!mapFn) {
			if (isArguments(arrayLike)) {
				// Source: Arguments
				length = arrayLike.length;
				if (length !== 1) return Array.apply(null, arrayLike);
				arr = new Array(1);
				arr[0] = arrayLike[0];
				return arr;
			}
			if (isArray(arrayLike)) {
				// Source: Array
				arr = new Array(length = arrayLike.length);
				for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
				return arr;
			}
		}
		arr = [];
	} else {
		// Result: Non plain array
		Context = this;
	}

	if (!isArray(arrayLike)) {
		if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
			// Source: Iterator
			iterator = callable(getIterator).call(arrayLike);
			if (Context) arr = new Context();
			result = iterator.next();
			i = 0;
			while (!result.done) {
				value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, i, desc);
				} else {
					arr[i] = value;
				}
				result = iterator.next();
				++i;
			}
			length = i;
		} else if (isString(arrayLike)) {
			// Source: String
			length = arrayLike.length;
			if (Context) arr = new Context();
			for (i = 0, j = 0; i < length; ++i) {
				value = arrayLike[i];
				if (i + 1 < length) {
					code = value.charCodeAt(0);
					// eslint-disable-next-line max-depth
					if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
				}
				value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, j, desc);
				} else {
					arr[j] = value;
				}
				++j;
			}
			length = j;
		}
	}
	if (length === undefined) {
		// Source: array or array-like
		length = toPosInt(arrayLike.length);
		if (Context) arr = new Context(length);
		for (i = 0; i < length; ++i) {
			value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
			if (Context) {
				desc.value = value;
				defineProperty(arr, i, desc);
			} else {
				arr[i] = value;
			}
		}
	}
	if (Context) {
		desc.value = null;
		arr.length = length;
	}
	return arr;
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var validTypes = { object: true, symbol: true };

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not (or partially) support it



var d              = __webpack_require__(213)
  , validateSymbol = __webpack_require__(214)

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
  , isNativeSafe;

if (typeof Symbol === 'function') {
	NativeSymbol = Symbol;
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
}

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	// To ensure proper interoperability with other native functions (e.g. Array.from)
	// fallback to eventual native implementation of given symbol
	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
	var symbol = validateSymbol(this);
	if (typeof symbol === 'symbol') return symbol;
	return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign        = __webpack_require__(52)
  , normalizeOpts = __webpack_require__(63)
  , isCallable    = __webpack_require__(85)
  , contains      = __webpack_require__(64)

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(215);

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (x) {
	if (!x) return false;
	if (typeof x === 'symbol') return true;
	if (!x.constructor) return false;
	if (x.constructor.name !== 'Symbol') return false;
	return (x[x.constructor.toStringTag] === 'Symbol');
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString, id = objToString.call(__webpack_require__(111));

module.exports = function (value) {
	return typeof value === "function" && objToString.call(value) === id;
};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(218)

  , max = Math.max;

module.exports = function (value) {
 return max(0, toInteger(value));
};


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sign = __webpack_require__(219)

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(220)()
	? Math.sign
	: __webpack_require__(221);


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== "function") return false;
	return (sign(10) === 1) && (sign(-20) === -1);
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return value > 0 ? 1 : -1;
};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(21)
  , forEach  = __webpack_require__(223)
  , call     = Function.prototype.call;

module.exports = function (obj, cb /*, thisArg*/) {
	var result = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, targetObj, index) {
		result[key] = call.call(cb, thisArg, value, key, targetObj, index);
	});
	return result;
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(224)("forEach");


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable                = __webpack_require__(21)
  , value                   = __webpack_require__(16)
  , bind                    = Function.prototype.bind
  , call                    = Function.prototype.call
  , keys                    = Object.keys
  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb /*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== "function") method = list[method];
		return call.call(method, list, function (key, index) {
			if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(84)
  , d              = __webpack_require__(86)
  , Iterator       = __webpack_require__(113)

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(227);

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(65)
  , isString       = __webpack_require__(66)
  , iteratorSymbol = __webpack_require__(53).iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(65)
  , callable    = __webpack_require__(21)
  , isString    = __webpack_require__(66)
  , get         = __webpack_require__(112)

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Exports true if environment provides native `WeakMap` implementation, whatever that is.



module.exports = (function () {
	if (typeof WeakMap !== 'function') return false;
	return (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');
}());


/***/ }),
/* 230 */
/***/ (function(module, exports) {

var extend = function(out) {
  out = out || {};
  for (var i = 1; i < arguments.length; i++) {
    if (!arguments[i]) continue;
    for (var key in arguments[i]) {
      if (arguments[i].hasOwnProperty(key)) {
        out[key] = arguments[i][key];
      }
    }
  }
  return out;
};

module.exports = {
  extend: extend
}


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ = __webpack_require__(2);
var List = __webpack_require__(232);
var Accordion = __webpack_require__(114).Accordion;

var KEYCODE_ENTER = 13;
var KEYCODE_ESC = 27;

// https://davidwalsh.name/element-matches-selector
function selectorMatches(el, selector) {
  var p = Element.prototype;
  var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
  return f.call(el, selector);
}

function forEach(values, callback) {
  return [].forEach.call(values, callback);
}

var itemTemplate = _.template(
  '<li class="{{ glossaryItemClass }}">' +
    '<button class="data-glossary-term {{ termClass }}">{{ term }}' +
    '</button>' +
    '<div class="{{ definitionClass }}">{{ definition }}</div>' +
  '</li>',
  {interpolate: /\{\{(.+?)\}\}/g}
);

var defaultSelectors = {
  glossaryID: '#glossary',
  toggle: '.js-glossary-toggle',
  close: '.js-glossary-close',
  listClass: '.js-glossary-list',
  searchClass: '.js-glossary-search'
};

var defaultClasses = {
  definitionClass: 'glossary__definition',
  glossaryItemClass: 'glossary__item',
  highlightedTerm: 'term--highlight',
  termClass: 'glossary__term'
};

function removeTabindex(elm) {
  var elms = getTabIndex(elm);
  forEach(elms, function(elm) {
    elm.setAttribute('tabIndex', '-1');
  });
}

function restoreTabindex(elm) {
  var elms = getTabIndex(elm);
  forEach(elms, function(elm) {
    elm.setAttribute('tabIndex', '0');
  });
}

function getTabIndex(elm) {
  return elm.querySelectorAll('a, button, input, [tabindex]');
}

/**
 * Glossary widget
 * @constructor
 * @param {Array} terms - Term objects with "glossary-term" and "glossary-definition" keys
 * @param {Object} selectors - CSS selectors for glossary components
 * @param {Object} classes - CSS classes to be applied for styling
 */
function Glossary(terms, selectors, classes) {
  this.terms = terms;
  this.selectors = _.extend({}, defaultSelectors, selectors);
  this.classes = _.extend({}, defaultClasses, classes);

  this.body = document.querySelector(this.selectors.glossaryID);
  this.toggleBtn = document.querySelector(this.selectors.toggle);
  this.closeBtn = document.querySelector(this.selectors.close);
  this.search = this.body.querySelector(this.selectors.searchClass);
  this.listElm = this.body.querySelector(this.selectors.listClass);
  this.selectedTerm = this.toggleBtn;

  // Initialize state
  this.isOpen = false;

  // Update DOM
  this.populate();
  this.initList();
  this.linkTerms();

  // Remove tabindices
  removeTabindex(this.body);

  // Initialize accordions
  this.accordion = new Accordion(this.listElm, null, {contentPrefix: 'glossary'});

  // Bind listeners
  this.listeners = [];
  this.addEventListener(this.toggleBtn, 'click', this.toggle.bind(this));
  this.addEventListener(this.closeBtn, 'click', this.hide.bind(this));
  this.addEventListener(this.search, 'input', this.handleInput.bind(this));
  this.addEventListener(document.body, 'keyup', this.handleKeyup.bind(this));
}

Glossary.prototype.populate = function() {
  this.terms.forEach(function(term) {
    var opts = {
      term: term.term,
      definition: term.definition,
      definitionClass: this.classes.definitionClass,
      glossaryItemClass: this.classes.glossaryItemClass,
      termClass: this.classes.termClass
    };
    this.listElm.insertAdjacentHTML('beforeend', itemTemplate(opts));
  }, this);
};

/** Initialize list.js list of terms */
Glossary.prototype.initList = function() {
  var glossaryId = this.selectors.glossaryID.slice(1);
  var listClass = this.selectors.listClass.slice(1);
  var searchClass = this.selectors.searchClass.slice(1);
  var options = {
    valueNames: ['data-glossary-term'],
    listClass: listClass,
    searchClass: searchClass,
  };
  this.list = new List(glossaryId, options);
  this.list.sort('data-glossary-term', {order: 'asc'});
};

/** Add links to terms in body */
Glossary.prototype.linkTerms = function() {
  var terms = document.querySelectorAll('[data-term]');
  forEach(terms, function(term) {
    term.setAttribute('title', 'Click to define');
    term.setAttribute('tabIndex', 0);
    term.setAttribute('data-term', (term.getAttribute('data-term') || '').toLowerCase());
  });
  document.body.addEventListener('click', this.handleTermTouch.bind(this));
  document.body.addEventListener('keyup', this.handleTermTouch.bind(this));
};

Glossary.prototype.handleTermTouch = function(e) {
  if (e.which === KEYCODE_ENTER || e.type === 'click') {
    if (selectorMatches(e.target, '[data-term]')) {
      this.show(e);
      this.selectedTerm = e.target;
      this.findTerm(e.target.getAttribute('data-term'));
    }
    else {
      this.selectedTerm = this.toggleBtn;
    }
  }
};

/** Highlight a term */
Glossary.prototype.findTerm = function(term) {
  this.search.value = term;
  var highlightClass = this.classes.highlightedTerm;

  // Highlight the term and remove other highlights
  forEach(this.body.querySelectorAll('.' + highlightClass), function(term) {
    term.classList.remove(highlightClass);
  });
  forEach(this.body.querySelectorAll('span[data-term="' + term + '"]'), function(term) {
    term.classList.add(highlightClass);
  });
  this.list.filter(function(item) {
    return item._values['data-glossary-term'].toLowerCase() === term;
  });

  this.list.search();
  var button = this.list.visibleItems[0].elm.querySelector('button');
  this.accordion.expand(button);
};

Glossary.prototype.toggle = function() {
  var method = this.isOpen ? this.hide : this.show;
  method.apply(this);
};

Glossary.prototype.show = function() {
  this.body.setAttribute('aria-hidden', 'false');
  this.toggleBtn.setAttribute('aria-expanded', 'true');
  this.search.focus();
  this.isOpen = true;
  restoreTabindex(this.body);
};

Glossary.prototype.hide = function() {
  this.body.setAttribute('aria-hidden', 'true');
  this.toggleBtn.setAttribute('aria-expanded', 'false');
  this.selectedTerm.focus();
  this.isOpen = false;
  removeTabindex(this.body);
};

/** Remove existing filters on input */
Glossary.prototype.handleInput = function() {
  if (this.list.filtered) {
    this.list.filter();
  }
};

/** Close glossary on escape keypress */
Glossary.prototype.handleKeyup = function(e) {
  if (e.keyCode == KEYCODE_ESC) {
    if (this.isOpen) {
      this.hide();
    }
  }
};

Glossary.prototype.addEventListener = function(elm, event, callback) {
  if (elm) {
    elm.addEventListener(event, callback);
    this.listeners.push({
      elm: elm,
      event: event,
      callback: callback
    });
  }
};

Glossary.prototype.destroy = function() {
  this.accordion.destroy();
  this.listeners.forEach(function(listener) {
    listener.elm.removeEventListener(listener.event, listener.callback);
  });
};

module.exports = Glossary;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function( window, undefined ) {
"use strict";

var document = window.document,
  getByClass = __webpack_require__(233),
  extend = __webpack_require__(234),
  indexOf = __webpack_require__(115),
  events = __webpack_require__(235),
  toString = __webpack_require__(236),
  naturalSort = __webpack_require__(237),
  classes = __webpack_require__(238),
  getAttribute = __webpack_require__(239),
  toArray = __webpack_require__(116);

var List = function(id, options, values) {

  var self = this,
    init,
    Item = __webpack_require__(117)(self),
    addAsync = __webpack_require__(240)(self);

  init = {
    start: function() {
      self.listClass      = "list";
      self.searchClass    = "search";
      self.sortClass      = "sort";
      self.page           = 10000;
      self.i              = 1;
      self.items          = [];
      self.visibleItems   = [];
      self.matchingItems  = [];
      self.searched       = false;
      self.filtered       = false;
      self.searchColumns  = undefined;
      self.handlers       = { 'updated': [] };
      self.plugins        = {};
      self.valueNames     = [];
      self.utils          = {
        getByClass: getByClass,
        extend: extend,
        indexOf: indexOf,
        events: events,
        toString: toString,
        naturalSort: naturalSort,
        classes: classes,
        getAttribute: getAttribute,
        toArray: toArray
      };

      self.utils.extend(self, options);

      self.listContainer = (typeof(id) === 'string') ? document.getElementById(id) : id;
      if (!self.listContainer) { return; }
      self.list       = getByClass(self.listContainer, self.listClass, true);

      self.parse      = __webpack_require__(241)(self);
      self.templater  = __webpack_require__(242)(self);
      self.search     = __webpack_require__(243)(self);
      self.filter     = __webpack_require__(244)(self);
      self.sort       = __webpack_require__(245)(self);

      this.handlers();
      this.items();
      self.update();
      this.plugins();
    },
    handlers: function() {
      for (var handler in self.handlers) {
        if (self[handler]) {
          self.on(handler, self[handler]);
        }
      }
    },
    items: function() {
      self.parse(self.list);
      if (values !== undefined) {
        self.add(values);
      }
    },
    plugins: function() {
      for (var i = 0; i < self.plugins.length; i++) {
        var plugin = self.plugins[i];
        self[plugin.name] = plugin;
        plugin.init(self, List);
      }
    }
  };

  /*
  * Re-parse the List, use if html have changed
  */
  this.reIndex = function() {
    self.items          = [];
    self.visibleItems   = [];
    self.matchingItems  = [];
    self.searched       = false;
    self.filtered       = false;
    self.parse(self.list);
  };

  this.toJSON = function() {
    var json = [];
    for (var i = 0, il = self.items.length; i < il; i++) {
      json.push(self.items[i].values());
    }
    return json;
  };


  /*
  * Add object to list
  */
  this.add = function(values, callback) {
    if (values.length === 0) {
      return;
    }
    if (callback) {
      addAsync(values, callback);
      return;
    }
    var added = [],
      notCreate = false;
    if (values[0] === undefined){
      values = [values];
    }
    for (var i = 0, il = values.length; i < il; i++) {
      var item = null;
      notCreate = (self.items.length > self.page) ? true : false;
      item = new Item(values[i], undefined, notCreate);
      self.items.push(item);
      added.push(item);
    }
    self.update();
    return added;
  };

	this.show = function(i, page) {
		this.i = i;
		this.page = page;
		self.update();
    return self;
	};

  /* Removes object from list.
  * Loops through the list and removes objects where
  * property "valuename" === value
  */
  this.remove = function(valueName, value, options) {
    var found = 0;
    for (var i = 0, il = self.items.length; i < il; i++) {
      if (self.items[i].values()[valueName] == value) {
        self.templater.remove(self.items[i], options);
        self.items.splice(i,1);
        il--;
        i--;
        found++;
      }
    }
    self.update();
    return found;
  };

  /* Gets the objects in the list which
  * property "valueName" === value
  */
  this.get = function(valueName, value) {
    var matchedItems = [];
    for (var i = 0, il = self.items.length; i < il; i++) {
      var item = self.items[i];
      if (item.values()[valueName] == value) {
        matchedItems.push(item);
      }
    }
    return matchedItems;
  };

  /*
  * Get size of the list
  */
  this.size = function() {
    return self.items.length;
  };

  /*
  * Removes all items from the list
  */
  this.clear = function() {
    self.templater.clear();
    self.items = [];
    return self;
  };

  this.on = function(event, callback) {
    self.handlers[event].push(callback);
    return self;
  };

  this.off = function(event, callback) {
    var e = self.handlers[event];
    var index = indexOf(e, callback);
    if (index > -1) {
      e.splice(index, 1);
    }
    return self;
  };

  this.trigger = function(event) {
    var i = self.handlers[event].length;
    while(i--) {
      self.handlers[event][i](self);
    }
    return self;
  };

  this.reset = {
    filter: function() {
      var is = self.items,
        il = is.length;
      while (il--) {
        is[il].filtered = false;
      }
      return self;
    },
    search: function() {
      var is = self.items,
        il = is.length;
      while (il--) {
        is[il].found = false;
      }
      return self;
    }
  };

  this.update = function() {
    var is = self.items,
			il = is.length;

    self.visibleItems = [];
    self.matchingItems = [];
    self.templater.clear();
    for (var i = 0; i < il; i++) {
      if (is[i].matching() && ((self.matchingItems.length+1) >= self.i && self.visibleItems.length < self.page)) {
        is[i].show();
        self.visibleItems.push(is[i]);
        self.matchingItems.push(is[i]);
      } else if (is[i].matching()) {
        self.matchingItems.push(is[i]);
        is[i].hide();
      } else {
        is[i].hide();
      }
    }
    self.trigger('updated');
    return self;
  };

  init.start();
};


// AMD support
if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return List; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
module.exports = List;
window.List = List;

})(window);


/***/ }),
/* 233 */
/***/ (function(module, exports) {

/**
 * A cross-browser implementation of getElementsByClass.
 * Heavily based on Dustin Diaz's function: http://dustindiaz.com/getelementsbyclass.
 *
 * Find all elements with class `className` inside `container`.
 * Use `single = true` to increase performance in older browsers
 * when only one element is needed.
 *
 * @param {String} className
 * @param {Element} container
 * @param {Boolean} single
 * @api public
 */

module.exports = (function() {
  if (document.getElementsByClassName) {
    return function(container, className, single) {
      if (single) {
        return container.getElementsByClassName(className)[0];
      } else {
        return container.getElementsByClassName(className);
      }
    };
  } else if (document.querySelector) {
    return function(container, className, single) {
      className = '.' + className;
      if (single) {
        return container.querySelector(className);
      } else {
        return container.querySelectorAll(className);
      }
    };
  } else {
    return function(container, className, single) {
      var classElements = [],
        tag = '*';
      if (container === null) {
        container = document;
      }
      var els = container.getElementsByTagName(tag);
      var elsLen = els.length;
      var pattern = new RegExp("(^|\\s)"+className+"(\\s|$)");
      for (var i = 0, j = 0; i < elsLen; i++) {
        if ( pattern.test(els[i].className) ) {
          if (single) {
            return els[i];
          } else {
            classElements[j] = els[i];
            j++;
          }
        }
      }
      return classElements;
    };
  }
})();


/***/ }),
/* 234 */
/***/ (function(module, exports) {

/*
 * Source: https://github.com/segmentio/extend
 */

module.exports = function extend (object) {
    // Takes an unlimited number of extenders.
    var args = Array.prototype.slice.call(arguments, 1);

    // For each extender, copy their properties on our object.
    for (var i = 0, source; source = args[i]; i++) {
        if (!source) continue;
        for (var property in source) {
            object[property] = source[property];
        }
    }

    return object;
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '',
    toArray = __webpack_require__(116);

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    el[i][bind](prefix + type, fn, capture || false);
  }
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    el[i][unbind](prefix + type, fn, capture || false);
  }
};


/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports = function(s) {
  s = (s === undefined) ? "" : s;
  s = (s === null) ? "" : s;
  s = s.toString();
  return s;
};


/***/ }),
/* 237 */
/***/ (function(module, exports) {

/*
 * Natural Sort algorithm for Javascript - Version 0.8.1 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */
module.exports = function(a, b, opts) {
    var re = /(^([+\-]?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?(?=\D|\s|$))|^0x[\da-fA-F]+$|\d+)/g,
        sre = /^\s+|\s+$/g,   // trim pre-post whitespace
        snre = /\s+/g,        // normalize all whitespace to single ' ' character
        dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
        hre = /^0x[0-9a-f]+$/i,
        ore = /^0/,
        options = opts || {},
        i = function(s) {
            return (options.insensitive && ('' + s).toLowerCase() || '' + s).replace(sre, '');
        },
        // convert all to strings strip whitespace
        x = i(a),
        y = i(b),
        // chunk/tokenize
        xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        // numeric, hex or date detection
        xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && Date.parse(x)),
        yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
        normChunk = function(s, l) {
           // normalize spaces; find floats not starting with '0', string or 0 if not defined (Clint Priest)
           return (!s.match(ore) || l == 1) && parseFloat(s) || s.replace(snre, ' ').replace(sre, '') || 0;
        },
        oFxNcL, oFyNcL;
   // first try and sort Hex codes or Dates
   if (yD) {
       if (xD < yD) { return -1; }
       else if (xD > yD) { return 1; }
   }
   // natural sorting through split numeric strings and default strings
   for(var cLoc = 0, xNl = xN.length, yNl = yN.length, numS = Math.max(xNl, yNl); cLoc < numS; cLoc++) {
       oFxNcL = normChunk(xN[cLoc] || '', xNl);
       oFyNcL = normChunk(yN[cLoc] || '', yNl);
       // handle numeric vs string comparison - number < string - (Kyle Adams)
       if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
           return isNaN(oFxNcL) ? 1 : -1;
       }
       // if unicode use locale comparison
       if (/[^\x00-\x80]/.test(oFxNcL + oFyNcL) && oFxNcL.localeCompare) {
           var comp = oFxNcL.localeCompare(oFyNcL);
           return comp / Math.abs(comp);
       }
       if (oFxNcL < oFyNcL) { return -1; }
       else if (oFxNcL > oFyNcL) { return 1; }
   }
    return 0;
};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var index = __webpack_require__(115);

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list ? this.list.contains(name) : !! ~index(this.array(), name);
};


/***/ }),
/* 239 */
/***/ (function(module, exports) {

/**
 * A cross-browser implementation of getAttribute.
 * Source found here: http://stackoverflow.com/a/3755343/361337 written by Vivin Paliath
 *
 * Return the value for `attr` at `element`.
 *
 * @param {Element} el
 * @param {String} attr
 * @api public
 */

module.exports = function(el, attr) {
  var result = (el.getAttribute && el.getAttribute(attr)) || null;
  if( !result ) {
    var attrs = el.attributes;
    var length = attrs.length;
    for(var i = 0; i < length; i++) {
      if (attr[i] !== undefined) {
        if(attr[i].nodeName === attr) {
          result = attr[i].nodeValue;
        }
      }
    }
  }
  return result;
};


/***/ }),
/* 240 */
/***/ (function(module, exports) {

module.exports = function(list) {
  var addAsync = function(values, callback, items) {
    var valuesToAdd = values.splice(0, 50);
    items = items || [];
    items = items.concat(list.add(valuesToAdd));
    if (values.length > 0) {
      setTimeout(function() {
        addAsync(values, callback, items);
      }, 1);
    } else {
      list.update();
      callback(items);
    }
  };
  return addAsync;
};


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(list) {

  var Item = __webpack_require__(117)(list);

  var getChildren = function(parent) {
    var nodes = parent.childNodes,
      items = [];
    for (var i = 0, il = nodes.length; i < il; i++) {
      // Only textnodes have a data attribute
      if (nodes[i].data === undefined) {
        items.push(nodes[i]);
      }
    }
    return items;
  };

  var parse = function(itemElements, valueNames) {
    for (var i = 0, il = itemElements.length; i < il; i++) {
      list.items.push(new Item(valueNames, itemElements[i]));
    }
  };
  var parseAsync = function(itemElements, valueNames) {
    var itemsToIndex = itemElements.splice(0, 50); // TODO: If < 100 items, what happens in IE etc?
    parse(itemsToIndex, valueNames);
    if (itemElements.length > 0) {
      setTimeout(function() {
        parseAsync(itemElements, valueNames);
      }, 1);
    } else {
      list.update();
      list.trigger('parseComplete');
    }
  };

  list.handlers.parseComplete = list.handlers.parseComplete || [];

  return function() {
    var itemsToIndex = getChildren(list.list),
      valueNames = list.valueNames;

    if (list.indexAsync) {
      parseAsync(itemsToIndex, valueNames);
    } else {
      parse(itemsToIndex, valueNames);
    }
  };
};


/***/ }),
/* 242 */
/***/ (function(module, exports) {

var Templater = function(list) {
  var itemSource,
    templater = this;

  var init = function() {
    itemSource = templater.getItemSource(list.item);
    if (itemSource) {
      itemSource = templater.clearSourceItem(itemSource, list.valueNames);
    }
  };

  this.clearSourceItem = function(el, valueNames) {
    for(var i = 0, il = valueNames.length; i < il; i++) {
      var elm;
      if (valueNames[i].data) {
        for (var j = 0, jl = valueNames[i].data.length; j < jl; j++) {
          el.setAttribute('data-'+valueNames[i].data[j], '');
        }
      } else if (valueNames[i].attr && valueNames[i].name) {
        elm = list.utils.getByClass(el, valueNames[i].name, true);
        if (elm) {
          elm.setAttribute(valueNames[i].attr, "");
        }
      } else {
        elm = list.utils.getByClass(el, valueNames[i], true);
        if (elm) {
          elm.innerHTML = "";
        }
      }
      elm = undefined;
    }
    return el;
  };

  this.getItemSource = function(item) {
    if (item === undefined) {
      var nodes = list.list.childNodes,
        items = [];

      for (var i = 0, il = nodes.length; i < il; i++) {
        // Only textnodes have a data attribute
        if (nodes[i].data === undefined) {
          return nodes[i].cloneNode(true);
        }
      }
    } else if (/<tr[\s>]/g.exec(item)) {
      var tbody = document.createElement('tbody');
      tbody.innerHTML = item;
      return tbody.firstChild;
    } else if (item.indexOf("<") !== -1) {
      var div = document.createElement('div');
      div.innerHTML = item;
      return div.firstChild;
    } else {
      var source = document.getElementById(list.item);
      if (source) {
        return source;
      }
    }
    return undefined;
  };

  this.get = function(item, valueNames) {
    templater.create(item);
    var values = {};
    for(var i = 0, il = valueNames.length; i < il; i++) {
      var elm;
      if (valueNames[i].data) {
        for (var j = 0, jl = valueNames[i].data.length; j < jl; j++) {
          values[valueNames[i].data[j]] = list.utils.getAttribute(item.elm, 'data-'+valueNames[i].data[j]);
        }
      } else if (valueNames[i].attr && valueNames[i].name) {
        elm = list.utils.getByClass(item.elm, valueNames[i].name, true);
        values[valueNames[i].name] = elm ? list.utils.getAttribute(elm, valueNames[i].attr) : "";
      } else {
        elm = list.utils.getByClass(item.elm, valueNames[i], true);
        values[valueNames[i]] = elm ? elm.innerHTML : "";
      }
      elm = undefined;
    }
    return values;
  };

  this.set = function(item, values) {
    var getValueName = function(name) {
      for (var i = 0, il = list.valueNames.length; i < il; i++) {
        if (list.valueNames[i].data) {
          var data = list.valueNames[i].data;
          for (var j = 0, jl = data.length; j < jl; j++) {
            if (data[j] === name) {
              return { data: name };
            }
          }
        } else if (list.valueNames[i].attr && list.valueNames[i].name && list.valueNames[i].name == name) {
          return list.valueNames[i];
        } else if (list.valueNames[i] === name) {
          return name;
        }
      }
    };
    var setValue = function(name, value) {
      var elm;
      var valueName = getValueName(name);
      if (!valueName)
        return;
      if (valueName.data) {
        item.elm.setAttribute('data-'+valueName.data, value);
      } else if (valueName.attr && valueName.name) {
        elm = list.utils.getByClass(item.elm, valueName.name, true);
        if (elm) {
          elm.setAttribute(valueName.attr, value);
        }
      } else {
        elm = list.utils.getByClass(item.elm, valueName, true);
        if (elm) {
          elm.innerHTML = value;
        }
      }
      elm = undefined;
    };
    if (!templater.create(item)) {
      for(var v in values) {
        if (values.hasOwnProperty(v)) {
          setValue(v, values[v]);
        }
      }
    }
  };

  this.create = function(item) {
    if (item.elm !== undefined) {
      return false;
    }
    if (itemSource === undefined) {
      throw new Error("The list need to have at list one item on init otherwise you'll have to add a template.");
    }
    /* If item source does not exists, use the first item in list as
    source for new items */
    var newItem = itemSource.cloneNode(true);
    newItem.removeAttribute('id');
    item.elm = newItem;
    templater.set(item, item.values());
    return true;
  };
  this.remove = function(item) {
    if (item.elm.parentNode === list.list) {
      list.list.removeChild(item.elm);
    }
  };
  this.show = function(item) {
    templater.create(item);
    list.list.appendChild(item.elm);
  };
  this.hide = function(item) {
    if (item.elm !== undefined && item.elm.parentNode === list.list) {
      list.list.removeChild(item.elm);
    }
  };
  this.clear = function() {
    /* .innerHTML = ''; fucks up IE */
    if (list.list.hasChildNodes()) {
      while (list.list.childNodes.length >= 1)
      {
        list.list.removeChild(list.list.firstChild);
      }
    }
  };

  init();
};

module.exports = function(list) {
  return new Templater(list);
};


/***/ }),
/* 243 */
/***/ (function(module, exports) {

module.exports = function(list) {
  var item,
    text,
    columns,
    searchString,
    customSearch;

  var prepare = {
    resetList: function() {
      list.i = 1;
      list.templater.clear();
      customSearch = undefined;
    },
    setOptions: function(args) {
      if (args.length == 2 && args[1] instanceof Array) {
        columns = args[1];
      } else if (args.length == 2 && typeof(args[1]) == "function") {
        columns = undefined;
        customSearch = args[1];
      } else if (args.length == 3) {
        columns = args[1];
        customSearch = args[2];
      } else {
        columns = undefined;
      }
    },
    setColumns: function() {
      if (list.items.length === 0) return;
      if (columns === undefined) {
        columns = (list.searchColumns === undefined) ? prepare.toArray(list.items[0].values()) : list.searchColumns;
      }
    },
    setSearchString: function(s) {
      s = list.utils.toString(s).toLowerCase();
      s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"); // Escape regular expression characters
      searchString = s;
    },
    toArray: function(values) {
      var tmpColumn = [];
      for (var name in values) {
        tmpColumn.push(name);
      }
      return tmpColumn;
    }
  };
  var search = {
    list: function() {
      for (var k = 0, kl = list.items.length; k < kl; k++) {
        search.item(list.items[k]);
      }
    },
    item: function(item) {
      item.found = false;
      for (var j = 0, jl = columns.length; j < jl; j++) {
        if (search.values(item.values(), columns[j])) {
          item.found = true;
          return;
        }
      }
    },
    values: function(values, column) {
      if (values.hasOwnProperty(column)) {
        text = list.utils.toString(values[column]).toLowerCase();
        if ((searchString !== "") && (text.search(searchString) > -1)) {
          return true;
        }
      }
      return false;
    },
    reset: function() {
      list.reset.search();
      list.searched = false;
    }
  };

  var searchMethod = function(str) {
    list.trigger('searchStart');

    prepare.resetList();
    prepare.setSearchString(str);
    prepare.setOptions(arguments); // str, cols|searchFunction, searchFunction
    prepare.setColumns();

    if (searchString === "" ) {
      search.reset();
    } else {
      list.searched = true;
      if (customSearch) {
        customSearch(searchString, columns);
      } else {
        search.list();
      }
    }

    list.update();
    list.trigger('searchComplete');
    return list.visibleItems;
  };

  list.handlers.searchStart = list.handlers.searchStart || [];
  list.handlers.searchComplete = list.handlers.searchComplete || [];

  list.utils.events.bind(list.utils.getByClass(list.listContainer, list.searchClass), 'keyup', function(e) {
    var target = e.target || e.srcElement, // IE have srcElement
      alreadyCleared = (target.value === "" && !list.searched);
    if (!alreadyCleared) { // If oninput already have resetted the list, do nothing
      searchMethod(target.value);
    }
  });

  // Used to detect click on HTML5 clear button
  list.utils.events.bind(list.utils.getByClass(list.listContainer, list.searchClass), 'input', function(e) {
    var target = e.target || e.srcElement;
    if (target.value === "") {
      searchMethod('');
    }
  });

  return searchMethod;
};


/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = function(list) {

  // Add handlers
  list.handlers.filterStart = list.handlers.filterStart || [];
  list.handlers.filterComplete = list.handlers.filterComplete || [];

  return function(filterFunction) {
    list.trigger('filterStart');
    list.i = 1; // Reset paging
    list.reset.filter();
    if (filterFunction === undefined) {
      list.filtered = false;
    } else {
      list.filtered = true;
      var is = list.items;
      for (var i = 0, il = is.length; i < il; i++) {
        var item = is[i];
        if (filterFunction(item)) {
          item.filtered = true;
        } else {
          item.filtered = false;
        }
      }
    }
    list.update();
    list.trigger('filterComplete');
    return list.visibleItems;
  };
};


/***/ }),
/* 245 */
/***/ (function(module, exports) {

module.exports = function(list) {
  list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
    options.desc = options.order == "desc" ? true : false; // Natural sort uses this format
    return list.utils.naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
  };

  var buttons = {
    els: undefined,
    clear: function() {
      for (var i = 0, il = buttons.els.length; i < il; i++) {
        list.utils.classes(buttons.els[i]).remove('asc');
        list.utils.classes(buttons.els[i]).remove('desc');
      }
    },
    getOrder: function(btn) {
      var predefinedOrder = list.utils.getAttribute(btn, 'data-order');
      if (predefinedOrder == "asc" || predefinedOrder == "desc") {
        return predefinedOrder;
      } else if (list.utils.classes(btn).has('desc')) {
        return "asc";
      } else if (list.utils.classes(btn).has('asc')) {
        return "desc";
      } else {
        return "asc";
      }
    },
    getInSensitive: function(btn, options) {
      var insensitive = list.utils.getAttribute(btn, 'data-insensitive');
      if (insensitive === "false") {
        options.insensitive = false;
      } else {
        options.insensitive = true;
      }
    },
    setOrder: function(options) {
      for (var i = 0, il = buttons.els.length; i < il; i++) {
        var btn = buttons.els[i];
        if (list.utils.getAttribute(btn, 'data-sort') !== options.valueName) {
          continue;
        }
        var predefinedOrder = list.utils.getAttribute(btn, 'data-order');
        if (predefinedOrder == "asc" || predefinedOrder == "desc") {
          if (predefinedOrder == options.order) {
            list.utils.classes(btn).add(options.order);
          }
        } else {
          list.utils.classes(btn).add(options.order);
        }
      }
    }
  };
  var sort = function() {
    list.trigger('sortStart');
    var options = {};

    var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;

    if (target) {
      options.valueName = list.utils.getAttribute(target, 'data-sort');
      buttons.getInSensitive(target, options);
      options.order = buttons.getOrder(target);
    } else {
      options = arguments[1] || options;
      options.valueName = arguments[0];
      options.order = options.order || "asc";
      options.insensitive = (typeof options.insensitive == "undefined") ? true : options.insensitive;
    }
    buttons.clear();
    buttons.setOrder(options);

    options.sortFunction = options.sortFunction || list.sortFunction;
    list.items.sort(function(a, b) {
      var mult = (options.order === 'desc') ? -1 : 1;
      return (options.sortFunction(a, b, options) * mult);
    });
    list.update();
    list.trigger('sortComplete');
  };

  // Add handlers
  list.handlers.sortStart = list.handlers.sortStart || [];
  list.handlers.sortComplete = list.handlers.sortComplete || [];

  buttons.els = list.utils.getByClass(list.listContainer, list.sortClass);
  list.utils.events.bind(buttons.els, 'click', sort);
  list.on('searchStart', buttons.clear);
  list.on('filterStart', buttons.clear);

  return sort;
};


/***/ }),
/* 246 */
/***/ (function(module, exports) {

module.exports = [{"term":"Act","definition":"The Federal Election Campaign Act of 1971, as amended (<a href=\"https://www.fec.gov/data/legal/statutes/\">52 U.S.C. 30101-30146</a>). 11 CFR <a href=\"https://www.fec.gov/regulations/100-18/CURRENT#100-18\">100.18</a>. Prior to September 1, 2014, the Act appeared in Title 2 of the U.S. Code. Sometimes abbreviated FECA."},{"term":"Administrative expense","definition":"For party committees, rent, utilities, office equipment, office supplies, routine building maintenance and other operating costs not attributable to a specific candidate."},{"term":"Advance","definition":"The payment by an individual from his or her personal funds, including a personal credit card, for the costs incurred in providing goods or services to, or obtaining goods or services that are used by or on behalf of, a candidate or a political committee.  See <a href=\"https://www.fec.gov/regulations/116-5/CURRENT#116-5\">11 CFR 116.5</a>."},{"term":"Advisory opinion (AO)","definition":"A formal response from the Commission regarding the legality of a specific activity proposed in an advisory opinion request (AOR). 11 CFR Part <a href=\"https://www.fec.gov/regulations/112\">112</a>."},{"term":"Affiliated committees","definition":"Committees and organizations that are considered one committee for purposes of the contribution limits. <a href=\"https://www.fec.gov/regulations/110-3/CURRENT#110-3\">11 CFR 110.3(a)(1)</a>. Affiliated committees include (1) All committees established or authorized by a candidate as part of his or her campaign for federal or nonfederal office; and (2) All committees established, financed, maintained or controlled by the same person, group or organization. 11 CFR <a href=\"https://www.fec.gov/regulations/100-5/CURRENT#100-5-g\">100.5(g)(1) and (2)</a>; <a href=\"https://www.fec.gov/regulations/110-3/CURRENT#110-3\">11 CFR 110.3(a)(1)</a>."},{"term":"Agent (of a candidate)","definition":"An agent of a federal candidate or officeholder is any person who has actual authority, either express or implied, to engage in any of the following activities on behalf of the candidate or officeholder: <ul class='list-bulleted'> <li>To solicit, receive, direct, transfer or spend funds in connection with any election.</li><li>To request or suggest that a communication be created, produced or distributed; </li><li>To make or authorize a communication that meets one or more of the content standards for coordination;</li><li>To request or suggest that any other person create, produce, or distribute any communication;</li><li>To be materially involved in decisions regarding the content, intended audience, means, media outlet, timing, frequency, size, prominence or duration of a communication;</li><li>To provide material or information to assist another person in the creation, production or distribution of any communication; or</li>\n<li>To make or direct a communication that is created, produced or distributed with the use of material or information derived from a substantial discussion about the communication with a different candidate;</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/109-3/CURRENT#109-3-b\">109.3(b)</a> and <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-b-3\">300.2(b)(3)</a>."},{"term":"Agent (of a party)","definition":"An agent is any person who has actual authority, either expressed or implied, to engage in certain activities on behalf of the committee. In the case of state, district and local party committees, these activities are:<ul  class=\"list-bulleted\"><li>Expending or disbursing any funds for federal election activity; </li><li>Transferring or accepting transfers of funds for federal election activity;</li> <li>Engaging in joint fundraising activity if any part of the funds are to be used for federal election activity; or </li><li>Soliciting any funds for, or making or directing any donations to, any tax-exempt 501(c) organization or 527 organization that is not also a political committee, a party committee or an authorized campaign committee. </li>11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-b-2\">300.2(b)(2)</a>.</ul>In the case of the national party committees, these activities are:\n<ul class=\"list-bulleted\"><li>Soliciting, directing or receiving a contribution, donation or transfer of funds; or</li><li>Soliciting any funds for, or making or directing donations to, any tax-exempt 501(c) organization or 527 organization that is not also a political committee, a party committee or an authorized campaign committee.</li> 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-b-1\">300.2(b)(1)</a>.</ul> In the case of communications, for all party committees, the activities include: <ul class=:\"list-bulleted\"><li>Requesting or suggesting that a communication be created, produced or distributed;</li><li>Creating, producing or distributing any communication at the request of a candidate; or</li><li>Being materially involved in the content or distribution of a communication.</li>11 CFR <a href=\"https://www.fec.gov/regulations/109-3/CURRENT#109-3\">109.3(a)</a>.</ul>"},{"term":"Allocation account","definition":"A separate federal account into which funds from either a committees federal and nonfederal accounts, or (for party committees) from its federal and Levin accounts, are deposited solely to pay expenses that must be allocated. (A party committee must have separate allocation accounts for its federal/nonfederal allocation and for its federal/Levin allocation). 11 CFR <a href=\"https://www.fec.gov/regulations/106-7/CURRENT#106-7\">106.7(f)</a> and <a href=\"https://www.fec.gov/regulations/300-33/CURRENT#300-33-d\">300.33(d)</a>."},{"term":"Authorized committee","definition":"A political committee that has been authorized by a candidate to accept contributions or make expenditures on his or her behalf, or one that accepts contributions or makes expenditures on behalf of a candidate and has not been disavowed by the candidate."},{"term":"Bundled contribution","definition":"A contribution forwarded to a reporting committee by a lobbyist/registrant or lobbyist/registrant PAC, or received by a reporting committee and credited to a lobbyist/registrant or lobbyist/registrant PAC. See 11 CFR <a href=\"https://www.fec.gov/regulations/104-22/CURRENT#104-22-a-6\">104.22(a)(6)</a>."},{"term":"Campaign traveler","definition":"Any candidate traveling in connection with an election for federal office, or any individual traveling in connection with an election for federal office on behalf of a candidate or political committee; or any member of the news media traveling with a candidate. 11 CFR <a href=\"https://www.fec.gov/regulations/100-93/CURRENT#100-93-a-3\">100.93(a)(3)(i)</a>."},{"term":"Candidate","definition":"An individual seeking nomination for election, or reelection, to a federal office becomes a candidate when he or she (or persons working on his or her behalf) receives contributions or makes expenditures that exceed $5,000."},{"term":"Candidate ID","definition":"A unique identifier assigned to each candidate registered with the FEC. The initial character indicates the office sought. (H)ouse, (S)enate, (P)resident. If a person runs for several offices, they will have separate IDs for each office."},{"term":"Cash-on-hand","definition":"Cash on hand includes funds held in checking and savings accounts, certificates of deposit, petty cash funds, travelers checks, treasury bills and other investments valued at cost. <a href=\"https://www.fec.gov/regulations/104-3/CURRENT#104-3-a-1\">11 CFR 104.3(a)(1)</a>."},{"term":"CFR","definition":"Code of Federal Regulations. The annual collection of executive-agency regulations published in the daily Federal Register, combined with previously issued regulations that are still in effect. The sections of the CFR containing federal campaign finance regulations may be found in Title 11 and are <a href=\"https://www.fec.gov/regulations/\">available on the FECs website</a> or as a free publication from the FEC."},{"term":"Clearly identified candidate","definition":"A candidate is clearly identified when his or her name, nickname, photograph or drawing appears, or when his or her identity is otherwise apparent through an unambiguous reference such as the President, your Congressman, or the incumbent, or through an unambiguous reference to his or her status as a candidate such as the Democratic presidential nominee or the Republican candidate for Senate in the State of Georgia. 11 CFR <a href=\"https://www.fec.gov/regulations/100-17/CURRENT#100-17\">100.17</a>."},{"term":"Commercial vendor","definition":"Any person providing goods or services to a candidate or political committee whose usual and normal business involves the sale, rental, lease or provision of those goods or services. 11 CFR <a href=\"https://www.fec.gov/regulations/116-1/CURRENT#116-1-c\">116.1(c)</a>."},{"term":"Committee type","definition":"A definition that categorizes groups organized to receive and spend money in federal elections. The basic committee types are authorized committees, political party committees, separate segregated funds (SSFs) and nonconnected committees."},{"term":"Communications filers","definition":"Form 5, Form 7 and Form 9 filers, whose activity includes: <ul><li>Contributions reported by persons other than political committees</li><li>Independent expenditures reported by persons other than political committees</li><li>Communication costs reported by corporations and membership organizations</li><li>Electioneering communications</li></ul>"},{"term":"Conduit or intermediary","definition":"Any person who receives and forwards an earmarked contribution to a candidate or a candidates authorized committee. 11 CFR <a href=\"https://www.fec.gov/regulations/110-6/CURRENT#110-6-b-2\">110.6(b)(2)</a>."},{"term":"Connected organization","definition":"An organization that uses its treasury funds to establish, administer or solicit contributions to a separate segregated fund. 11 CFR <a href=\"https://www.fec.gov/regulations/100-6/CURRENT#100-6\">100.6(a)</a>."},{"term":"Contribution","definition":"A gift, subscription, loan, advance or deposit of money or anything of value given to influence a federal election; or the payment by any person of compensation for the personal services of another person if those services are rendered without charge to a political committee for any purpose. 11 CFR <a href=\"https://www.fec.gov/regulations/100-52/CURRENT#100-52\">100.52(a)</a> and <a href=\"https://www.fec.gov/regulations/100-54/CURRENT#100-54\">100.54</a>."},{"term":"Contribution in the name of another","definition":"Giving money or anything of value, all or part of which was provided to the contributor by another person (the true contributor) without disclosing the source of the money or the thing of value to the recipient candidate or committee at the time the contribution is made; or making a contribution of money or anything of value and attributing as the source another person when in fact the contributor is the source. <a href=\"https://www.fec.gov/regulations/110-4/CURRENT#110-4-b\">11 CFR 110.4(b)</a>."},{"term":"Coordinated","definition":"Made in cooperation, consultation or concert with, or at the request or suggestion of, a candidate, a candidates authorized committee or their agents, or a political party committee or its agents. 11 CFR <a href=\"https://www.fec.gov/regulations/109-20/CURRENT#109-20\">109.20(a)</a>."},{"term":"Coordinated communication","definition":"A communication that satisfies a three-pronged test: <ol class='list-bulleted'>><li>The communication must be paid for by a person other than a federal candidate, authorized committee, or a political party committee, or any agents of the aforementioned entities with whom the communication is coordinated.</li><li>One or more of the five content standards set forth in <a href=\"https://www.fec.gov/regulations/109-21/CURRENT#109-21-c\">11 CFR 109.21(c)</a> must be satisfied; and</li><li>One or more of the five conduct standards set forth in <a href=\"https://www.fec.gov/regulations/109-21/CURRENT#109-21-d\">11 CFR 109.21(d)</a> must be satisfied.</li></ol>A payment for a communication satisfying all three prongs is an in-kind contribution to the candidate or political party committee with which it was coordinated. 11 CFR <a href=\"https://www.fec.gov/regulations/109-21/CURRENT#109-21\">109.21</a>."},{"term":"Coordinated party expenditure","definition":"A special type of expenditure that can be made only by a national or state political party committee in connection with the general election of a candidate. These expenditures are subject to a separate set of limits and do not count against the partys normal contribution limits with respect to each candidate. 11 CFR <a href=\"https://www.fec.gov/regulations/109-30/CURRENT#109-30\">109.30</a> and <a href=\"https://www.fec.gov/regulations/109-32/CURRENT#109-32\">109.32-37</a>."},{"term":"Corporation","definition":"Any separately incorporated entity (other than a political committee that has incorporated for liability purposes only). 11 CFR <a href=\"https://www.fec.gov/regulations/100-134/CURRENT#100-134-l\">100.134(l)</a> and <a href=\"https://www.fec.gov/regulations/114-12/CURRENT#114-12\">114.12(a)</a>. The term corporation covers both for-profit and nonprofit corporations and includes nonstock corporations, incorporated membership organizations, incorporated cooperatives, incorporated trade associations, professional corporations and, under certain circumstances, limited liability companies."},{"term":"Custodian of Records","definition":"The individual or entity holding possession of a political committees books and accounts.The Custodian of Records is listed on the committees Statement of Organization. 11 CFR <a href=\"https://www.fec.gov/regulations/102-2/CURRENT#102-2-a-1-ii\">102.2(a)(1)(iii)</a>."},{"term":"Date made","definition":"The date the contributor relinquishes control over a contribution. A contribution that is mailed is considered made on the date of the postmark. In the case of an in-kind contribution, a contribution is made on the date the goods or services are provided by the contributor. This date determines the election or calendar year limit against which a contribution counts. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-6\">110.1(b)(6)</a>."},{"term":"Date received","definition":"The date a committee (or a person acting on the committees behalf) takes possession of the contribution. 11 CFR <a href=\"https://www.fec.gov/regulations/102-8/CURRENT#102-8\">102.8(a)</a>. This date is used for FEC reporting."},{"term":"Debt","definition":"Debts include unpaid bills. FEC reports show the amount of reportable debt a committee owes to other entities at the end of the filing period."},{"term":"Delegate","definition":"An individual who is or seeks to become a delegate to a national nominating convention or to a state, district or local convention, caucus or primary held to select delegates to a national nominating convention. 11 CFR <a href=\"https://www.fec.gov/regulations/110-14/CURRENT#110-14-b\">110.14(b)(1)</a>."},{"term":"Delegate committee","definition":"A group organized for the purpose of influencing the selection of one or more delegates. The term includes a group of delegates, a group of individuals seeking to become delegates and a group of individuals supporting delegates. 11 CFR <a href=\"https://www.fec.gov/regulations/110-14/CURRENT#110-14-b-2\">110.14(b)(2)</a>."},{"term":"Designated/designation","definition":"A contribution is considered to be designated in writing for a particular election if <ul class='list-bulleted'><li>The contribution is made by check, money order, or other negotiable instrument which clearly indicates the particular election with respect to which the contribution is made;</li><li>The contribution is accompanied by a writing, signed by the contributor, which clearly indicates the particular election with respect to which the contribution is made; or</li>The contribution is redesignated in accordance with <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-4-iii\">11 CFR 110.1(b)(5)</a>.</li></ul> <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-4\">11 CFR 110.1(b)(4)</a>."},{"term":"Direct mail","definition":"Any mailings made by a commercial vendor or made from a commercial list. 11 CFR <a href=\"https://www.fec.gov/regulations/100-87/CURRENT#100-87\">100.87(a)</a>, <a href=\"https://www.fec.gov/regulations/100-89/CURRENT#100-89-a\">100.89(a)</a>, <a href=\"https://www.fec.gov/regulations/100-147/CURRENT#100-147-a\">100.147(a)</a> and <a href=\"https://www.fec.gov/regulations/100-149/CURRENT#100-149\">100.149(a)</a>"},{"term":"Disbursement","definition":"Any purchase or payment made by a political committee or any other person that is subject to the Federal Election Campaign Act. 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-d\">300.2(d)</a>."},{"term":"Disclaimer notice","definition":"A disclaimer notice is a statement that identifies the person(s) who paid for a communication and whether the communication was authorized by one or more candidates. 11 CFR <a href=\"https://www.fec.gov/regulations/110-11/CURRENT#110-11\">110.11</a>."},{"term":"District","definition":"A U.S. House of Representatives District. Because Senators represent an entire state, Senate races do not have districts associated with them."},{"term":"Donation","definition":"A payment, gift, subscription, loan, advance, deposit or anything of value given to a person but does not include contributions.11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-d-2\">300.2(e)</a>."},{"term":"Earmarked contribution","definition":"A contribution that the contributor directs (either orally or in writing) to or on behalf of a clearly identified candidate or authorized committee through an intermediary or conduit. Earmarking may take the form of a designation, instruction or encumbrance, and it may be direct or indirect, express or implied. 11 CFR <a href=\"https://www.fec.gov/regulations/110-6/CURRENT#110-6\">110.6</a>."},{"term":"Election","definition":"Any one of several processes by which an individual seeks nomination for election, or election, to federal office. They include: a primary election, including a caucus or convention that has authority to select a nominee; a general election; a runoff election; and a special election held to fill a vacant seat. 11 CFR <a href=\"https://www.fec.gov/regulations/100-2/CURRENT#100-2\">100.2</a>."},{"term":"Election cycle","definition":"The period beginning the day after the previous general election for a given federal office and ending on the date of the general election for that office. The number of years in an election cycle differs according to the federal office sought. The election cycle spans two years for House candidates; four years for presidential candidates; and six years for Senate candidates. See 11 CFR <a href=\"https://www.fec.gov/regulations/100-3/CURRENT#100-3-b\">100.3(b)</a>."},{"term":"Electioneering communication","definition":"Any broadcast, cable or satellite communication that (1) refers to a clearly identified candidate for federal office; (2) is publicly distributed within certain time periods before an election and (3) is targeted to the relevant electorate. 11 CFR <a href=\"https://www.fec.gov/regulations/100-29/CURRENT#100-29\">100.29</a>."},{"term":"Employer","definition":"The organization or person by whom an individual is employed, and not the name of his or her supervisor. <a href=\"https://www.fec.gov/regulations/100-21/CURRENT#100-21\">11 CFR 100.21</a>."},{"term":"Ending cash-on-hand","definition":"The total amount of cash on hand that remains after the amount of cash-on-hand at the beginning of the reporting period is adjusted to add the total receipts for the reporting period and subtract the total disbursements for the reporting period."},{"term":"Executive and administrative personnel","definition":"Individuals employed by a corporation or labor organization who are paid on a salary rather than hourly basis and who have policymaking, managerial, professional, or supervisory responsibilities. The definition does not include professionals who are represented by a labor organization, salaried foremen and lower-level supervisors having direct supervision over hourly employees, former or retired personnel who are not stockholders, and consultants who are not employees under the Internal Revenue Code. 11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-c\">114.1(c)</a>, <a href=\"https://www.ecfr.gov/cgi-bin/text-idx?SID=8fcc28cd0cc7d6262e5dbe3865335df0&mc=true&node=se26.17.31_13401_2c_3_61&rgn=div8\">26 CFR 31.3401(c)-1</a>."},{"term":"Exempt party activities","definition":"Certain candidate support activities that state and local party groups may undertake without making a contribution or expenditure, provided specific rules are followed."},{"term":"Expenditure","definition":"A purchase, payment, distribution, loan, advance, deposit or gift of money or anything of value made for the purpose of influencing a federal election. A written agreement to make an expenditure is also considered an expenditure. 11 CFR <a href=\"https://www.fec.gov/regulations/100-111/CURRENT#100-111\">100.111</a> and <a href=\"https://www.fec.gov/regulations/100-112/CURRENT#100-112\">100.112</a>."},{"term":"Express advocacy","definition":"Unambiguously advocating the election or defeat of a clearly identified federal candidate. There are two ways that a communication can be defined as express advocacy (candidate advocacy): by use of certain explicit words of advocacy of election or defeat and by the only reasonable interpretation test. See 11 CFR <a href=\"https://www.fec.gov/regulations/100-22/CURRENT#100-22\">100.22</a>."},{"term":"Facilitation","definition":"The use of corporate or labor organization resources or facilities to engage in fundraising activities in connection with any federal election (other than raising funds for the organizations separate segregated fund). Facilitation results in a prohibited contribution to the committee that benefits from the activity. 11 CFR <a href=\"https://www.fec.gov/regulations/114-2/CURRENT#114-2-f\">114.2(f)</a>."},{"term":"Family","definition":"For purposes of the rules governing fundraising by corporate/labor/trade PACs, the Commission views the term \"family\" to mean the spouses, parents, and children who live in the same household. Spouse is defined by state law. See <a href=\"https://www.fec.gov/data/legal/advisory-opinions/2013-06\">AOs 2013-06</a> and <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1980-102\">1980-102</a>. For purposes of the rules governing the use of campaign funds by candidates, a candidates family includes the candidates spouse, any child, step-child, parent, grandparent, sibling, half-sibling or step-sibling of the candidate or the candidate's spouse, the spouse of any child, step-child, parent, grandparent, sibling, half-sibling or step-sibling of the candidate; and any person who shares a residence with the candidate. See 11 CFR  <a href=\"https://www.fec.gov/regulations/113-1/CURRENT#113-1-g-7\">113.1(g)(7)</a>. Publicly funded presidential candidates should refer to 11 CFR <a href=\"https://www.fec.gov/regulations/9003-2/CURRENT#9003-2-c-1\">9003.2(c)(1)</a> and <a href=\"https://www.fec.gov/regulations/9035-2/2017-annual-9035#9035-2-b\">9035.2(b)</a>."},{"term":"Federal Election Activity (FEA)","definition":"Activity by state, district and local party committees, which may be paid for with federal or  in the case of the first two types  a combination of federal and Levin funds. The four types of federal election activity are as follows:<ul class=\"list-numbered\"><li>Voter registration activity during the period 120 days before a primary or general election and ending on election day itself;</li><li>Voter identification, get-out-the-vote and generic campaign activity conducted in connection with an election in which a federal candidate appears on the ballot;</li><li>A public communication that refers to a clearly identified candidate for federal office and that promotes, attacks, supports or opposes any candidate for federal office. The communication does not need to expressly advocate the election or defeat of the federal candidate to qualify as federal election activity; and </li><li>Services provided during a month by an employee of a state, district or local party committee who spends more than 25 percent of his or her compensated time during that month on activities in connection with a federal election including FEA.</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/100-24/CURRENT#100-24-b\">100.24(b)</a>."},{"term":"Federal funds","definition":"Funds that comply with the limits, prohibitions and reporting requirements of the Federal Election Campaign Act. 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-g\">300.2(g)</a>."},{"term":"Federal government contractor","definition":"A person who enters into a contract, or is bidding on such a contract, with any agency or department of the United States government and is paid, or is to be paid, for services, material, equipment, supplies, land or buildings with funds appropriated by Congress. 11 CFR <a href=\"https://www.fec.gov/regulations/115-1/CURRENT#115-1\">115.1</a>."},{"term":"Federal officeholder","definition":"An individual elected to or serving in the office of President or Vice President of the United States, or a Senator or Representative in, or a Delegate or Resident Commissioner, to the Congress of the United States. 11 CFR <a href=\"https://www.fec.gov/regulations/113-1/CURRENT#113-1-c\">113.1(c)</a> and <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-o\">300.2(o)</a>."},{"term":"Federally chartered corporation","definition":"A corporation that is organized pursuant to a federal statute and that became a corporation when it received a charter from a federal agency. See <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1988-12\">AOs 1988-12</a> and <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1984-63\">1984-63</a>."},{"term":"Filing","definition":"A report, designation or statement submitted to the FEC or Secretary of the Senate by a candidate, committee or other entity. Required filings include declarations of candidacy and committee reports of the money they receive and spend.  See also \"Reports, designations and statements\"."},{"term":"Foreign national","definition":"<ol><li> An individual who is not a citizen of the United States or a national of the United States and has not been lawfully admitted to the U.S. for permanent residence, as defined in 8 U.S.C.  1101(a)(20); or</li><li>A foreign principal, as defined in 22 U.S.C.  611(b).</li></ol> 11 CFR <a href=\"https://www.fec.gov/regulations/110-20/CURRENT#110-20-a\">110.20(a)(3)</a>."},{"term":"Generic campaign activity","definition":"A type of Federal Election Activity, as distinguished from voter drive activity. Generic campaign activity is a public communication that promotes or opposes a political party and does not promote or oppose a clearly identified federal candidate or a nonfederal candidate. 11 CFR <a href=\"https://www.fec.gov/regulations/100-25/CURRENT#100-25\">100.25</a>."},{"term":"Get-Out-The-Vote (GOTV)","definition":"In regard to FEA, GOTV activity encompasses all means of assisting, encouraging or urging potential voters to vote. This activity includes, but is not limited to: <ul><li>Encouraging or urging potential voters to vote, whether by mail (including direct mail), email, in person, by telephone (including prerecorded telephone calls, phone banks and messaging such as SMS and MMS), or by any other means;</li><li>Informing potential voters, whether by mail (including direct mail), email, in person, by telephone (including pre-recorded telephone calls, phone banks and messaging such as SMS and MMS), or by any other means, about the hours or location of polling places, or about early voting or voting by absentee ballot;</li><li>Offering or arranging to transport, or actually transporting voters to the polls;</li><li>Any other activity that assists potential voters in voting.</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/100-24/CURRENT#100-24-a-3\">100.24(a)(3)</a>."},{"term":"Hybrid PAC","definition":"A committee that, in addition to making contributions, establishes a separate bank account to deposit and withdraw funds raised in unlimited amounts from individuals, corporations, labor organizations and/or other political committees, consistent with the stipulated judgment in <i>Carey v. FEC</i>. The funds maintained in this separate account will not be used to make contributions, whether direct, in-kind or via coordinated communications, or coordinated expenditures, to federal candidates or committees."},{"term":"Identification","definition":"For purposes of recordkeeping and reporting, a persons full name and address and, in the case of an individual, his or her occupation (principal job title or position) and employer (organization or person by whom an individual is employed) as well. 11 CFR <a href=\"https://www.fec.gov/regulations/100-12/CURRENT#100-12\">100.12</a>, <a href=\"https://www.fec.gov/regulations/100-20/CURRENT#100-20\">100.20</a> and <a href=\"https://www.fec.gov/regulations/100-21/CURRENT#100-21\">100.21</a>."},{"term":"In-kind contribution","definition":"A contribution of goods, services or property offered free or at less than the usual and normal charge. The term also includes payments made on behalf of, but not directly to, candidates and political committees (except for independent expenditures or non-coordinated communications). 11 CFR <a href=\"https://www.fec.gov/regulations/100-52/CURRENT#100-52-d\">100.52(d)</a>."},{"term":"Independent expenditure","definition":"An expenditure for a communication <ul><li>That expressly advocates the election or defeat of a clearly identified candidate and</li><li>That is not made in cooperation, consultation or concert with, or at the request or suggestion of, any candidate, or his or her authorized committees or agents, or a political party committee or its agents. 11 CFR <a href=\"https://www.fec.gov/regulations/100-16/CURRENT#100-16\">100.16</a>.</li></ul>"},{"term":"Independent expenditure only committee","definition":"Political committees that make only independent expenditures that may solicit and accept unlimited contributions from individuals, corporations, labor organizations and other political committees. They may not accept contributions from foreign nationals, federal contractors, national banks or federally chartered corporations. See <a href=\"https://www.fec.gov/data/legal/advisory-opinions/2010-11/\">AO 2010-11</a>. Such committees, popularly known as Super PACs, must register with the Commission and comply with all applicable reporting requirements of the Act."},{"term":"Joint contribution","definition":"A contribution made by more than one person on a single check or other written instrument. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-k\">110.1(k)(1)</a>."},{"term":"Joint fundraising","definition":"Fundraising conducted jointly by a political committee and one or more other political committees or unregistered organizations.  Joint fundraising is often conducted between a principal campaign committee and a political party committee."},{"term":"Joint fundraising committee","definition":"A committee that has been set up for the purposes of fundraising for multiple committees at the same time or an existing committee that has been authorized to serve that purpose."},{"term":"Labor organization","definition":"An organization, agency or employee representative committee or plan, in which employees participate and which exists for the purpose of dealing with employers on grievances, labor disputes, wages, hours of employment or working conditions. 11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-d\">114.1(d)</a>."},{"term":"Leadership PAC","definition":"A political committee that is directly or indirectly established, financed, maintained or controlled by a candidate or an individual holding federal office, but is not an authorized committee of the candidate or officeholder and is not affiliated with an authorized committee of a candidate or officeholder."},{"term":"Levin funds","definition":"A category of funds raised by state, district and local party committees that may be spent for certain Federal Election Activities. Levin funds are donations from sources ordinarily prohibited by federal law but permitted by state law. 11 CFR <a href=\"https://www.fec.gov/regulations/300-31/CURRENT#300-31\">300.31</a> and <a href=\"https://www.fec.gov/regulations/300-32/CURRENT#300-32\">300.32</a>."},{"term":"Limited liability company (LLC)","definition":"A business entity that is recognized as a limited liability company under the laws of the state in which it is established. LLCs that are treated as partnerships under the IRS code may make contributions. LLCs that have publicly traded stock or are treated as corporations under the IRS code are prohibited from making contributions. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-g\">110.1(g)</a>."},{"term":"Lobbyist/registrant","definition":"A person who is a current registrant under the Lobbying Disclosure Act, or an individual who is named on a current registration or report filed under the Lobbying Disclosure Act. See 11 CFR <a href=\"https://www.fec.gov/regulations/104-22/CURRENT#104-22\">104.22</a>."},{"term":"Lobbyist/Registrant PAC","definition":"Any political committee established or controlled by a person who is a current registrant under Lobbying Disclosure Act or an individual who is named on a current registration or report filed under the Lobbying Disclosure Act."},{"term":"Local or district party committee","definition":"A political committee that, by virtue of the bylaws of a political party, is responsible for the day-to-day operation of a political party at a level lower than the state level (e.g., city, county, ward). 11 CFR <a href=\"https://www.fec.gov/regulations/100-14/CURRENT#100-14-b\">100.14(b)</a>."},{"term":"Local party organization","definition":"A local party organization is an organization that is responsible for a political party's activities below the state level (such as city, county or district level) but is not registered with the Federal Election Commission as a district or local party committee."},{"term":"Major party","definition":"A political party whose candidate in the preceding presidential election received, as the candidate of such party, 25 percent or more of the popular vote. 11 CFR <a href=\"https://www.fec.gov/regulations/9002-6/CURRENT#9002-6\">9002.6</a> and <a href=\"https://www.fec.gov/regulations/9008-2/CURRENT#9008-2\">9008.2(c)</a>."},{"term":"Matter Under Review (MUR)","definition":"An FEC enforcement action, initiated by a sworn complaint or by an internal administrative action."},{"term":"Member","definition":"With respect to a labor organization, a trade association, a cooperative or other incorporated membership organization, a member is an individual or other entity that: <ul><li>Satisfies the requirements for membership in a membership organization;</li><li> affirmatively accepts the organizations invitation to become a member; and</li><li>maintains a long-term and continuous bond with the organization by:<ul><li>having a significant financial attachment, such as a significant investment or ownership stake;</li><li>paying annual dues; or</li><li>having direct participatory rights in the governance of the organization.</li></ul></li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-e-2\">114.1(e)(2)</a>."},{"term":"Membership organization","definition":"A labor organization or a trade association, cooperative or other incorporated membership organization that:<ul><li>is composed of members;</li><li>expressly states the qualifications for membership in its articles and by-laws;</li><li>makes its articles, by-laws and other organizational documents available to its members;</li><li>expressly seeks members;</li><li>acknowledges the acceptance of membership, such as by sending membership cards to new members or including them on a membership newsletter list; and</li><li>is not organized primarily for the purpose of influencing a federal election.</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/100-134/CURRENT#100-134-e\">100.134(e)</a> and <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-e\">114.1(e)(1)</a>."},{"term":"Memo entry/memo item","definition":"Supplemental or explanatory information on a reporting schedule. A memo entry is often used to disclose additional information about an itemized transaction that is included in the total receipts or disbursements for the current report or a previous report. The dollar amount in a memo entry is not incorporated into the total figure for the schedule."},{"term":"Memo text","definition":"A field offered in FECFile software and some commercial software to allow a committee to provide additional text to describe a particular transaction it is reporting."},{"term":"Multicandidate committee","definition":"A political action committee or party committee that has been registered at least 6 months, has more than 50 contributors and, with the exception of state party committees, has made contributions to at least 5 candidates for federal office. 11 CFR <a href=\"https://www.fec.gov/regulations/100-5/CURRENT#100-5-e-3\">100.5(e)(3)</a>."},{"term":"National bank","definition":"A bank that is subject to the supervision of the <a href=\"https://www.helpwithmybank.gov/dictionary/index-dictionary.html#N\">Comptroller of the Currency</a>. The Office of the Comptroller of the Currency is a bureau of the U.S. Treasury Department."},{"term":"National committee","definition":"An organization that, by virtue of the bylaws of a political party, is responsible for the day-to-day operation of the political party at the national level, as determined by the Commission. 11 CFR <a href=\"https://www.fec.gov/regulations/100-13/CURRENT#100-13\">100.13</a>."},{"term":"National party committee","definition":"A political committee established and maintained by a national political party. A partys national committee, House campaign committee and Senate campaign committee are considered national party committees, as determined by the Commission. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-c-2\">110.1(c)(2)</a>; <a href=\"https://www.fec.gov/regulations/110-2/CURRENT#110-2-c-2\">110.2(c)(2)</a>; <a href=\"https://www.fec.gov/regulations/110-3/CURRENT#110-3-b-1-ii\">110.3(b)(2)</a>."},{"term":"Net debts outstanding","definition":"The total of a campaigns unpaid debts incurred with respect to an election plus estimated costs to liquidate the debts plus costs of terminating political activity (if appropriate) minus cash on hand and receivables. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-3-ii\">110.1(b)(3)(ii)</a>."},{"term":"Nonconnected committee","definition":"Any committee that conducts activities in connection with an election, but that is not a party committee, an authorized committee of any candidate for federal election, or a separate segregated fund. 11 CFR <a href=\"https://www.fec.gov/regulations/100-6/CURRENT#100-6\">106.6(a)</a>."},{"term":"Non-contribution account","definition":"A separate bank account to deposit and withdraw funds raised in unlimited amounts from individuals, corporations, labor organizations and/or other political committees, consistent with the stipulated judgment in <i>Carey v. FEC</i>. The funds maintained in this separate account will not be used to make contributions, whether direct, in-kind or via coordinated communications, or coordinated expenditures, to federal candidates or committees."},{"term":"None","definition":"If data appears as \"None\", it's best to check the source document. Common reasons that the data appears as \"None\" are:<ul><li>Data is not processed yet; often, paper filings cause delays and inconsistent upload times.</li><li>Data is from an amendment that did not properly identify the form it was amending.</li><li>The filer did not fill out the information on the form.</li></ul>If you think there is an error, you can report that via our feedback tool."},{"term":"Nonfederal funds","definition":"Funds that are not subject to the limitations or prohibitions of the Federal Election Campaign Act. 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-k\">300.2(k)</a>."},{"term":"Occupation","definition":"The principal job title or position of an individual and whether or not self-employed. 11 CFR <a href=\"https://www.fec.gov/regulations/100-20/CURRENT#100-20\">100.20</a>."},{"term":"One-third rule","definition":"A formula used to ensure the treasury funds of a connected organization are not traded for voluntary contributions when the organization pays for prizes or entertainment to offer as an incentive to make a contribution to its SSF. Under the one-third rule, the SSF must reimburse the connected organization for costs that exceed one-third of the money raised. See 11 CFR <a href=\"https://www.fec.gov/regulations/114-5/CURRENT#114-5-b-2\">114.5(b)(2)</a>."},{"term":"Ongoing committee","definition":"Any political committee that has not terminated and does not qualify as a terminating committee. 11 CFR <a href=\"https://www.fec.gov/regulations/116-1/CURRENT#116-1-b\">116.1(b)</a>."},{"term":"Operating expenditures","definition":"A committee's day-to-day expenditures for items such as rent, overhead, administration, personnel, equipment, travel, advertising and fundraising."},{"term":"Ordinary course of business","definition":"In determining whether credit was extended in the ordinary course of business, the Commission will consider<ul class='list-bulleted'><li>Whether the commercial vendor followed its established procedures and its past practice in approving the extension of credit;</li><li>Whether the commercial vendor received prompt payment in full if it previously extended credit to the same candidate or political committee; and</li><li>Whether the extension of credit conformed to the usual and normal practice in the commercial vendor's trade or industry. </li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/116-3/CURRENT#116-3-c\">116.3(c)</a>."},{"term":"Organization type","definition":"Certain filers, like separate segregated funds and communication cost filers, identify the types of organizations they are connected with. These connected organizations can be identified as corporations, trade associations, labor organizations, cooperatives, membership organizations or corporations without capital stock."},{"term":"Overnight delivery service","definition":"A private delivery service business of established reliability that offers an overnight (next business day) delivery option."},{"term":"Party committee","definition":"A political committee that represents a political party and is part of the official party structure at the national, state or local level."},{"term":"PASO","definition":"PASO is an acronym that stands for Promote, Attack, Support or Oppose. See, e.g., 11 CFR <a href=\"https://www.fec.gov/regulations/100-24/CURRENT#100-24-b-3\">100.24(b)(3)</a>."},{"term":"Person","definition":"An individual, partnership, political committee, corporation, labor organization or any other organization or group of persons, not including the federal government. 11 CFR <a href=\"https://www.fec.gov/regulations/100-10/CURRENT#100-10\">100.10</a>."},{"term":"Personal funds of a candidate","definition":"The personal funds of a candidate include: <ul class='list-bulleted'><li>Assets which the candidate has a legal right of access to or control over, and which he or she has legal title to or an equitable interest in, at the time of candidacy;</li><li>Income from employment;</li><li>Dividends and interest from, and proceeds from sale or liquidation of, stocks and other investments;</li><li>Income from trusts, if established before the election cycle;</li><li>Income from trusts established by bequests (even after candidacy)</li><li>Bequests to the candidate;</li><li>Personal gifts that had been customarily received by the candidate prior to the beginning of the election cycle; and</li><li>Proceeds from lotteries and similar games of chance.</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/100-33/CURRENT#100-33\">100.33(a) and (b)</a>."},{"term":"Political Action Committee (PAC)","definition":"Popular term for a political committee that is neither a party committee nor an authorized committee of a candidate. PACs directly or indirectly established, administered or financially supported by a corporation or labor organization are called separate segregated funds (SSFs). PACs without such a corporate or labor sponsor are called nonconnected PACs."},{"term":"Political committee","definition":"An entity that meets one of the following conditions:<ul><li>An authorized committee of a candidate (see definition of candidate)</li><li>Any club, association or other group of persons that receives contributions or makes expenditures, either of which aggregate over $1,000 during a calendar year</li><li>A local unit of a political party (except a state party committee) that: (1) receives contributions aggregating over $5,000 during a calendar year; (2) makes contributions or expenditures either of which aggregate over $1,000 during a calendar year or (3) makes payments aggregating over $5,000 during a calendar year for certain activities that are exempt from the definitions of contribution and expenditure (11 CFR <a href=\"https://www.fec.gov/regulations/100-80/CURRENT#100-80\">100.80</a>, <a href=\"https://www.fec.gov/regulations/100-87/CURRENT#100-87\">100.87</a> and <a href=\"https://www.fec.gov/regulations/100-89/CURRENT#100-89\">100.89</a>; 11 CFR <a href=\"https://www.fec.gov/regulations/100-140/CURRENT#100-140\">100.140</a>, <a href=\"https://www.fec.gov/regulations/100-140/CURRENT#100-147>100.147</a> and <a href=\"https://www.fec.gov/regulations/100-149/CURRENT#100-149\">100.149</a>).</li><li>Any separate segregated fund upon its establishment. 11 CFR <a href=\"https://www.fec.gov/regulations/100-5/CURRENT#100-5-b\">100.5</a>.</li></ul>"},{"term":"Political party","definition":"An association, committee or organization that nominates or selects a candidate for election to federal office whose name appears on the election ballot as the candidate of the organization."},{"term":"Postmarked","definition":"A U.S. Postal Service postmark or the verifiable date of deposit with an overnight delivery service."},{"term":"Presidential public funds","definition":"Public funding of presidential elections means that qualified presidential candidates may choose to receive federal government funds to pay for certain expenses of their political campaigns in both the primary and general elections. Prior to the 2016 presidential election, national political parties could also receive federal money for their national nominating conventions."},{"term":"Principal campaign committee","definition":"An authorized committee designated by a candidate as the principal committee to raise contributions and make expenditures for his or her campaign for a federal office."},{"term":"Prior approval","definition":"A written request to a member corporation of a trade association to a member corporation for permission to solicit the members restricted class. This request for approval must inform the member corporation that corporate approval is necessary before the trade association or its SSF may conduct a solicitation and the corporation may not approve solicitations by another trade association for the same calendar year. 11 CFR <a href=\"https://www.fec.gov/regulations/114-8/CURRENT#114-8-d-3\">114.8(d)(3)</a>."},{"term":"Public communication","definition":"A communication by means of any broadcast, cable or satellite communication, newspaper, magazine, outdoor advertising facility, mass mailing or telephone bank to the general public, or any other form of general public political advertising. The term general public political advertising does not include communications made over the internet, except for communications placed for a fee on another persons website. 11 CFR <a href=\"https://www.fec.gov/regulations/100-26/CURRENT#100-26\">100.26</a>, <a href=\"https://www.fec.gov/regulations/100-27/CURRENT#100-27\">100.27</a> (definition of mass mailing) and <a href=\"https://www.fec.gov/regulations/100-28/CURRENT#100-28\">100.28</a> (definition of telephone bank)."},{"term":"Qualified/non-qualified","definition":"In the context of multicandidate political committees identified in FEC data reports and indices, the designation qualified or non-qualified reflects whether a political committee has satisfied the criteria for multicandidate political committee status (i.e., whether the committee has been registered for at least 6 months, received contributions from more than 50 persons, and made contributions to 5 or more federal candidates). Committees listed as non-qualified do not satisfy these requirements. See 11 CFR <a href=\"https://www.fec.gov/regulations/100-5/CURRENT#100-5-e-3\">100.5(e)(3)</a>."},{"term":"Reattributed contribution","definition":"The portion of an excessive contribution that has been attributed in writing to another contributor and signed by both contributors. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-k-3-ii\">110.1(k)(3)(ii)</a>."},{"term":"Receipt","definition":"Anything of value (money, goods, services or property) received by a political committee."},{"term":"Redesignated contribution","definition":"With regard to contributions made to candidates, the portion of a contribution that has been designated by the contributor, in writing, to an election other than the one for which the funds were originally given. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-4-iii\">110.1(b)(5)</a>."},{"term":"Refunded contribution","definition":"A contribution is refunded when the recipient committee deposits the contribution and sends the contributor a check for the amount (or a portion) of the contribution. 11 CFR <a href=\"https://www.fec.gov/regulations/103-3/CURRENT#103-3-b\">103.3(b)</a>."},{"term":"Reports, designations and statements","definition":"All committees registered with the FEC and other persons who make certain expenditures or disbursements are required to file reports, designations and statements that disclose their financial activity. The contents of those reports and statements, as well as the filing schedule, depend on the type of committee or organization, or the type of expenditure or disbursement made.  See also \"Filing.\"."},{"term":"Restricted class/solicitable class","definition":"Those persons, including the executive and administrative personnel, members or stockholders (and the families of each) within a corporation or labor organization, who may be solicited for contributions to the organizations separate segregated fund at any time and who may receive certain communications from the organization. 11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-j\">114.1(j)</a>; <a href=\"https://www.fec.gov/regulations/114-3/CURRENT#114-3\">114.3(a)</a>; <a href=\"https://www.fec.gov/regulations/114-5/CURRENT#114-5-g\">114.5(g)</a>; <a href=\"https://www.fec.gov/regulations/114-7/CURRENT#114-7\">114.7(a) and (h)</a>; and <a href=\"https://www.fec.gov/regulations/114-8/CURRENT#114-8-c\">114.8(c), (h) and (i)</a>."},{"term":"Separate segregated fund (SSF)","definition":"A political committee established, administered or financially supported by a corporation or labor organization, popularly called a Corporate or Labor Political Action Committee (PAC). See 11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-a-2\">114.1(a)(2)(iii)</a>. The term \"financially supported\" does not include contributions to the SSF, but does include the payment of establishment, administration or solicitation costs. <a href=\"https://www.fec.gov/regulations/100-6/CURRENT#100-6-c\">11 CFR 100.6(c)</a>."},{"term":"Solicitation (SSF)","definition":"A statement that publicizes the SSFs right to accept unsolicited contributions from any lawful contributor; provides information on how to contribute to the SSF; or encourages support for the SSF. <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1984-55/\">AO 198455, n. 2</a>; AOs <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1979-66/\">197966</a> and <a href=\"https://www.fec.gov/data/legal/advisory-opinions/1979-13/\">197913</a>."},{"term":"Special election","definition":"A primary, general or runoff election that is not a regularly scheduled election and that is held to fill a vacant seat in the House of Representatives or the Senate. <a href=\"https://www.fec.gov/regulations/100-2/CURRENT#100-2-f\">100.2(f)</a>."},{"term":"State party committee","definition":"A committee which, by virtue of the bylaws of a political party or the operation of state law is part of the official party structure and is responsible for the day-to-day operation of the party at the state level, including an entity that is directly or indirectly established, financed, maintained or controlled by that organization, as determined by the Commission. 11 CFR <a href=\"https://www.fec.gov/regulations/100-14/CURRENT#100-14\">100.14(a)</a>."},{"term":"Status","definition":"Refers to whether the candidate is an incumbent, challenger or running unopposed."},{"term":"Stockholder","definition":"A person who has a vested beneficial interest in stock, the power to direct how that stock is voted (if it is voting stock) and the right to receive dividends.11 CFR <a href=\"https://www.fec.gov/regulations/114-1/CURRENT#114-1-h\">114.1(h)</a>."},{"term":"Super PAC","definition":"A committee that intends to make independent expenditures, and  consistent with the U.S. Court of Appeals for the District of Columbia Circuit decision in <i>SpeechNow v. FEC</i>  it therefore intends to raise funds in unlimited amounts. This committee will not use those funds to make contributions, whether direct, in-kind or via coordinated communications, to federal candidates or committees."},{"term":"Terminating committee","definition":"A political committee that is winding down its activities in preparation for filing a termination report. A terminating committee has ceased to make or receive contributions or make expenditures (other than for debt retirement purposes or winding-down costs). 11 CFR <a href=\"https://www.fec.gov/regulations/116-1/CURRENT#116-1\">116.1(a)</a>."},{"term":"to Direct","definition":"For purposes of 11 CFR Part 300, to direct means to guide, directly or indirectly, a person who has expressed an intent to make a contribution, donation, transfer of funds or otherwise provide anything of value, by identifying a candidate, political committee or organization for the receipt of such funds or things of value. The contribution, donation, transfer or thing of value may be provided directly or through an intermediary. Direction does not include merely providing information or guidance as to the applicability of a particular law or regulation. 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/2017-annual-300#300-2-n\">300.2(n)</a>."},{"term":"to Solicit","definition":"For the purposes of 11 CFR <a href=\"https://www.fec.gov/regulations/300\">Part 300</a>, to solicit means to ask, request or recommend, explicitly or implicitly, that another person make a contribution, donation, transfer of funds or otherwise provide anything of value. A solicitation is an oral or written communication that, construed as reasonably understood in the context in which it is made, contains a clear message asking, requesting or recommending that a person make a contribution, donation, transfer of funds or otherwise provide anything of value. A solicitation may be made directly or indirectly. The context includes the conduct of persons involved in the communication. A solicitation does not include mere statements of political support or mere guidance as to the applicability of a particular law or regulation. 11 CFR <a href=\"https://www.fec.gov/regulations/300-2/CURRENT#300-2-l\">300.2(m)</a>."},{"term":"Total disbursements","definition":"The sum of all purchases and payments made during a filing period by a political committee or any other person, including an organization that is not a political committee that is subject to the Federal Election Campaign Act."},{"term":"Total receipts","definition":"The sum of all contributions and other receipts received by a committee during a filing period."},{"term":"Trade association","definition":"A membership organization consisting of persons engaged in a similar or related line of commerce. A trade association is organized to promote and improve business conditions in that line of commerce and not to engage in a regular business for profit. No part of the net earnings of a trade association may inure to the benefit of any member."},{"term":"Treasurer","definition":"Required for every political committee. The treasurer is responsible for filing the committee's registration form, depositing receipts, authorizing expenditures, monitoring contributions, keeping records, signing all reports and statements and filing all reports and statements on time."},{"term":"Treasury funds","definition":"Funds of a corporation or labor organization that are derived from commercial activities or dues payments. Treasury funds may be used for the establishment, administrative and fundraising costs of the organizations separate segregated fund, as well as for making independent expenditures and contributing to Super PACs and the non-contribution accounts of Hybrid PACs. See 11 CFR <a href=\"https://www.fec.gov/regulations/114-5/CURRENT#114-5-b\">114.5(b)</a> and <a href=\"https://www.fec.gov/regulations/114-10/CURRENT#114-10\">114.10</a>."},{"term":"Undesignated contribution","definition":"Contributors may designate contributions for a particular election by indicating in writing the specific election to which they intend a contribution to apply. A contribution that is not designated by the contributor for a specific election is an undesignated contribution. Undesignated contributions count against the donors contribution limits for the candidates next election. 11 CFR <a href=\"https://www.fec.gov/regulations/110-1/CURRENT#110-1-b-2-ii\">110.1(b)(2)</a>."},{"term":"Unique identifier","definition":"A unique title or code assigned by a party committee to each program or event for which it reports an allocation ratio. Party committees must use that identifier consistently when reporting the activity. 11 CFR <a href=\"https://www.fec.gov/regulations/104-17/CURRENT#104-17-b-1-iii\">104.17(b)(1)(iii)</a>."},{"term":"U.S.C.","definition":"The United States Code (U.S.C.) contains the federal statutory laws of the United States, arranged into 54 broad titles according to subject matter. The FEC administers the <a href=\"https://www.fec.gov/data/legal/statutes/\">campaign finance laws</a> found in Title 52 and the portions of Title 26 of the United States Code concerning public financing of presidential election campaigns."},{"term":"Usual and normal charge","definition":"With regard to goods provided to a political committee, the term refers to the price of those goods in the market from which they ordinarily would have been purchased at the time they were provided. With regard to services, the term refers to the hourly or piecework charge for the services at a commercially reasonable rate prevailing at the time the services were rendered. 11 CFR <a href=\"https://www.fec.gov/regulations/100-52/CURRENT#100-52-d-2\">100.52(d)(2)</a>."},{"term":"Voter drive activity","definition":"Voter identification, voter registration and get-out-the-vote-drives, or any other activities that urge the general public to register or vote, or that promote or oppose a political party, without promoting any federal or nonfederal candidate, that do not qualify as FEA. This is a category of allocable activity for mixed federal/nonfederal party activity sometimes also referred to as a generic voter drive. 11 CFR <a href=\"https://www.fec.gov/regulations/106-7/CURRENT#106-7-c-5\">106.7(c)(5)</a>."},{"term":"Voter identification","definition":"With regard to FEA, this means acquiring information about potential voters, including, but not limited to, obtaining voter lists and creating or enhancing voter lists by verifying or adding information about the voters likelihood of voting in an upcoming election or voting for specific candidates. 11 CFR <a href=\"https://www.fec.gov/regulations/100-24/CURRENT#100-24-a-4\">100.24(a)(4)</a>."},{"term":"Voter registration activity","definition":"In regard to FEA, voter registration activity encompasses all means of contacting potential voters to assist, encourage or urge them to register to vote. This activity includes, but is not limited to: <ul><li>Encouraging or urging potential voters to register to vote, whether by mail (including direct mail), email, in person, by telephone (including pre-recorded telephone calls, phone banks and messaging such as SMS and MMS), or by any other means;</li><li>Preparing and distributing information about registration and voting;</li><li>Distributing voter registration forms or instructions to potential voters;</li><li>Answering questions about how to complete or file a voter registration form, or assisting potential voters in completing or filing such forms;</li><li>Submitting or delivering a completed voter registration form on behalf of a potential voter;</li><li>Offering or arranging to transport, or actually transporting potential voters to a board of elections or county clerks office for them to fill out voter registration forms; or</li><li>any other activity that assists potential voters to register to vote.</li></ul> 11 CFR <a href=\"https://www.fec.gov/regulations/100-24/CURRENT#100-24-a-2\">100.24(a)(2)</a>."}]

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
var _ = __webpack_require__(2);

var accessibility = __webpack_require__(28);

var feedback = __webpack_require__(248);

var statusClasses = {
  success: 'message--success',
  error: 'message--error'
};

/**
 * Feedback widget
 * @constructor
 * @param {String} url - AJAX URL
 * @param {String} parent - Optional parent selector; defaults to 'body'
 */
function Feedback(url, parent) {
  this.url = url;
  this.isOpen = false;
  this.$feedback = $(feedback());

  $(parent || 'body').append(this.$feedback);

  this.$button = this.$feedback.find('.js-feedback');
  this.$reset = this.$feedback.find('.js-reset');
  this.$box = this.$feedback.find('.js-feedback-box');
  this.$status = this.$box.find('.js-status');
  this.$message = this.$box.find('.js-message');
  this.$form = this.$feedback.find('form');

  this.$button.on('click', this.toggle.bind(this));
  this.$reset.on('click', this.reset.bind(this));
  this.$form.on('submit', this.submit.bind(this));

  accessibility.removeTabindex(this.$box);

  $(document.body).on('feedback:open', this.show.bind(this));
}

Feedback.prototype.toggle = function() {
  var method = this.isOpen ? this.hide : this.show;
  method.apply(this);
};

Feedback.prototype.show = function() {
  this.$box.attr('aria-hidden', 'false');
  this.$button.attr('aria-expanded', 'true');
  this.isOpen = true;

  accessibility.restoreTabindex(this.$box);
};

Feedback.prototype.hide = function() {
  this.$box.attr('aria-hidden', 'true');
  this.$button.attr('aria-expanded', 'false');
  this.isOpen = false;

  accessibility.removeTabindex(this.$box);
};

Feedback.prototype.submit = function(e) {
  /**
   * setup JQuery's AJAX methods to setup CSRF token in the request before sending it off.
   * http://stackoverflow.com/questions/5100539/django-csrf-check-failing-with-an-ajax-post-request
   */
  $.ajaxSetup({
     beforeSend: function(xhr, settings) {
       if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
           // Only send the token to relative URLs i.e. locally.
           xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
       }
     }
  });

  e.preventDefault();

  var data = _.chain(this.$box.find('textarea'))
    .map(function(elm) {
      var $elm = $(elm);
      return [$elm.attr('name'), $elm.val()];
    })
    .object()
    .value();

  if (!_.some(_.values(data))) {
    var message =
      '<h2 class="feedback__title">Input required</h2>' +
      '<p>Please fill out at least one field.</p>';
    var buttonText = 'Try again';
    this.message(message, buttonText, 'error');
    return;
  }

  var promise = $.ajax({
    method: 'POST',
    url: this.url,
    data: JSON.stringify(data),
    contentType: 'application/json',
    dataType: 'json'
  });

  promise.done(this.handleSuccess.bind(this));
  promise.fail(this.handleError.bind(this));
};

Feedback.prototype.handleSuccess = function(response) {
  var message =
    '<h2 class="feedback__title">Thanks for helping us improve</h2>' +
    '<p>This information has been reported on GitHub, where it\'s publicly visible. ' +
    '<a href="' + response.html_url + '">Track the status of your feedback</a>.</p>';
  var buttonText = 'Submit another issue';
  this.$box.find('textarea').val('');
  this.message(message, buttonText, 'success');
};

Feedback.prototype.handleError = function() {
  var message =
    '<h2 class="feedback__title">There was an error</h2>' +
    '<p>Please try submitting your issue again.</p>';
  var buttonText = 'Try again';
  this.message(message, buttonText, 'error');
};

Feedback.prototype.message = function(text, buttonText, style) {
  var self = this;
  this.$form.attr('aria-hidden', true);
  this.$status.attr('aria-hidden', false);
  this.$reset.text(buttonText);
  _.each(statusClasses, function(value) {
    self.$message.removeClass(value);
  });
  this.$message.html(text).addClass(statusClasses[style]);
};

Feedback.prototype.reset = function() {
  this.$form.attr('aria-hidden', false);
  this.$status.attr('aria-hidden', true);
};

module.exports = {Feedback: Feedback};


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var Handlebars = __webpack_require__(7);
module.exports = (Handlebars['default'] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div>\n  <button class=\"js-feedback feedback__toggle button--cta-primary\" aria-controls=\"feedback\" aria-expanded=\"false\" type=\"button\">Feedback</button>\n  <div id=\"feedback\" class=\"js-feedback-box feedback\" aria-hidden=\"true\">\n    <button class=\"js-feedback button--down feedback__close\"><span class=\"u-visually-hidden\">Close</span></button>\n    <div class=\"js-status\" aria-hidden=\"true\">\n      <div class=\"message message--inverse js-message\">\n      </div>\n      <ul class=\"list--buttons\">\n        <li><button class=\"js-reset button--cta-primary feedback__button\" type=\"button\">Submit another issue</button></li>\n      </ul>\n    </div>\n    <form id=\"feedback-form\" class=\"container\">\n      <fieldset>\n        <legend class=\"feedback__title\">Help us improve FEC.gov</legend>\n        <p class=\"t-sans\">Don't include sensitive information like your name, contact information or Social Security number.</p>\n        <label for=\"feedback-1\" class=\"label\">What were you trying to do and how can we improve it?*</label>\n        <textarea id=\"feedback-1\" name=\"action\"></textarea>\n        <label for=\"feedback-2\" class=\"label\">General feedback?</label>\n        <textarea id=\"feedback-2\" name=\"feedback\"></textarea>\n        <label for=\"feedback-3\" class=\"label\">Tell us about yourself</label>\n        <span class=\"label--help\">I'm a <span class=\"u-blank-space\"></span> interested in <span class=\"u-blank-space\"></span>.</span>\n        <textarea id=\"feedback-3\" name=\"about\"></textarea>\n        <p class=\"t-sans\">This information will be reported on GitHub where it will be publicly visible. You can review all reported feedback on <a href=\"https://github.com/18f/fec/issues\">our GitHub page</a>.</p>\n        <p class=\"t-sans t-note\">*Required</p>\n        <button type=\"submit\" class=\"button--standard feedback__button\">Submit</button>\n      </fieldset>\n    </form>\n  </div>\n</div>\n";
},"useData":true});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global require, module, document */

var $ = __webpack_require__(0);

/**
  * Skip nav link
  * @constructor
  * @param {string} anchor - CSS selector for the anchor element that will function as the skip nav
  * @param {string} targetBody - CSS selector for the main content area to look for a focusable element in
  */

function Skipnav(anchor, targetBody) {
  this.anchor = anchor;
  this.$targetBody = $(targetBody);
  this.$target = $(this.findTarget());
  $(document.body).on('click keyup', this.anchor, this.focusOnTarget.bind(this));
}

Skipnav.prototype.findTarget = function() {
  return this.$targetBody.find(':first-child')
    .not('div, header, section, article, aside')
    .filter(':visible')[0];
};

Skipnav.prototype.focusOnTarget = function(e) {
  e.preventDefault();
  
  if (e.keyCode === 13 || e.type === 'click') {
    this.$target.attr('tabindex','0');
    this.$target.focus();
  }
};

module.exports = {Skipnav: Skipnav};


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
var helpers = __webpack_require__(6);

window.$ = window.jQuery = $;

__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"accessible-mega-menu\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

/** SiteNav module
 * On mobile: Controls the visibility of the the hamburger menu and sublists
 * On desktop: Controls the visibility of dropdown sublists on hover and focus
 * @constructor
 * @param {object} selector - CSS selector for the nav component
 * @param {object} opts - Options, including base URLs
 */

function SiteNav(selector) {
  this.$body = $('body');
  this.$element = $(selector);
  this.$menu = this.$element.find('#site-menu');
  this.$toggle = this.$element.find('.js-nav-toggle');

  this.assignAria();

  this.initMenu();

  // Open and close the menu on mobile
  this.$toggle.on('click', this.toggleMenu.bind(this));
}

SiteNav.prototype.initMenu = function() {
  this.initMegaMenu();
};

SiteNav.prototype.initMegaMenu = function() {
  this.$element.find('[data-submenu]').each(function() {
    // Remove hrefs and default click behavior for links that have submenus
    $(this).find('.site-nav__link').attr('href', '#0').on('click', function(e) {
      e.preventDefault();
    });
  });

  this.$menu.accessibleMegaMenu({
    uuidPrefix: 'mega-menu',
    menuClass: 'site-nav__panel--main',
    topNavItemClass: 'site-nav__item',
    panelClass: 'mega-container',
    panelGroupClass: 'mega__group',
    hoverClass: 'is-hover',
    focusClass: 'is-focus',
    openClass: 'is-open',
    openDelay: 500,
    openOnClick: true,
    selectors: {
      topNavItems: '[data-submenu]'
    }
  });
};

SiteNav.prototype.assignAria = function() {
  this.$menu.attr('aria-label', 'Site-wide navigation');
  if (helpers.getWindowWidth() < helpers.BREAKPOINTS.LARGE) {
    this.$toggle.attr('aria-haspopup', true);
    this.$menu.attr('aria-hidden', true);
  }
};

SiteNav.prototype.toggleMenu = function() {
  var method = this.isOpen ? this.hideMenu : this.showMenu;
  method.apply(this);
};

SiteNav.prototype.showMenu = function() {
  this.$body.css({
    'overflow': 'hidden'
  });
  this.$element.addClass('is-open');
  this.$toggle.addClass('active');
  this.$menu.attr('aria-hidden', false);
  this.isOpen = true;
};

SiteNav.prototype.hideMenu = function() {
  this.$body.css({
    'overflow': 'auto'
  });
  this.$element.removeClass('is-open');
  this.$toggle.removeClass('active');
  this.$menu.attr('aria-hidden', true);
  this.isOpen = false;
  if (this.isMobile) {
    this.$element.find('[aria-hidden=false]').attr('aria-hidden', true);
  }
};

module.exports = {
  SiteNav: SiteNav
};


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
var scrollMonitor = __webpack_require__(252);
var _ = __webpack_require__(2);

/**
 * Table of Contents widget
 *
 * 1. Takes a list of links and finds all sections with IDs matching their hrefs
 * 2. Adds scrollwatchers to highlight the menu item when the section reaches top of viewport
 * 3. Animates the document to scroll to the section when clicking the link
 *
 * @constructor
 * @param {string} selector - Selector for the navigation menu for the TOC
 */

function TOC(selector) {
  this.$menu = $(selector);
  this.sections = this.getSections();
  this.offset = -1 * window.innerHeight;
  this.watchers = this.addWatchers();
  this.$menu.on('click', 'a', this.scrollTo.bind(this));
  $(window).on('resize', this.updateWatchers.bind(this));
}

TOC.prototype.getSections = function() {
  return this.$menu.find('a').map(function(idx, elm) {
    return $(elm).attr('href');
  });
};

TOC.prototype.addWatchers = function() {
  var self = this;

  return this.sections.map(function(idx, section) {
    var elm = document.querySelector(section);
    var watcher = scrollMonitor.create(elm, {top: self.offset});
    watcher.$menuItem = self.$menu.find('a[href="' + section + '"]');
    watcher.enterViewport(function() {
      self.highlightActiveItem(this);
    });
    return watcher;
  });
};

TOC.prototype.highlightActiveItem = function(watcher) {
  var $currentHighlight = this.$menu.find('a.is-active');
  if (watcher.isInViewport) {
    $currentHighlight.removeClass('is-active');
    watcher.$menuItem.addClass('is-active');
  }
};

TOC.prototype.scrollTo = function(e) {
  e.preventDefault();
  var $link = $(e.target);
  var section = $link.attr('href');
  var sectionTop = $(section).offset().top + 10;
  $('body, html').animate({
    scrollTop: sectionTop
  });
};

TOC.prototype.updateWatchers = function() {
  var newOffset = -1 * window.innerHeight;
  _.each(this.watchers, function(watcher) {
    watcher.offsets.top = newOffset;
    watcher.recalculateLocation();
  });
};

module.exports = { TOC: TOC };


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define("scrollMonitor",[],e):"object"==typeof exports?exports.scrollMonitor=e():t.scrollMonitor=e()}(this,function(){return function(t){function e(o){if(i[o])return i[o].exports;var s=i[o]={exports:{},id:o,loaded:!1};return t[o].call(s.exports,s,s.exports,e),s.loaded=!0,s.exports}var i={};return e.m=t,e.c=i,e.p="",e(0)}([function(t,e,i){"use strict";var o=i(1),s=o.isInBrowser,n=i(2),r=new n(s?document.body:null);r.setStateFromDOM(null),r.listenToDOM(),s&&(window.scrollMonitor=r),t.exports=r},function(t,e){"use strict";e.VISIBILITYCHANGE="visibilityChange",e.ENTERVIEWPORT="enterViewport",e.FULLYENTERVIEWPORT="fullyEnterViewport",e.EXITVIEWPORT="exitViewport",e.PARTIALLYEXITVIEWPORT="partiallyExitViewport",e.LOCATIONCHANGE="locationChange",e.STATECHANGE="stateChange",e.eventTypes=[e.VISIBILITYCHANGE,e.ENTERVIEWPORT,e.FULLYENTERVIEWPORT,e.EXITVIEWPORT,e.PARTIALLYEXITVIEWPORT,e.LOCATIONCHANGE,e.STATECHANGE],e.isOnServer="undefined"==typeof window,e.isInBrowser=!e.isOnServer,e.defaultOffsets={top:0,bottom:0}},function(t,e,i){"use strict";function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t){return c?0:t===document.body?window.innerHeight||document.documentElement.clientHeight:t.clientHeight}function n(t){return c?0:t===document.body?Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.documentElement.clientHeight):t.scrollHeight}function r(t){return c?0:t===document.body?window.pageYOffset||document.documentElement&&document.documentElement.scrollTop||document.body.scrollTop:t.scrollTop}var h=i(1),c=h.isOnServer,a=h.isInBrowser,l=h.eventTypes,p=i(3),w=function(){function t(e,i){function h(){if(a.viewportTop=r(e),a.viewportBottom=a.viewportTop+a.viewportHeight,a.documentHeight=n(e),a.documentHeight!==p){for(w=a.watchers.length;w--;)a.watchers[w].recalculateLocation();p=a.documentHeight}}function c(){for(u=a.watchers.length;u--;)a.watchers[u].update();for(u=a.watchers.length;u--;)a.watchers[u].triggerCallbacks()}o(this,t);var a=this;this.item=e,this.watchers=[],this.viewportTop=null,this.viewportBottom=null,this.documentHeight=n(e),this.viewportHeight=s(e),this.DOMListener=function(){t.prototype.DOMListener.apply(a,arguments)},this.eventTypes=l,i&&(this.containerWatcher=i.create(e));var p,w,u;this.update=function(){h(),c()},this.recalculateLocations=function(){this.documentHeight=0,this.update()}}return t.prototype.listenToDOM=function(){a&&(window.addEventListener?(this.item===document.body?window.addEventListener("scroll",this.DOMListener):this.item.addEventListener("scroll",this.DOMListener),window.addEventListener("resize",this.DOMListener)):(this.item===document.body?window.attachEvent("onscroll",this.DOMListener):this.item.attachEvent("onscroll",this.DOMListener),window.attachEvent("onresize",this.DOMListener)),this.destroy=function(){window.addEventListener?(this.item===document.body?(window.removeEventListener("scroll",this.DOMListener),this.containerWatcher.destroy()):this.item.removeEventListener("scroll",this.DOMListener),window.removeEventListener("resize",this.DOMListener)):(this.item===document.body?(window.detachEvent("onscroll",this.DOMListener),this.containerWatcher.destroy()):this.item.detachEvent("onscroll",this.DOMListener),window.detachEvent("onresize",this.DOMListener))})},t.prototype.destroy=function(){},t.prototype.DOMListener=function(t){this.setStateFromDOM(t)},t.prototype.setStateFromDOM=function(t){var e=r(this.item),i=s(this.item),o=n(this.item);this.setState(e,i,o,t)},t.prototype.setState=function(t,e,i,o){var s=e!==this.viewportHeight||i!==this.contentHeight;if(this.latestEvent=o,this.viewportTop=t,this.viewportHeight=e,this.viewportBottom=t+e,this.contentHeight=i,s)for(var n=this.watchers.length;n--;)this.watchers[n].recalculateLocation();this.updateAndTriggerWatchers(o)},t.prototype.updateAndTriggerWatchers=function(t){for(var e=this.watchers.length;e--;)this.watchers[e].update();for(e=this.watchers.length;e--;)this.watchers[e].triggerCallbacks(t)},t.prototype.createCustomContainer=function(){return new t},t.prototype.createContainer=function(e){"string"==typeof e?e=document.querySelector(e):e&&e.length>0&&(e=e[0]);var i=new t(e,this);return i.setStateFromDOM(),i.listenToDOM(),i},t.prototype.create=function(t,e){"string"==typeof t?t=document.querySelector(t):t&&t.length>0&&(t=t[0]);var i=new p(this,t,e);return this.watchers.push(i),i},t.prototype.beget=function(t,e){return this.create(t,e)},t}();t.exports=w},function(t,e,i){"use strict";function o(t,e,i){function o(t,e){if(0!==t.length)for(E=t.length;E--;)T=t[E],T.callback.call(s,e,s),T.isOne&&t.splice(E,1)}var s=this;this.watchItem=e,this.container=t,i?i===+i?this.offsets={top:i,bottom:i}:this.offsets={top:i.top||u.top,bottom:i.bottom||u.bottom}:this.offsets=u,this.callbacks={};for(var d=0,f=w.length;d<f;d++)s.callbacks[w[d]]=[];this.locked=!1;var m,v,b,I,E,T;this.triggerCallbacks=function(t){switch(this.isInViewport&&!m&&o(this.callbacks[r],t),this.isFullyInViewport&&!v&&o(this.callbacks[h],t),this.isAboveViewport!==b&&this.isBelowViewport!==I&&(o(this.callbacks[n],t),v||this.isFullyInViewport||(o(this.callbacks[h],t),o(this.callbacks[a],t)),m||this.isInViewport||(o(this.callbacks[r],t),o(this.callbacks[c],t))),!this.isFullyInViewport&&v&&o(this.callbacks[a],t),!this.isInViewport&&m&&o(this.callbacks[c],t),this.isInViewport!==m&&o(this.callbacks[n],t),!0){case m!==this.isInViewport:case v!==this.isFullyInViewport:case b!==this.isAboveViewport:case I!==this.isBelowViewport:o(this.callbacks[p],t)}m=this.isInViewport,v=this.isFullyInViewport,b=this.isAboveViewport,I=this.isBelowViewport},this.recalculateLocation=function(){if(!this.locked){var t=this.top,e=this.bottom;if(this.watchItem.nodeName){var i=this.watchItem.style.display;"none"===i&&(this.watchItem.style.display="");for(var s=0,n=this.container;n.containerWatcher;)s+=n.containerWatcher.top-n.containerWatcher.container.viewportTop,n=n.containerWatcher.container;var r=this.watchItem.getBoundingClientRect();this.top=r.top+this.container.viewportTop-s,this.bottom=r.bottom+this.container.viewportTop-s,"none"===i&&(this.watchItem.style.display=i)}else this.watchItem===+this.watchItem?this.watchItem>0?this.top=this.bottom=this.watchItem:this.top=this.bottom=this.container.documentHeight-this.watchItem:(this.top=this.watchItem.top,this.bottom=this.watchItem.bottom);this.top-=this.offsets.top,this.bottom+=this.offsets.bottom,this.height=this.bottom-this.top,void 0===t&&void 0===e||this.top===t&&this.bottom===e||o(this.callbacks[l],null)}},this.recalculateLocation(),this.update(),m=this.isInViewport,v=this.isFullyInViewport,b=this.isAboveViewport,I=this.isBelowViewport}var s=i(1),n=s.VISIBILITYCHANGE,r=s.ENTERVIEWPORT,h=s.FULLYENTERVIEWPORT,c=s.EXITVIEWPORT,a=s.PARTIALLYEXITVIEWPORT,l=s.LOCATIONCHANGE,p=s.STATECHANGE,w=s.eventTypes,u=s.defaultOffsets;o.prototype={on:function(t,e,i){switch(!0){case t===n&&!this.isInViewport&&this.isAboveViewport:case t===r&&this.isInViewport:case t===h&&this.isFullyInViewport:case t===c&&this.isAboveViewport&&!this.isInViewport:case t===a&&this.isInViewport&&this.isAboveViewport:if(e.call(this,this.container.latestEvent,this),i)return}if(!this.callbacks[t])throw new Error("Tried to add a scroll monitor listener of type "+t+". Your options are: "+w.join(", "));this.callbacks[t].push({callback:e,isOne:i||!1})},off:function(t,e){if(!this.callbacks[t])throw new Error("Tried to remove a scroll monitor listener of type "+t+". Your options are: "+w.join(", "));for(var i,o=0;i=this.callbacks[t][o];o++)if(i.callback===e){this.callbacks[t].splice(o,1);break}},one:function(t,e){this.on(t,e,!0)},recalculateSize:function(){this.height=this.watchItem.offsetHeight+this.offsets.top+this.offsets.bottom,this.bottom=this.top+this.height},update:function(){this.isAboveViewport=this.top<this.container.viewportTop,this.isBelowViewport=this.bottom>this.container.viewportBottom,this.isInViewport=this.top<this.container.viewportBottom&&this.bottom>this.container.viewportTop,this.isFullyInViewport=this.top>=this.container.viewportTop&&this.bottom<=this.container.viewportBottom||this.isAboveViewport&&this.isBelowViewport},destroy:function(){var t=this.container.watchers.indexOf(this),e=this;this.container.watchers.splice(t,1);for(var i=0,o=w.length;i<o;i++)e.callbacks[w[i]].length=0},lock:function(){this.locked=!0},unlock:function(){this.locked=!1}};for(var d=function(t){return function(e,i){this.on.call(this,t,e,i)}},f=0,m=w.length;f<m;f++){var v=w[f];o.prototype[v]=d(v)}t.exports=o}])});
//# sourceMappingURL=scrollMonitor.js.map

/***/ }),
/* 253 */,
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Sticky
 * @module
 */


var extend = __webpack_require__(255);
var on = __webpack_require__(256);
var off = __webpack_require__(258);
var emit = __webpack_require__(259);
var getOffsets = __webpack_require__(261);


module.exports = Sticky;


/**
 * @constructor
 */
function Sticky(el, options){
	if (el.getAttribute('data-sticky-id') === undefined) {
		return console.log('Sticky already exist');
	}

	this.el = el;
	this.parent = this.el.parentNode;

	//recognize attributes
	var dataset = el.dataset;
	if (!dataset){
		dataset = {};
		if (el.getAttribute('data-within')) dataset['within'] = el.getAttribute('data-within');
		if (el.getAttribute('data-offset')) dataset['offset'] = el.getAttribute('data-offset');
		if (el.getAttribute('data-stack')) dataset['stack'] = el.getAttribute('data-stack');
		if (el.getAttribute('data-sticky-class')) dataset['stickyClass'] = el.getAttribute('data-sticky-class');
	}
	this.options = extend({}, this.options, dataset, options);

	//query selector, if passed one
	if ( typeof this.options['within'] === 'string' && this.options['within'].trim() ){
		this.within = document.body.querySelector(this.options['within']);
	} else {
		this.within = this.options['within'];
	}

	//keep list
	this.el.setAttribute('data-sticky-id', Sticky.list.length);
	this.id = Sticky.list.length;
	Sticky.list.push(this);

	//state
	this.isFixed = false;
	this.isBottom = false;
	this.isTop = true;
	this.updateClasses();

	//boundaries to strict within
	this.restrictBox = {
		top: 0,
		bottom: 9999
	};

	//self position & size
	this.height = 0;
	this.isDisabled = false;

	//parent position & size
	this.parentBox = {
		top: 0,
		height: 0
	}

	//mind gap from bottom & top in addition to restrictBox (for stacks)
	this.options.offset = parseFloat(this.options['offset']) || 0;
	this.offset = {
		top: 0,
		bottom: 0
	};

	//additional gap if item being scrolled
	this.scrollOffset = 0;

	//Detect whether stacking is needed
	var prevEl = this.el;
	this.stackId = [];
	this.stack = [];
	if (this.options['stack']) {
		var stack = this.options['stack'].split(',');
		for (var i = stack.length; i--;){
			stack[i] = stack[i].trim();
			if (!Sticky.stack[stack[i]]) Sticky.stack[stack[i]] = [];
			this.stackId[i] = Sticky.stack[stack[i]].length;
			this.stack.push(stack[i]);
			Sticky.stack[stack[i]].push(this)
		}
	} else {
		this.stackId[0] = Sticky.noStack.length;
		Sticky.noStack.push(this);
	}


	//stub is a spacer filling space when element is stuck
	this.stub = this.el.cloneNode();
	this.stub.classList.add(this.options['stubClass']);
	this.stub.style.visibility = 'hidden';
	this.stub.style.display = 'none';
	this.stub.removeAttribute('hidden');

	//save initial inline style
	this.initialStyle = this.el.style.cssText;
	this.initialDisplay = getComputedStyle(this.el)['display'];

	//ensure parent's container relative coordinates
	var pStyle = getComputedStyle(this.parent);
	if (pStyle.position == 'static') this.parent.style.position = 'relative';

	//bind methods
	this.check = this.check.bind(this);
	this.recalc = this.recalc.bind(this);
	this.disable = this.disable.bind(this);
	this.enable = this.enable.bind(this);
	this.bindEvents = this.bindEvents.bind(this);
	this.adjustSizeAndPosition = this.adjustSizeAndPosition.bind(this);
	this.park = this.park.bind(this);
	this.stick = this.stick.bind(this);
	this.parkStack = this.parkStack.bind(this);
	this.stickStack = this.stickStack.bind(this);
	this.captureScrollOffset = this.captureScrollOffset.bind(this);
	this.observeStackScroll = this.observeStackScroll.bind(this);
	this.stopObservingStackScroll = this.stopObservingStackScroll.bind(this);

	if (this.initialDisplay === 'none') {
		this.initialDisplay = 'block';
		this.disable();
	}
	else this.enable();
}

//list of instances
Sticky.list = [];
//mutually exclusive items
Sticky.noStack = [];
//stacks of items
Sticky.stack = {};
//heights of stacks
Sticky.stackHeights = {};


/** Update all sticky instances */
Sticky.recalc = function () {
	Sticky.list.forEach(function (instance) {
		instance.recalc();
	});
};


/** API events */
on(document, 'sticky:recalc', Sticky.recalc);


var proto = Sticky.prototype;


proto.options = {
	'offset': 0,
	'within': null, //element or bounding box
	'stubClass': 'sticky-stub',
	'stickyClass': 'is-stuck',
	'bottomClass': 'is-bottom',
	'topClass': 'is-top',
	'stack': null,
	'collapse': true,
	'recalcInterval': 20
};


/** when element removed or made hidden. */
proto.disable = function(){
	if (this.stub.parentNode) this.parent.removeChild(this.stub);
	this.unbindEvents();
	this.isDisabled = true;
	Sticky.recalc();
};


/** enables previously disabled element */
proto.enable = function(){
	if (!this.stub.parentNode) this.parent.insertBefore(this.stub, this.el);
	this.isDisabled = false;
	this.bindEvents();
	Sticky.recalc();
};


proto.bindEvents = function(){
	on(document, 'scroll', this.check);
	on(window, 'resize', this.recalc);
	on(this.el, 'mouseover', this.observeStackScroll);
	on(this.el, 'mouseout', this.stopObservingStackScroll);
};


proto.unbindEvents = function(){
	off(document, 'scroll', this.check);
	off(window, 'resize', this.recalc);
	off(this.el, 'mouseover', this.observeStackScroll);
	off(this.el, 'mouseout', this.stopObservingStackScroll);
};


/** changing state necessity checker */
proto.check = function(){
	var vpTop = window.pageYOffset || document.documentElement.scrollTop;
	//console.log('check:' + this.el.dataset['stickyId'], 'isFixed:' + this.isFixed, this.restrictBox)
	if (this.isFixed){
		if (!this.isTop && vpTop + this.offset.top + this.options.offset + this.height + this.mt + this.mb + this.scrollOffset >= this.restrictBox.bottom - this.offset.bottom){
			//check bottom parking needed
			this.parkBottom();
		}
		if (!this.isBottom && vpTop + this.offset.top + this.options.offset + this.mt + this.scrollOffset <= this.restrictBox.top){
			//check top parking needed
			this.parkTop();
		}
	} else {
		if (this.isTop || this.isBottom){
			if (vpTop + this.offset.top + this.options.offset + this.mt > this.restrictBox.top){
				//fringe violation from top
				if (vpTop + this.offset.top + this.options.offset + this.height + this.mt + this.mb < this.restrictBox.bottom - this.offset.bottom){
					//fringe violation from top or bottom to the sticking zone
					this.stick();
				} else if (!this.isBottom) {
					//fringe violation from top lower than bottom
					this.stick();
					this.parkBottom();
				}
			} else if(this.isBottom){
				//fringe violation from bottom to higher than top
				this.stick();
				this.parkTop();
			}
		}
	}
};


/**
 * sticking inner routines
 * when park top needed
 */
proto.parkTop = function(){
	//this.el = this.parent.removeChild(this.el);
	this.el.style.cssText = this.initialStyle;
	//this.stub = this.parent.replaceChild(this.el, this.stub);
	this.stub.style.display = 'none';

	this.scrollOffset = 0;

	this.isFixed = false;
	this.isTop = true;
	this.isBottom = false;
	this.updateClasses();

	this.isStackParked = true;

	// console.log('parkTop', this.id)
};


/** when stop needed somewhere in between top and bottom */
proto.park = function(){
	// console.log('parkMiddle', this.id)

	this.isFixed = false;
	this.isTop = false;
	this.isBottom = false;
	this.updateClasses();

	this.isStackParked = true;

	var offset = (window.pageYOffset || document.documentElement.scrollTop) + this.offset.top - this.parentBox.top + this.scrollOffset;
	this.makeParkedStyle(offset);
};

/**
 * to make fixed
 * enhanced replace: faked visual stub is fastly replaced with natural one
 */
proto.stick = function(){
	//this.el = this.parent.replaceChild(this.stub, this.el);
	this.stub.style.display = this.initialDisplay;
	this.makeStickedStyle();
	//this.parent.insertBefore(this.el, this.stub);

	this.isFixed = true;
	this.isTop = false;
	this.isBottom = false;
	this.updateClasses();

	this.isStackParked = false;

	// console.log('stick', this.id)
};


/** when bottom land needed */
proto.parkBottom = function(){
	this.makeParkedBottomStyle();

	this.scrollOffset = 0;

	this.isFixed = false;
	this.isBottom = true;
	this.isTop = false;
	this.updateClasses();

	this.isStackParked = true;

	// console.log('parkBottom', this.id)
};


/**
 * park all items within stack passed/all stacks of this
 * used when item was scrolled on
 */
proto.parkStack = function(){
	var stack = Sticky.stack[this.stack[0]];
	var first = stack[0], last = stack[stack.length - 1];

	for (var i = 0; i < stack.length; i++){
		var item = stack[i]
		item.park();
	}
};


/** unpark all items of stack passed */
proto.stickStack = function(){
	var stack = Sticky.stack[this.stack[0]]
	var first = stack[0], last = stack[stack.length - 1];

	for (var i = 0; i < stack.length; i++){
		var item = stack[i]
		item.stick();
	}
};

/**
 * begin observing scroll to park stack
 */
proto.observeStackScroll = function(){
	var stack = Sticky.stack[this.stack[0]]
	if (!stack) return;

	var first = stack[0], last = stack[stack.length - 1];

	//if stack is parked top or parked bottom - ignore
	if (first.isTop || last.isTop) return;

	//if stack isnt higher than window height - ignore
	if (Sticky.stackHeights[this.stack[0]] <= window.innerHeight && this.scrollOffset >= 0) return;

	//capture stacks scroll
	this.scrollStartOffset = (window.pageYOffset || document.documentElement.scrollTop) + this.scrollOffset;

	on(document, 'scroll', this.captureScrollOffset);

	return this;
};

/** stop observing scroll */
proto.stopObservingStackScroll = function(){
	var stack = Sticky.stack[this.stack[0]];
	if (!stack) return;

	var last = stack[stack.length-1], first = stack[0];

	off(document, 'scroll', this.captureScrollOffset);

	if (first.isTop || first.isBottom || last.isTop || last.isBottom) {
		return;
	}
	if (this.isStackParked) this.stickStack();
};

/** when item was scrolled on - capture how much it is scrolled */
proto.captureScrollOffset = function(e){

	var scrollOffset = this.scrollStartOffset - (window.pageYOffset || document.documentElement.scrollTop);
	var stack = Sticky.stack[this.stack[0]];
	var last = stack[stack.length-1], first = stack[0];

	//ignore outside sticking
	if (first.isTop || first.isBottom || last.isTop || last.isBottom) {
		return;
	}

	var stickNeeded = false, parkNeeded = false;

	//if bottom is higher or equal than viewports bottom - stick within viewport
	if ( scrollOffset < window.innerHeight - (Sticky.stackHeights[this.stack[0]]) ){
		scrollOffset = window.innerHeight - (Sticky.stackHeights[this.stack[0]]);
		this.scrollStartOffset = (window.pageYOffset || document.documentElement.scrollTop) + scrollOffset;
		stickNeeded = true;
	}

	//if top is lower or equal to the viewports top - stick within viewport
	else if ( scrollOffset > 0){
		scrollOffset = 0;
		this.scrollStartOffset = (window.pageYOffset || document.documentElement.scrollTop);
		stickNeeded = true;
	}

	//if stack items is somewhere in between
	else if (!this.isStackParked ){
		parkNeeded = true;
	}

	for (var i = 0; i < stack.length; i++){
		var item = stack[i]
		item.scrollOffset = scrollOffset
	}

	if (stickNeeded && this.isStackParked) return this.stickStack();
	else if (parkNeeded && !this.isStackParked) return this.parkStack();
};

/** set up style of element as if it is parked somewhere / at the bottom */
proto.makeParkedStyle = function(top){
	this.el.style.cssText = this.initialStyle;
	this.el.style.position = 'absolute';
	this.el.style.top = top + 'px';
	mimicStyle(this.el, this.stub);
	this.el.style.left = this.stub.offsetLeft + 'px';
};

proto.makeParkedBottomStyle = function(){
	this.makeParkedStyle(this.restrictBox.bottom - this.offset.bottom - this.parentBox.top - this.height - this.mt - this.mb);
};

proto.makeStickedStyle = function(){
	this.el.style.cssText = this.initialStyle;
	this.el.style.position = 'fixed';
	this.el.style.top = this.offset.top + this.options.offset + this.scrollOffset + 'px';
	mimicStyle(this.el, this.stub);
};

//makes element classes reflecting it's state (this.isTop, this.isBottom, this.isFixed)
proto.updateClasses = function(){
	if (this.isTop){
		this.el.classList.add(this.options['topClass']);
	} else {
		this.el.classList.remove(this.options['topClass']);
	}

	if (this.isFixed){
		this.el.classList.add(this.options['stickyClass']);
	} else {
		this.el.classList.remove(this.options['stickyClass']);
	}

	if (this.isBottom){
		this.el.classList.add(this.options['bottomClass']);
	} else {
		this.el.classList.remove(this.options['bottomClass']);
	}
};


proto.recalc = function(){
	//console.group('recalc:' + this.el.dataset['stickyId'])
	//element to mimic visual properties from
	var measureEl = (this.isTop ? this.el : this.stub);

	//update stub content
	this.stub.innerHTML = this.el.innerHTML;
	cleanNode(this.stub);

	//update parent container size & offsets
	this.parentBox = getOffsets(this.parent);

	//update self size & position
	this.height = this.el.offsetHeight;
	var mStyle = getComputedStyle(measureEl);
	this.ml = ~~mStyle.marginLeft.slice(0,-2);
	this.mr = ~~mStyle.marginRight.slice(0,-2);
	this.mt = ~~mStyle.marginTop.slice(0,-2);
	this.mb = ~~mStyle.marginBottom.slice(0,-2);

	this.scrollOffset = 0;

	//update restrictions
	this.restrictBox = this.getRestrictBox(this.within, measureEl);

	//make restriction up to next sibling within one container
	var prevSticky;
	this.offset.bottom = 0;
	this.offset.top = 0;
	if (this.stack.length){
		for (var i = this.stack.length; i--;){
			if (prevSticky = Sticky.stack[this.stack[i]][this.stackId[i] - 1]){
				//make offsets for stacked mode
				var prevMeasurer = (prevSticky.isTop ? prevSticky.el : prevSticky.stub);
				this.offset.top = prevSticky.offset.top + prevSticky.options.offset;
				if (!(this.options['collapse'] && !isOverlap(measureEl, prevMeasurer))) {
				 	this.offset.top += prevSticky.height + Math.max(prevSticky.mt, prevSticky.mb)//collapsed margin
				 	var nextSticky = Sticky.stack[this.stack[i]][this.stackId[i]];
					//multistacking-way of correcting bottom offsets
					for( var j = this.stackId[i] - 1; (prevSticky = Sticky.stack[this.stack[i]][j]); j--){
						prevSticky.offset.bottom = Math.max(prevSticky.offset.bottom, nextSticky.offset.bottom + nextSticky.height + nextSticky.mt + nextSticky.mb);
						nextSticky = prevSticky;
					}
				}
			}

			//track stack heights;
			Sticky.stackHeights[this.stack[i]] = this.offset.top + this.height + this.mt + this.mb;
		}
	} else if (prevSticky = Sticky.noStack[this.stackId[0] - 1]){
		prevSticky.restrictBox.bottom = this.restrictBox.top - this.mt;
	}

	clearTimeout(this._updTimeout);
	this._updTimeout = setTimeout(this.adjustSizeAndPosition, 0);
};


/**
 * return box with sizes based on any restrictwithin object passed
 */
proto.getRestrictBox = function(within, measureEl){
	var restrictBox = {
		top: 0,
		bottom: 0
	};
	if (within instanceof Element){
		var offsetRect = getOffsets(within)
		restrictBox.top = Math.max(offsetRect.top, getOffsets(measureEl).top);
		//console.log(getOffsets(this.stub))
		restrictBox.bottom = within.offsetHeight + offsetRect.top;
	} else if (within instanceof Object) {
		if (within.top instanceof Element) {
			var offsetRect = getOffsets(within.top)
			restrictBox.top = Math.max(offsetRect.top, getOffsets(measureEl).top);
		} else {
			restrictBox.top = within.top;
		}
		if (within.bottom instanceof Element) {
			var offsetRect = getOffsets(within.bottom)
			restrictBox.bottom = within.bottom.offsetHeight + offsetRect.top;
			//console.log(offsetRect)
		} else {
			restrictBox.bottom = within.bottom;
		}
	} else {
		//case of parent container
		restrictBox.top = getOffsets(measureEl).top;
		restrictBox.bottom = this.parentBox.height + this.parentBox.top;
	}
	//console.log('Restrictbox', restrictBox)
	return restrictBox;
};


proto.adjustSizeAndPosition = function(){
	if (this.isTop){
		this.el.style.cssText = this.initialStyle;
	} else if (this.isBottom){
		this.makeParkedBottomStyle();
	} else {
		this.makeStickedStyle();
	}

	this.check();
};




/** removes iframe, objects etc shit */
var badTags = ['object', 'iframe', 'embed', 'img'];
function cleanNode(node){
	node.removeAttribute('id');
	var idTags = node.querySelectorAll('[id]');
	for (var k = 0; k < idTags.length; k++){
		idTags[k].removeAttribute('id'); //avoid any uniqueness
		idTags[k].removeAttribute('name'); //avoid any uniqueness
	}
	for (var i = 0; i < badTags.length; i++){
		var tags = node.querySelectorAll(badTags[i]);
		for (var j = tags.length; j--; ){
			if (tags[j].tagName === 'SCRIPT') tags[j].parentNode.replaceChild(tags[j])
			tags[j].removeAttribute('src');
			tags[j].removeAttribute('href');
			tags[j].removeAttribute('rel');
			tags[j].removeAttribute('srcdoc');
		}
	}
}


var directions = ['left', 'top', 'right', 'bottom'],
	mimicProperties = ['padding-', 'border-'];


/** copies size-related style of stub */
function mimicStyle(to, from){
	var stubStyle = getComputedStyle(from),
		stubOffset = getOffsets(from),
		pl = 0, pr = 0, ml = 0;
	if (stubStyle['box-sizing'] !== 'border-box'){
		pl = ~~stubStyle.paddingLeft.slice(0,-2)
		pr = ~~stubStyle.paddingRight.slice(0,-2)
	}

	to.style.width = (stubOffset.width - pl - pr) + 'px';
	to.style.left = stubOffset.left + 'px';
	to.style.marginLeft = 0;
	for (var i = 0; i < mimicProperties.length; i++){
		for (var j = 0; j < directions.length; j++){
			var prop = mimicProperties[i] + directions[j];
			to.style[prop] = stubStyle[prop];
		}
	}
}


/** checks overlapping widths */
function isOverlap(left, right){
	var lLeft = left.offsetLeft,
		lRight = left.offsetLeft + left.offsetWidth,
		rLeft = right.offsetLeft,
		rRight = right.offsetWidth + right.offsetLeft;
	if (lRight < rLeft && lLeft < rLeft
		|| lRight > rRight && lLeft > rRight){
		return false;
	}
	return true;
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module emmy/on
 */


var icicle = __webpack_require__(87);
var listeners = __webpack_require__(88);
var isObject = __webpack_require__(257);

module.exports = on;


/**
 * Bind fn to a target.
 *
 * @param {*} targte A single target to bind evt
 * @param {string} evt An event name
 * @param {Function} fn A callback
 * @param {Function}? condition An optional filtering fn for a callback
 *                              which accepts an event and returns callback
 *
 * @return {object} A target
 */
function on(target, evt, fn){
	if (!target) return target;

	//consider object of events
	if (isObject(evt)) {
		for(var evtName in evt) {
			on(target, evtName, evt[evtName]);
		}
		return target;
	}

	//get target `on` method, if any
	//prefer native-like method name
	//user may occasionally expose `on` to the global, in case of browserify
	//but it is unlikely one would replace native `addEventListener`
	var onMethod =  target['addEventListener'] || target['addListener'] || target['attachEvent'] || target['on'];

	var cb = fn;

	evt = '' + evt;

	//invoke method for each space-separated event from a list
	evt.split(/\s+/).forEach(function(evt){
		var evtParts = evt.split('.');
		evt = evtParts.shift();

		//use target event system, if possible
		if (onMethod) {
			//avoid self-recursions
			//if its frozen - ignore call
			if (icicle.freeze(target, 'on' + evt)){
				onMethod.call(target, evt, cb);
				icicle.unfreeze(target, 'on' + evt);
			}
			else {
				return target;
			}
		}

		//save the callback anyway
		listeners.add(target, evt, cb, evtParts);
	});

	return target;
}


/**
 * Wrap an fn with condition passing
 */
on.wrap = function(target, evt, fn, condition){
	var cb = function() {
		if (condition.apply(target, arguments)) {
			return fn.apply(target, arguments);
		}
	};

	cb.fn = fn;

	return cb;
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module emmy/off
 */
module.exports = off;

var icicle = __webpack_require__(87);
var slice = __webpack_require__(118);
var listeners = __webpack_require__(88);


/**
 * Remove listener[s] from the target
 *
 * @param {[type]} evt [description]
 * @param {Function} fn [description]
 *
 * @return {[type]} [description]
 */
function off(target, evt, fn) {
	if (!target) return target;

	var callbacks, i;

	//unbind all listeners if no fn specified
	if (fn === undefined) {
		var args = slice(arguments, 1);

		//try to use target removeAll method, if any
		var allOff = target['removeAll'] || target['removeAllListeners'];

		//call target removeAll
		if (allOff) {
			allOff.apply(target, args);
		}


		//then forget own callbacks, if any

		//unbind all evts
		if (!evt) {
			callbacks = listeners(target);
			for (evt in callbacks) {
				off(target, evt);
			}
		}
		//unbind all callbacks for an evt
		else {
			evt = '' + evt;

			//invoke method for each space-separated event from a list
			evt.split(/\s+/).forEach(function (evt) {
				var evtParts = evt.split('.');
				evt = evtParts.shift();
				callbacks = listeners(target, evt, evtParts);

				//returned array of callbacks (as event is defined)
				if (evt) {
					var obj = {};
					obj[evt] = callbacks;
					callbacks = obj;
				}

				//for each group of callbacks - unbind all
				for (var evtName in callbacks) {
					slice(callbacks[evtName]).forEach(function (cb) {
						off(target, evtName, cb);
					});
				}
			});
		}

		return target;
	}


	//target events (string notation to advanced_optimizations)
	var offMethod = target['removeEventListener'] || target['removeListener'] || target['detachEvent'] || target['off'];

	//invoke method for each space-separated event from a list
	evt.split(/\s+/).forEach(function (evt) {
		var evtParts = evt.split('.');
		evt = evtParts.shift();

		//use target `off`, if possible
		if (offMethod) {
			//avoid self-recursion from the outside
			if (icicle.freeze(target, 'off' + evt)) {
				offMethod.call(target, evt, fn);
				icicle.unfreeze(target, 'off' + evt);
			}

			//if its frozen - ignore call
			else {
				return target;
			}
		}

		if (fn.closedCall) fn.closedCall = false;

		//forget callback
		listeners.remove(target, evt, fn, evtParts);
	});


	return target;
}


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module emmy/emit
 */
var icicle = __webpack_require__(87);
var slice = __webpack_require__(118);
var listeners = __webpack_require__(88);
var isBrowser = __webpack_require__(260);


/**
 * A simple wrapper to handle stringy/plain events
 */
module.exports = function(target, evt){
	if (!target) return;

	var args = arguments;
	if (typeof evt === 'string') {
		args = slice(arguments, 2);
		evt.split(/\s+/).forEach(function(evt){
			evt = evt.split('.')[0];

			emit.apply(this, [target, evt].concat(args));
		});
	} else {
		return emit.apply(this, args);
	}
};


/** detect env */
var $ = typeof jQuery === 'undefined' ? undefined : jQuery;
var doc = typeof document === 'undefined' ? undefined : document;
var win = typeof window === 'undefined' ? undefined : window;


/**
 * Emit an event, optionally with data or bubbling
 * Accept only single elements/events
 *
 * @param {string} eventName An event name, e. g. 'click'
 * @param {*} data Any data to pass to event.details (DOM) or event.data (elsewhere)
 * @param {bool} bubbles Whether to trigger bubbling event (DOM)
 *
 *
 * @return {target} a target
 */
function emit(target, eventName, data, bubbles){
	var emitMethod, evt = eventName;

	//Create proper event for DOM objects
	if (isBrowser && (target instanceof Node || target === win)) {
		//NOTE: this doesnot bubble on off-DOM elements

		if (isBrowser && eventName instanceof Event) {
			evt = eventName;
		} else {
			//IE9-compliant constructor
			evt = doc.createEvent('CustomEvent');
			evt.initCustomEvent(eventName, bubbles, true, data);

			//a modern constructor would be:
			// var evt = new CustomEvent(eventName, { detail: data, bubbles: bubbles })
		}

		emitMethod = target.dispatchEvent;
	}

	//create event for jQuery object
	else if ($ && target instanceof $) {
		//TODO: decide how to pass data
		evt = $.Event( eventName, data );
		evt.detail = data;

		//FIXME: reference case where triggerHandler needed (something with multiple calls)
		emitMethod = bubbles ? targte.trigger : target.triggerHandler;
	}

	//detect target events
	else {
		//emit - default
		//trigger - jquery
		//dispatchEvent - DOM
		//raise - node-state
		//fire - ???
		emitMethod = target['dispatchEvent'] || target['emit'] || target['trigger'] || target['fire'] || target['raise'];
	}


	var args = slice(arguments, 2);


	//use locks to avoid self-recursion on objects wrapping this method
	if (emitMethod) {
		if (icicle.freeze(target, 'emit' + eventName)) {
			//use target event system, if possible
			emitMethod.apply(target, [evt].concat(args));
			icicle.unfreeze(target, 'emit' + eventName);

			return target;
		}

		//if event was frozen - probably it is emitter instance
		//so perform normal callback
	}


	//fall back to default event system
	var evtCallbacks = listeners(target, evt);

	//copy callbacks to fire because list can be changed by some callback (like `off`)
	var fireList = slice(evtCallbacks);
	for (var i = 0; i < fireList.length; i++ ) {
		fireList[i] && fireList[i].apply(target, args);
	}

	return target;
}


/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Calculate absolute offsets of an element, relative to the document.
 *
 * @module mucss/offsets
 *
 */
var win = window;
var doc = document;
var Rect = __webpack_require__(262);
var hasScroll = __webpack_require__(263);
var scrollbar = __webpack_require__(264);
var isFixedEl = __webpack_require__(265);

/**
 * Return absolute offsets of any target passed
 *
 * @param    {Element|window}   el   A target. Pass window to calculate viewport offsets
 * @return   {Object}   Offsets object with trbl.
 */
module.exports = offsets;

function offsets (el) {
	if (!el) throw Error('Bad argument');

	//calc client rect
	var cRect, result;

	//return vp offsets
	if (el === win) {
		result = new Rect(
			win.pageXOffset,
			win.pageYOffset
		);

		result.width = win.innerWidth - (hasScroll.y() ? scrollbar : 0),
		result.height = win.innerHeight - (hasScroll.x() ? scrollbar : 0)
		result.right = result.left + result.width;
		result.bottom = result.top + result.height;

		return result;
	}

	//return absolute offsets if document requested
	else if (el === doc) {
		var res = offsets(doc.documentElement);
		res.bottom = Math.max(window.innerHeight, res.bottom);
		res.right = Math.max(window.innerWidth, res.right);
		if (hasScroll.y(doc.documentElement)) res.right -= scrollbar;
		if (hasScroll.x(doc.documentElement)) res.bottom -= scrollbar;
		return res;
	}

	//FIXME: why not every element has getBoundingClientRect method?
	try {
		cRect = el.getBoundingClientRect();
	} catch (e) {
		cRect = new Rect(
			el.clientLeft,
			el.clientTop
		);
	}

	//whether element is or is in fixed
	var isFixed = isFixedEl(el);
	var xOffset = isFixed ? 0 : win.pageXOffset;
	var yOffset = isFixed ? 0 : win.pageYOffset;

	result = new Rect(
		cRect.left + xOffset,
		cRect.top + yOffset,
		cRect.left + xOffset + el.offsetWidth,
		cRect.top + yOffset + el.offsetHeight,
		el.offsetWidth,
		el.offsetHeight
	);

	return result;
};

/***/ }),
/* 262 */
/***/ (function(module, exports) {

/**
 * Simple rect constructor.
 * It is just faster and smaller than constructing an object.
 *
 * @module mucss/Rect
 *
 * @param {number} l left
 * @param {number} t top
 * @param {number} r right
 * @param {number} b bottom
 * @param {number}? w width
 * @param {number}? h height
 *
 * @return {Rect} A rectangle object
 */
module.exports = function Rect (l,t,r,b,w,h) {
	this.top=t||0;
	this.bottom=b||0;
	this.left=l||0;
	this.right=r||0;
	if (w!==undefined) this.width=w||this.right-this.left;
	if (h!==undefined) this.height=h||this.bottom-this.top;
};

/***/ }),
/* 263 */
/***/ (function(module, exports) {

/**
 * Window scrollbar detector.
 *
 * @module mucss/has-scroll
 */
exports.x = function () {
	return window.innerHeight > document.documentElement.clientHeight;
};
exports.y = function () {
	return window.innerWidth > document.documentElement.clientWidth;
};

/***/ }),
/* 264 */
/***/ (function(module, exports) {

/**
 * Calculate scrollbar width.
 *
 * @module mucss/scrollbar
 */

// Create the measurement node
var scrollDiv = document.createElement("div");

var style = scrollDiv.style;

style.width = '100px';
style.height = '100px';
style.overflow = 'scroll';
style.position = 'absolute';
style.top = '-9999px';

document.documentElement.appendChild(scrollDiv);

// the scrollbar width
module.exports = scrollDiv.offsetWidth - scrollDiv.clientWidth;

// Delete fake DIV
document.documentElement.removeChild(scrollDiv);

/***/ }),
/* 265 */
/***/ (function(module, exports) {

/**
 * Detect whether element is placed to fixed container or is fixed itself.
 *
 * @module mucss/is-fixed
 *
 * @param {(Element|Object)} el Element to detect fixedness.
 *
 * @return {boolean} Whether element is nested.
 */
module.exports = function (el) {
	var parentEl = el;

	//window is fixed, btw
	if (el === window) return true;

	//unlike the doc
	if (el === document) return false;

	while (parentEl) {
		if (getComputedStyle(parentEl).position === 'fixed') return true;
		parentEl = parentEl.offsetParent;
	}
	return false;
};

/***/ }),
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(0);
__webpack_require__(61).init();

// Implementing a polyfill for js native WeakMap
// in order to patch functionality in an included library
__webpack_require__(189);

var Accordion = __webpack_require__(114).Accordion;
var Glossary = __webpack_require__(231);

var terms = __webpack_require__(246);
var feedback = __webpack_require__(247);
var skipNav = __webpack_require__(249);
var siteNav = __webpack_require__(250);
var dropdown = __webpack_require__(22);
var toc = __webpack_require__(251);
var typeahead = __webpack_require__(19);
var helpers = __webpack_require__(6);

// Hack: Append jQuery to `window` for use by legacy libraries
window.$ = window.jQuery = $;

var Sticky = __webpack_require__(254);
var FormNav = __webpack_require__(319).FormNav;

$(document).ready(function() {

  // Initialize glossary
  new Glossary(terms, {}, {
    termClass: 'glossary__term accordion__button',
    definitionClass: 'glossary__definition accordion__content'
  });

  // Initialize new accordions
  $('.js-accordion').each(function() {
    var contentPrefix = $(this).data('content-prefix') || 'accordion';
    var openFirst = $(this).data('open-first') || false;
    var selectors = {
      trigger: '.js-accordion-trigger'
    };
    var opts = {
      contentPrefix: contentPrefix,
      openFirst: openFirst
    };
    new Accordion(this, selectors, opts);
  });

  new skipNav.Skipnav('.skip-nav', 'main');
  new siteNav.SiteNav('.js-site-nav');

  // Initialize table of contents
  new toc.TOC('.js-toc');

  // Initialize sticky elements
  $('.js-sticky-side').each(function() {
    var container = $(this).data('sticky-container');
    var opts = {
      within: document.getElementById(container)
    };
    if (helpers.isLargeScreen()) {
      new Sticky(this, opts);
    }
  });

  // Initialize checkbox dropdowns
  $('.js-dropdown').each(function() {
    new dropdown.Dropdown(this);
  });

  // Initialize feedback widget
  new feedback.Feedback('/data/issue/');

  $('.js-form-nav').each(function() {
    new FormNav(this);
  });

  // Initialize header typeaheads (mobile and desktop)
  $('.js-site-search').each(function() {
    new typeahead.Typeahead($(this), 'all', '/data/');
  });

  // For any link that should scroll to a section on the page apply .js-scroll to <a>
  $('.js-scroll').on('click', function(e) {
    e.preventDefault();
    var $link = $(e.target);
    var section = $link.attr('href');
    var sectionTop = $(section).offset().top;
    $('body, html').animate({
      scrollTop: sectionTop
    });
  });

  // Post feed
  // Move the read more links to be inline with the snippet from the post
  $('.js-post-content').each(function() {
    var $p = $(this).find('p:first-of-type');
    var $link = $(this).find('.js-read-more');
    if ($p.text() !== 'PDF') {
      $p.append($link);
    } else {
      $link.remove();
    }
  });
});


/***/ }),
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* FormNav
 * Submits the form on select change and clears out unnecessary params
 */

function FormNav(form) {
  this.form = form;
  this.form.addEventListener('change', this.handleChange.bind(this));
}

FormNav.prototype.handleChange = function() {
  var allSelects = this.form.querySelectorAll('select,input');
  // Remove names from all selects with no values
  for(var i = 0; i < allSelects.length; i++) {
    var select = allSelects[i];
    if(select.getAttribute('name') && !select.value) {
      select.setAttribute('name', '');
    }
  }

  this.form.submit();
};

module.exports = {FormNav: FormNav};


/***/ })
],[290]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaW5zdGFuY2VzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL3VwZGF0ZS1nZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvZG9tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9hbmFseXRpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvdHlwZWFoZWFkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMi9saWIvZXZlbnRlbWl0dGVyMi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9kcm9wZG93bnMuanMiLCJ3ZWJwYWNrOi8vLy4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL2xpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvYWNjZXNzaWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9hZGFwdG9yL2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9tYWluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9kZXN0cm95LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9kZWZhdWx0LXNldHRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2V2ZW50LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2d1aWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2luaXRpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvY2xpY2stcmFpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9kcmFnLXNjcm9sbGJhci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9rZXlib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9tb3VzZS13aGVlbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci90b3VjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vdXBkYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdHlwZWFoZWFkLmpzL2Rpc3QvdHlwZWFoZWFkLmpxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3R5cGVhaGVhZC5qcy9kaXN0L2Jsb29kaG91bmQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9pcy12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZmVjL3N0YXRpYy9qcy92ZW5kb3IvdGFibGlzdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL25vZGVfbW9kdWxlcy9kL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaWNpY2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW1teS9saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9ub29wLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2dldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2FyaWEtYWNjb3JkaW9uL3NyYy9hY2NvcmRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvaXRlbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NsaWNlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi13ZWFrLW1hcC9pbXBsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi13ZWFrLW1hcC9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nL3JhbmRvbS11bmlxLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2FycmF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL25vZGVfbW9kdWxlcy9kL2F1dG8tYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NvcHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczYtc3ltYm9sL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9ub2RlX21vZHVsZXMvZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL2lzLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvdG8tcG9zLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci90by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvbWF0aC9zaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L19pdGVyYXRlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaXMtbmF0aXZlLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXJpYS1hY2NvcmRpb24vc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9zcmMvZ2xvc3NhcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy91dGlscy9nZXQtYnktY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvZXh0ZW5kLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy91dGlscy90by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvbmF0dXJhbC1zb3J0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL2NsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy9hZGQtYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdGVtcGxhdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL2RhdGEvdGVybXMuanNvbiIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vZmVjL3N0YXRpYy9qcy90ZW1wbGF0ZXMvZmVlZGJhY2suaGJzIiwid2VicGFjazovLy8uL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9za2lwLW5hdi5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvc2l0ZS1uYXYuanMiLCJ3ZWJwYWNrOi8vLy4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL3RvYy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Njcm9sbG1vbml0b3Ivc2Nyb2xsTW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1zdGlja3kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy94dGVuZC9tdXRhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW1teS9vbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iai9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VtbXkvb2ZmLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW1teS9lbWl0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaXMtYnJvd3Nlci9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9tdWNzcy9vZmZzZXRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbXVjc3MvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL211Y3NzL2hhcy1zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9tdWNzcy9zY3JvbGxiYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9tdWNzcy9pcy1maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9mZWMvc3RhdGljL2pzL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL2Zvcm0tbmF2LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixzRUFBc0U7QUFDN0YsdUJBQXVCLHNFQUFzRTtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzVDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFELHdDQUF3QyxxQkFBcUI7QUFDN0QsbUNBQW1DLFVBQVUsUUFBUTtBQUNyRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsSUFBSSxNQUFNO0FBQzdELDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsSUFBSSxNQUFNO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFBQTtBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDNWpCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7Ozs7Ozs7O0FDL01sQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGtCQUFrQjs7Ozs7Ozs7Ozs7QUN6QmxCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDZkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztvREMzQkE7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBO0FBQ1QsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0M7QUFDeEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLEU7Ozs7Ozs7QUNqZ0REOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwREE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3pMRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQUE7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLEU7Ozs7Ozs7O0FDcjVCRDs7QUFFQSw0Q0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyw4QkFBOEI7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDeEZBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7OztBQ25CQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSwyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxJQUFJO0FBQ0osMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7Ozs7Ozs7QUNyRkE7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Ysc0JBQXNCLHlDQUF5QyxFQUFFO0FBQ2pFO0FBQ0EsK0JBQStCO0FBQy9CLFVBQVU7QUFDVixFQUFFO0FBQ0YsMkJBQTJCLHlCQUF5QixFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMEJBQTBCLDRCQUE0QixFQUFFO0FBQ3hELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3pGQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsa0JBQWtCOzs7Ozs7O0FDNUlsQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QjtBQUN2QiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUI7QUFDbkI7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLGFBQWE7QUFDMUQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ0pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDBCQUEwQiwyQkFBMkIsRUFBRTtBQUN2RCxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDakVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQy9DRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7QUM5REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWMsYUFBYSxHQUFHLGVBQWU7QUFDN0M7QUFDQTs7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7O0FDVEE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiwwQkFBMEIsa0NBQWtDLEVBQUU7QUFDOUQsQ0FBQzs7Ozs7Ozs7QUM3QkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9DQUFvQyxFQUFFO0FBQ2hGOzs7Ozs7OztBQy9CQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0SEE7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCLEVBQUUsWUFBWSxjQUFjOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCLEVBQUU7QUFDdEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWdFLEVBQUU7QUFDNUYseUJBQXlCLDZCQUE2QixFQUFFO0FBQ3hELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDOURBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7OztBQ2JBOztBQUVBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMEJBQTBCLG1DQUFtQyxFQUFFO0FBQy9ELENBQUM7Ozs7Ozs7O0FDcENEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ1BEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLHlDQUF5QyxhQUFhLElBQUksUUFBUTtBQUNsRTtBQUNBLG1CQUFtQixtQkFBbUIsSUFBSSxjQUFjO0FBQ3hEO0FBQ0EsR0FBRyxnQkFBZ0IsRUFBRSxPQUFPLEVBQUU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELDBCQUEwQjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7Ozs7OztBQ3pPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGlEQUFzQixhQUFhLEVBQUU7QUFBQTtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQzNRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDdkREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUksbUJBQW1CLEVBQUU7QUFDNUg7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEMsa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBOzs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7OztBQ3ZIQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN6RkEsbUJBQW1CLGlXQUFpVyxFQUFFLDBOQUEwTixFQUFFLHVYQUF1WCxFQUFFLHNQQUFzUCxFQUFFLHVZQUF1WSxvTkFBb04sMEZBQTBGLEVBQUUsc2NBQXNjLGtIQUFrSCxzR0FBc0csa0xBQWtMLHNJQUFzSSwwTkFBME4sMkxBQTJMLEVBQUUscVdBQXFXLHFGQUFxRix1SEFBdUgsaWdCQUFpZ0IsMmdCQUEyZ0IsNkZBQTZGLHdMQUF3TCxFQUFFLGdrQkFBZ2tCLEVBQUUsNFNBQTRTLEVBQUUsOFZBQThWLEVBQUUsa1BBQWtQLGdLQUFnSyxFQUFFLGtRQUFrUSxFQUFFLG1SQUFtUixFQUFFLHVUQUF1VCxFQUFFLDhiQUE4YixFQUFFLHVqQkFBdWpCLEVBQUUsd1RBQXdULEVBQUUsc1JBQXNSLEVBQUUsMFlBQTBZLEVBQUUsaVFBQWlRLEVBQUUsa1FBQWtRLEVBQUUsdUpBQXVKLDRWQUE0VixFQUFFLDBVQUEwVSx5T0FBeU8sRUFBRSxrVUFBa1UsRUFBRSw2Z0JBQTZnQixpYkFBaWIsRUFBRSx1aEJBQXVoQixFQUFFLHFuQkFBcW5CLEVBQUUsNFRBQTRULEVBQUUsK2VBQStlLEVBQUUsMFFBQTBRLEVBQUUsNEtBQTRLLEVBQUUsa1ZBQWtWLEVBQUUsK1dBQStXLEVBQUUsZ1ZBQWdWLGlMQUFpTCxtUUFBbVEsRUFBRSxvY0FBb2MsRUFBRSw0UEFBNFAsRUFBRSx1U0FBdVMsRUFBRSxnTEFBZ0wsRUFBRSwwUEFBMFAsRUFBRSwwYkFBMGIsRUFBRSw2UEFBNlAsb0JBQW9CLG1CQUFtQix1SUFBdUksRUFBRSxtVkFBbVYsd0NBQXdDLGtJQUFrSSxFQUFFLHlLQUF5SyxrTkFBa04sRUFBRSwrTkFBK04sRUFBRSxrU0FBa1MsRUFBRSwreUJBQSt5QixFQUFFLHlOQUF5TixFQUFFLHNiQUFzYixFQUFFLHFiQUFxYixFQUFFLDJiQUEyYixFQUFFLG95QkFBb3lCLG1aQUFtWixFQUFFLCtiQUErYiwwS0FBMEssaVVBQWlVLHFXQUFxVyxFQUFFLDhPQUE4TyxFQUFFLGdaQUFnWixFQUFFLCthQUErYSxFQUFFLHFYQUFxWCxFQUFFLCtUQUErVCxFQUFFLHlQQUF5UCwyS0FBMkssRUFBRSx3WkFBd1osRUFBRSxnY0FBZ2MsK1RBQStULDBGQUEwRiwrS0FBK0ssRUFBRSxraUJBQWtpQixFQUFFLHFoQkFBcWhCLEVBQUUsb2FBQW9hLEVBQUUsdWVBQXVlLEVBQUUscW5CQUFxbkIsRUFBRSxnT0FBZ08sRUFBRSx5UkFBeVIsRUFBRSx1T0FBdU8sRUFBRSxtWEFBbVgsRUFBRSwyVkFBMlYsRUFBRSxzYkFBc2IsRUFBRSw2ZEFBNmQsRUFBRSx3VEFBd1QsRUFBRSxtUkFBbVIsRUFBRSxpV0FBaVcsRUFBRSx3VEFBd1QsRUFBRSx3V0FBd1csRUFBRSxxSkFBcUosRUFBRSxxUkFBcVIsaUZBQWlGLHVMQUF1TCw0QkFBNEIsdU1BQXVNLEVBQUUsMExBQTBMLHdGQUF3RixpR0FBaUcsaUNBQWlDLHlKQUF5Six5UkFBeVIsRUFBRSw2WUFBNlksRUFBRSx5TUFBeU0sRUFBRSw4WEFBOFgsRUFBRSxpU0FBaVMsRUFBRSwrVEFBK1QsRUFBRSwyWEFBMlgscUZBQXFGLDBGQUEwRixFQUFFLDJXQUEyVyxFQUFFLDRVQUE0VSxFQUFFLDZlQUE2ZSxFQUFFLHdMQUF3TCxrVEFBa1QsRUFBRSxvT0FBb08sRUFBRSwrTUFBK00sRUFBRSw4ZUFBOGUsRUFBRSxrT0FBa08sRUFBRSxrTUFBa00sRUFBRSwwVEFBMFQscUpBQXFKLHlPQUF5TyxFQUFFLDZXQUE2VyxFQUFFLGdMQUFnTCxFQUFFLG1MQUFtTCxFQUFFLGdOQUFnTixFQUFFLDBSQUEwUixFQUFFLHNTQUFzUyxnQ0FBZ0MsNkdBQTZHLHNFQUFzRSw2R0FBNkcseUhBQXlILDZLQUE2SyxFQUFFLDhaQUE4WixFQUFFLGdmQUFnZiwyZkFBMmYseVpBQXlaLEVBQUUsdU9BQXVPLEVBQUUsd0lBQXdJLEVBQUUsMmFBQTJhLEVBQUUsNk5BQTZOLEVBQUUscWlCQUFxaUIsRUFBRSw0dkJBQTR2QixFQUFFLDRvQkFBNG9CLEVBQUUsMFJBQTBSLEVBQUUsMEhBQTBILEVBQUUsdVdBQXVXLEVBQUUsNFNBQTRTLEVBQUUsOGNBQThjLEVBQUUsd2RBQXdkLDhFQUE4RSxnRkFBZ0Ysc0ZBQXNGLG1HQUFtRyxFQUFFLCtrQkFBK2tCLEVBQUUsc0pBQXNKLHNEQUFzRCwrSEFBK0gsK0tBQStLLEVBQUUsZ1NBQWdTLEVBQUUsdWZBQXVmLEVBQUUsaUhBQWlILEVBQUUsMFJBQTBSLEVBQUUsaWJBQWliLEVBQUUsdVlBQXVZLEVBQUUsa3JCQUFrckIsRUFBRSwyN0JBQTI3QixFQUFFLDhRQUE4USxFQUFFLHVJQUF1SSxFQUFFLGdZQUFnWSxFQUFFLGlVQUFpVSxFQUFFLHFrQkFBcWtCLEVBQUUsK2dCQUErZ0IsRUFBRSw4VkFBOFYsRUFBRSxvYUFBb2EsRUFBRSx1Z0JBQXVnQixFQUFFLHFpQkFBcWlCLEVBQUUseWJBQXliLEVBQUUsdWZBQXVmLDhFQUE4RSxtRkFBbUYsdUpBQXVKLHFHQUFxRyxzTEFBc0wsNExBQTRMLEM7Ozs7Ozs7QUNBeDM2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7Ozs7Ozs7QUMvSWxCO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsQ0FBQyxnQkFBZ0IsRTs7Ozs7OztBQ0hqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7Ozs7Ozs7O0FDbkNsQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ2xHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGtCQUFrQjs7Ozs7OztBQ3hFbEIsZUFBZSxtS0FBK00saUJBQWlCLG1CQUFtQixjQUFjLDRCQUE0QixZQUFZLFVBQVUsaUJBQWlCLGdFQUFnRSxTQUFTLCtCQUErQixrQkFBa0IsYUFBYSxnRUFBZ0UsZ0ZBQWdGLGVBQWUsYUFBYSwrZEFBK2QsZ0JBQWdCLGlCQUFpQixhQUFhLGdCQUFnQiw4RUFBOEUsY0FBYyxzR0FBc0csY0FBYyw4TkFBOE4sY0FBYyxtSkFBbUosNkVBQTZFLGdCQUFnQixhQUFhLGtIQUFrSCx3QkFBd0IsSUFBSSxxQ0FBcUMsb0JBQW9CLGFBQWEsd0JBQXdCLElBQUksd0JBQXdCLHdCQUF3QixJQUFJLGtDQUFrQyxVQUFVLFdBQVcsMEpBQTBKLDJDQUEyQywwREFBMEQsVUFBVSx1QkFBdUIsUUFBUSxzQ0FBc0MscUNBQXFDLDBDQUEwQywyWkFBMlosNGNBQTRjLEVBQUUsaUNBQWlDLHFDQUFxQyx3QkFBd0IseUNBQXlDLGlEQUFpRCx1QkFBdUIsd0NBQXdDLHNEQUFzRCw2SUFBNkksSUFBSSx3Q0FBd0MsaUNBQWlDLGtEQUFrRCwrQkFBK0IsSUFBSSwyQkFBMkIsMkJBQTJCLElBQUksc0NBQXNDLDhDQUE4QyxhQUFhLHlDQUF5Qyx1RUFBdUUsb0JBQW9CLDZDQUE2QyxrQ0FBa0MsdUVBQXVFLHNCQUFzQiwrQkFBK0IsaUNBQWlDLHdCQUF3QixHQUFHLEdBQUcsWUFBWSxpQkFBaUIsYUFBYSxrQkFBa0IsZ0JBQWdCLCtCQUErQixJQUFJLHNEQUFzRCxXQUFXLHlEQUF5RCxlQUFlLGVBQWUsMkNBQTJDLGtDQUFrQyx1QkFBdUIsSUFBSSx5QkFBeUIsZUFBZSxnQkFBZ0Isa0NBQWtDLHlkQUF5ZCw4SUFBOEksMkZBQTJGLHFDQUFxQyxpQkFBaUIsNkJBQTZCLDRCQUE0QixtQ0FBbUMsOENBQThDLDZCQUE2QixtQkFBbUIsbUdBQW1HLDZDQUE2QywySUFBMkksNk5BQTZOLCtLQUErSyxxSUFBcUkseUxBQXlMLGFBQWEsbUJBQW1CLFdBQVcsd1JBQXdSLCtIQUErSCx3QkFBd0IsdUJBQXVCLEVBQUUsbUJBQW1CLGtJQUFrSSxjQUFjLHVCQUF1Qix1QkFBdUIsOEJBQThCLE9BQU8sbUJBQW1CLGdCQUFnQiw0QkFBNEIsOEdBQThHLG1CQUFtQiw2V0FBNlcsb0JBQW9CLG1EQUFtRCxvQ0FBb0MsdUJBQXVCLElBQUksK0JBQStCLGlCQUFpQixlQUFlLG1CQUFtQixpQkFBaUIsc0JBQXNCLHFCQUFxQiwwQkFBMEIsZ0JBQWdCLElBQUksS0FBSyxXQUFXLG9CQUFvQixZQUFZLEdBQUc7QUFDN2lSLHlDOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQStDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQztBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUM5bkJBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbkZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGlDQUFpQztBQUM3RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNwSEEsc0I7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0Q7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IiLCJmaWxlIjoiaW5pdC0yMGE2NjkwZTRiMjEzOTkzNTQwMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBkZWZhdWx0U2V0dGluZ3MgPSByZXF1aXJlKCcuL2RlZmF1bHQtc2V0dGluZycpXG4gICwgRXZlbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbGliL2V2ZW50LW1hbmFnZXInKVxuICAsIGd1aWQgPSByZXF1aXJlKCcuLi9saWIvZ3VpZCcpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcblxudmFyIGluc3RhbmNlcyA9IHt9O1xuXG5mdW5jdGlvbiBJbnN0YW5jZShlbGVtZW50KSB7XG4gIHZhciBpID0gdGhpcztcblxuICBpLnNldHRpbmdzID0gaC5jbG9uZShkZWZhdWx0U2V0dGluZ3MpO1xuICBpLmNvbnRhaW5lcldpZHRoID0gbnVsbDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBudWxsO1xuICBpLmNvbnRlbnRXaWR0aCA9IG51bGw7XG4gIGkuY29udGVudEhlaWdodCA9IG51bGw7XG5cbiAgaS5pc1J0bCA9IGQuY3NzKGVsZW1lbnQsICdkaXJlY3Rpb24nKSA9PT0gXCJydGxcIjtcbiAgaS5ldmVudCA9IG5ldyBFdmVudE1hbmFnZXIoKTtcbiAgaS5vd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXG4gIGkuc2Nyb2xsYmFyWFJhaWwgPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci14LXJhaWwnKSwgZWxlbWVudCk7XG4gIGkuc2Nyb2xsYmFyWCA9IGQuYXBwZW5kVG8oZC5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXgnKSwgaS5zY3JvbGxiYXJYUmFpbCk7XG4gIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWEJvdHRvbSA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvdHRvbScpKTtcbiAgaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9IGkuc2Nyb2xsYmFyWEJvdHRvbSA9PT0gaS5zY3JvbGxiYXJYQm90dG9tOyAvLyAhaXNOYU5cbiAgaS5zY3JvbGxiYXJYVG9wID0gaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IG51bGwgOiBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICd0b3AnKSk7XG4gIGkucmFpbEJvcmRlclhXaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvcmRlckxlZnRXaWR0aCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvcmRlclJpZ2h0V2lkdGgnKSk7XG4gIC8vIFNldCByYWlsIHRvIGRpc3BsYXk6YmxvY2sgdG8gY2FsY3VsYXRlIG1hcmdpbnNcbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgaS5yYWlsWE1hcmdpbldpZHRoID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luTGVmdCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpblJpZ2h0JykpO1xuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICcnKTtcbiAgaS5yYWlsWFdpZHRoID0gbnVsbDtcbiAgaS5yYWlsWFJhdGlvID0gbnVsbDtcblxuICBpLnNjcm9sbGJhcllSYWlsID0gZC5hcHBlbmRUbyhkLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteS1yYWlsJyksIGVsZW1lbnQpO1xuICBpLnNjcm9sbGJhclkgPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci15JyksIGkuc2Nyb2xsYmFyWVJhaWwpO1xuICBpLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsO1xuICBpLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsO1xuICBpLnNjcm9sbGJhcllUb3AgPSBudWxsO1xuICBpLnNjcm9sbGJhcllSaWdodCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ3JpZ2h0JykpO1xuICBpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSBpLnNjcm9sbGJhcllSaWdodCA9PT0gaS5zY3JvbGxiYXJZUmlnaHQ7IC8vICFpc05hTlxuICBpLnNjcm9sbGJhcllMZWZ0ID0gaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gbnVsbCA6IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2xlZnQnKSk7XG4gIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGggPSBpLmlzUnRsID8gaC5vdXRlcldpZHRoKGkuc2Nyb2xsYmFyWSkgOiBudWxsO1xuICBpLnJhaWxCb3JkZXJZV2lkdGggPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdib3JkZXJUb3BXaWR0aCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2JvcmRlckJvdHRvbVdpZHRoJykpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xuICBpLnJhaWxZTWFyZ2luSGVpZ2h0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luVG9wJykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luQm90dG9tJykpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcbiAgaS5yYWlsWUhlaWdodCA9IG51bGw7XG4gIGkucmFpbFlSYXRpbyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldElkKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRhdGFzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YXNldC5wc0lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldElkKGVsZW1lbnQsIGlkKSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5kYXRhc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJywgaWQpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuZGF0YXNldC5wc0lkID0gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlSWQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQucHNJZDtcbiAgfVxufVxuXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBuZXdJZCA9IGd1aWQoKTtcbiAgc2V0SWQoZWxlbWVudCwgbmV3SWQpO1xuICBpbnN0YW5jZXNbbmV3SWRdID0gbmV3IEluc3RhbmNlKGVsZW1lbnQpO1xuICByZXR1cm4gaW5zdGFuY2VzW25ld0lkXTtcbn07XG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tnZXRJZChlbGVtZW50KV07XG4gIHJlbW92ZUlkKGVsZW1lbnQpO1xufTtcblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2dldElkKGVsZW1lbnQpXTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9pbnN0YW5jZXMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbHMgPSByZXF1aXJlKCcuL2NsYXNzJylcbiAgLCBkID0gcmVxdWlyZSgnLi9kb20nKTtcblxuZXhwb3J0cy50b0ludCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBwYXJzZUludCh4LCAxMCkgfHwgMDtcbn07XG5cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHRoaXMuY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBzb3VyY2UpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUob3JpZ2luYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgcmVzdWx0W2tleV0gPSB0aGlzLmNsb25lKHNvdXJjZVtrZXldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5pc0VkaXRhYmxlID0gZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBkLm1hdGNoZXMoZWwsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcbiAgICAgICAgIGQubWF0Y2hlcyhlbCwgXCJzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcbiAgICAgICAgIGQubWF0Y2hlcyhlbCwgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxuICAgICAgICAgZC5tYXRjaGVzKGVsLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHNDbGFzc2VzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGNsc0xpc3QgPSBjbHMubGlzdChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGNsc0xpc3RbaV07XG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKCdwcy0nKSA9PT0gMCkge1xuICAgICAgY2xzLnJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5vdXRlcldpZHRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3dpZHRoJykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3BhZGRpbmdMZWZ0JykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ3BhZGRpbmdSaWdodCcpKSArXG4gICAgICAgICB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICdib3JkZXJMZWZ0V2lkdGgnKSkgK1xuICAgICAgICAgdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAnYm9yZGVyUmlnaHRXaWR0aCcpKTtcbn07XG5cbmV4cG9ydHMuc3RhcnRTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xuICBjbHMuYWRkKGVsZW1lbnQsICdwcy1pbi1zY3JvbGxpbmcnKTtcbiAgaWYgKHR5cGVvZiBheGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcbiAgfSBlbHNlIHtcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy14Jyk7XG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMteScpO1xuICB9XG59O1xuXG5leHBvcnRzLnN0b3BTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xuICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy1pbi1zY3JvbGxpbmcnKTtcbiAgaWYgKHR5cGVvZiBheGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcbiAgfSBlbHNlIHtcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy14Jyk7XG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMteScpO1xuICB9XG59O1xuXG5leHBvcnRzLmVudiA9IHtcbiAgaXNXZWJLaXQ6ICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gIHN1cHBvcnRzVG91Y2g6ICgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6IHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAhPT0gbnVsbFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpXG4gICwgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xuXG5mdW5jdGlvbiBnZXRUaHVtYlNpemUoaSwgdGh1bWJTaXplKSB7XG4gIGlmIChpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCkge1xuICAgIHRodW1iU2l6ZSA9IE1hdGgubWF4KHRodW1iU2l6ZSwgaS5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpO1xuICB9XG4gIGlmIChpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkge1xuICAgIHRodW1iU2l6ZSA9IE1hdGgubWluKHRodW1iU2l6ZSwgaS5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpO1xuICB9XG4gIHJldHVybiB0aHVtYlNpemU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNzcyhlbGVtZW50LCBpKSB7XG4gIHZhciB4UmFpbE9mZnNldCA9IHt3aWR0aDogaS5yYWlsWFdpZHRofTtcbiAgaWYgKGkuaXNSdGwpIHtcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0ICsgaS5jb250YWluZXJXaWR0aCAtIGkuY29udGVudFdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cbiAgaWYgKGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20pIHtcbiAgICB4UmFpbE9mZnNldC5ib3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gLSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfSBlbHNlIHtcbiAgICB4UmFpbE9mZnNldC50b3AgPSBpLnNjcm9sbGJhclhUb3AgKyBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCB4UmFpbE9mZnNldCk7XG5cbiAgdmFyIHlSYWlsT2Zmc2V0ID0ge3RvcDogZWxlbWVudC5zY3JvbGxUb3AsIGhlaWdodDogaS5yYWlsWUhlaWdodH07XG4gIGlmIChpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQpIHtcbiAgICBpZiAoaS5pc1J0bCkge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPSBpLmNvbnRlbnRXaWR0aCAtIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIGkuc2Nyb2xsYmFyWVJpZ2h0IC0gaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPSBpLnNjcm9sbGJhcllSaWdodCAtIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkuaXNSdGwpIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQgKyBpLmNvbnRhaW5lcldpZHRoICogMiAtIGkuY29udGVudFdpZHRoIC0gaS5zY3JvbGxiYXJZTGVmdCAtIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLnNjcm9sbGJhcllMZWZ0ICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgfVxuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCB5UmFpbE9mZnNldCk7XG5cbiAgZC5jc3MoaS5zY3JvbGxiYXJYLCB7bGVmdDogaS5zY3JvbGxiYXJYTGVmdCwgd2lkdGg6IGkuc2Nyb2xsYmFyWFdpZHRoIC0gaS5yYWlsQm9yZGVyWFdpZHRofSk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWSwge3RvcDogaS5zY3JvbGxiYXJZVG9wLCBoZWlnaHQ6IGkuc2Nyb2xsYmFyWUhlaWdodCAtIGkucmFpbEJvcmRlcllXaWR0aH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpLmNvbnRhaW5lcldpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgaS5jb250ZW50V2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuICBpLmNvbnRlbnRIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJYUmFpbCkpIHtcbiAgICBkLmFwcGVuZFRvKGkuc2Nyb2xsYmFyWFJhaWwsIGVsZW1lbnQpO1xuICB9XG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhcllSYWlsKSkge1xuICAgIGQuYXBwZW5kVG8oaS5zY3JvbGxiYXJZUmFpbCwgZWxlbWVudCk7XG4gIH1cblxuICBpZiAoIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGkuY29udGFpbmVyV2lkdGggKyBpLnNldHRpbmdzLnNjcm9sbFhNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRXaWR0aCkge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWFdpZHRoID0gaS5jb250YWluZXJXaWR0aCAtIGkucmFpbFhNYXJnaW5XaWR0aDtcbiAgICBpLnJhaWxYUmF0aW8gPSBpLmNvbnRhaW5lcldpZHRoIC8gaS5yYWlsWFdpZHRoO1xuICAgIGkuc2Nyb2xsYmFyWFdpZHRoID0gZ2V0VGh1bWJTaXplKGksIGgudG9JbnQoaS5yYWlsWFdpZHRoICogaS5jb250YWluZXJXaWR0aCAvIGkuY29udGVudFdpZHRoKSk7XG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IGgudG9JbnQoZWxlbWVudC5zY3JvbGxMZWZ0ICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSAvIChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpKTtcbiAgfSBlbHNlIHtcbiAgICBpLnNjcm9sbGJhclhBY3RpdmUgPSBmYWxzZTtcbiAgICBpLnNjcm9sbGJhclhXaWR0aCA9IDA7XG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IDA7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gMDtcbiAgfVxuXG4gIGlmICghaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgaS5jb250YWluZXJIZWlnaHQgKyBpLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRIZWlnaHQpIHtcbiAgICBpLnNjcm9sbGJhcllBY3RpdmUgPSB0cnVlO1xuICAgIGkucmFpbFlIZWlnaHQgPSBpLmNvbnRhaW5lckhlaWdodCAtIGkucmFpbFlNYXJnaW5IZWlnaHQ7XG4gICAgaS5yYWlsWVJhdGlvID0gaS5jb250YWluZXJIZWlnaHQgLyBpLnJhaWxZSGVpZ2h0O1xuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IGdldFRodW1iU2l6ZShpLCBoLnRvSW50KGkucmFpbFlIZWlnaHQgKiBpLmNvbnRhaW5lckhlaWdodCAvIGkuY29udGVudEhlaWdodCkpO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IGgudG9JbnQoZWxlbWVudC5zY3JvbGxUb3AgKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkgLyAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpKTtcbiAgfSBlbHNlIHtcbiAgICBpLnNjcm9sbGJhcllBY3RpdmUgPSBmYWxzZTtcbiAgICBpLnNjcm9sbGJhcllIZWlnaHQgPSAwO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICB9XG5cbiAgaWYgKGkuc2Nyb2xsYmFyWExlZnQgPj0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIHtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGg7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWVRvcCA+PSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSB7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodDtcbiAgfVxuXG4gIHVwZGF0ZUNzcyhlbGVtZW50LCBpKTtcblxuICBjbHNbaS5zY3JvbGxiYXJYQWN0aXZlID8gJ2FkZCcgOiAncmVtb3ZlJ10oZWxlbWVudCwgJ3BzLWFjdGl2ZS14Jyk7XG4gIGNsc1tpLnNjcm9sbGJhcllBY3RpdmUgPyAnYWRkJyA6ICdyZW1vdmUnXShlbGVtZW50LCAncHMtYWN0aXZlLXknKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi91cGRhdGUtZ2VvbWV0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5leHBvcnRzLmFwcGVuZFRvID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcblxuZnVuY3Rpb24gY3NzR2V0KGVsZW1lbnQsIHN0eWxlTmFtZSkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVOYW1lXTtcbn1cblxuZnVuY3Rpb24gY3NzU2V0KGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgc3R5bGVWYWx1ZSA9IHN0eWxlVmFsdWUudG9TdHJpbmcoKSArICdweCc7XG4gIH1cbiAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNzc011bHRpU2V0KGVsZW1lbnQsIG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsLnRvU3RyaW5nKCkgKyAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW2tleV0gPSB2YWw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmV4cG9ydHMuY3NzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0LCBzdHlsZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVOYW1lT3JPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gbXVsdGlwbGUgc2V0IHdpdGggb2JqZWN0XG4gICAgcmV0dXJuIGNzc011bHRpU2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY3NzR2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNzc1NldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCwgc3R5bGVWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgcXVlcnkpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhxdWVyeSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQucmVtb3ZlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2RvbS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2xkQWRkKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgfVxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBvbGRSZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgdmFyIGlkeCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICBjbGFzc2VzLnNwbGljZShpZHgsIDEpO1xuICB9XG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBvbGRBZGQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIG9sZFJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9XG59O1xuXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9jbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCByZXF1aXJlLCBtb2R1bGUsIHdpbmRvdyAqL1xuXG52YXIgZXZlbnRlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMicpO1xudmFyIEV2ZW50RW1pdHRlcjIgPSBldmVudGVtaXR0ZXIuRXZlbnRFbWl0dGVyMiB8fCBldmVudGVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5ldmVudHMgPSB3aW5kb3cuZXZlbnRzIHx8IG5ldyBFdmVudEVtaXR0ZXIyKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IDcgMTIgMTMiLCIndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBnYSAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBVUkkgPSByZXF1aXJlKCd1cmlqcycpO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5mdW5jdGlvbiB0cmFja2VyRXhpc3RzKCkge1xuICBpZiAodHlwZW9mIGdhICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qIEluaXRpYWxpemUgYSBub24gRGlnaXRhbCBBbmFseXRpY3MgUHJvZ3JhbSBHQSB0cmFja2VyXG4gKiBUaGlzIHRyYWNrZXIncyBuYW1lIGlzIFwibm9uREFQXCIsIHNvIGFsbCBjb21tYW5kcyB3aWxsIG5lZWQgdG8gYmUgcHJlZml4ZWRcbiovXG5mdW5jdGlvbiBpbml0KCkge1xuICBpZiAoIXRyYWNrZXJFeGlzdHMoKSkge1xuICAgIChmdW5jdGlvbihpLHMsbyxnLHIsYSxtKXtpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXT1yO2lbcl09aVtyXXx8ZnVuY3Rpb24oKXtcbiAgICAoaVtyXS5xPWlbcl0ucXx8W10pLnB1c2goYXJndW1lbnRzKX0saVtyXS5sPTEqbmV3IERhdGUoKTthPXMuY3JlYXRlRWxlbWVudChvKSxcbiAgICBtPXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07YS5hc3luYz0xO2Euc3JjPWc7bS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG0pXG4gICAgfSkod2luZG93LGRvY3VtZW50LCdzY3JpcHQnLCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCdnYScpO1xuICB9XG5cbiAgZ2EoJ2NyZWF0ZScsICdVQS00ODYwNTk2NC0yMicsICdhdXRvJywgJ25vdERBUCcpO1xuICBnYSgnbm90REFQLnNldCcsICdmb3JjZVNTTCcsIHRydWUpO1xuICBnYSgnbm90REFQLnNldCcsICdhbm9ueW1pemVJcCcsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBwYWdlVmlldygpIHtcbiAgaWYgKHR5cGVvZiBnYSA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG4gIHZhciBwYXRoID0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG4gIGlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICB2YXIgcXVlcnkgPSBoZWxwZXJzLnNhbml0aXplUXVlcnlQYXJhbXMoVVJJLnBhcnNlUXVlcnkoZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoKSk7XG4gICAgcGF0aCArPSAnPycgKyBzb3J0UXVlcnkocXVlcnkpO1xuICB9XG4gIGdhKCdub3REQVAuc2VuZCcsICdwYWdldmlldycsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBzb3J0UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIF8uY2hhaW4ocXVlcnkpXG4gICAgLnBhaXJzKClcbiAgICAubWFwKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgIHJldHVybiBbcGFpclswXSwgXy5pc0FycmF5KHBhaXJbMV0pID8gcGFpclsxXSA6IFtwYWlyWzFdXV07XG4gICAgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIHBhaXIpIHtcbiAgICAgIHJldHVybiBtZW1vLmNvbmNhdChfLm1hcChwYWlyWzFdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW3BhaXJbMF0sIHZhbHVlXTtcbiAgICAgIH0pKTtcbiAgICB9LCBbXSlcbiAgICAuc29ydCgpXG4gICAgLm1hcChmdW5jdGlvbihwYWlyKSB7XG4gICAgICByZXR1cm4gcGFpci5qb2luKCc9Jyk7XG4gICAgfSlcbiAgICAuam9pbignJicpXG4gICAgLnZhbHVlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBpbml0LFxuICBwYWdlVmlldzogcGFnZVZpZXcsXG4gIHNvcnRRdWVyeTogc29ydFF1ZXJ5LFxuICB0cmFja2VyRXhpc3RzOiB0cmFja2VyRXhpc3RzXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9mZWMvc3RhdGljL2pzL21vZHVsZXMvYW5hbHl0aWNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyAxMyAxNiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC92YWxpZC12YWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgVVJJID0gcmVxdWlyZSgndXJpanMnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vLyBIYWNrOiBBcHBlbmQgalF1ZXJ5IHRvIGB3aW5kb3dgIGZvciB1c2UgYnkgdHlwZWFoZWFkLmpzXG53aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSAkO1xuXG5yZXF1aXJlKCd0eXBlYWhlYWQuanMvZGlzdC90eXBlYWhlYWQuanF1ZXJ5Jyk7XG52YXIgQmxvb2Rob3VuZCA9IHJlcXVpcmUoJ3R5cGVhaGVhZC5qcy9kaXN0L2Jsb29kaG91bmQnKTtcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbnZhciBvZmZpY2VNYXAgPSB7XG4gIEg6ICdIb3VzZScsXG4gIFM6ICdTZW5hdGUnLFxuICBQOiAnUHJlc2lkZW50J1xufTtcblxuZnVuY3Rpb24gZm9ybWF0Q2FuZGlkYXRlKHJlc3VsdCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHJlc3VsdC5uYW1lLFxuICAgIGlkOiByZXN1bHQuaWQsXG4gICAgdHlwZTogJ2NhbmRpZGF0ZScsXG4gICAgb2ZmaWNlOiBvZmZpY2VNYXBbcmVzdWx0Lm9mZmljZV9zb3VnaHRdXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENvbW1pdHRlZShyZXN1bHQpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiByZXN1bHQubmFtZSxcbiAgICBpZDogcmVzdWx0LmlkLFxuICAgIHR5cGU6ICdjb21taXR0ZWUnXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFVybChyZXNvdXJjZSkge1xuICByZXR1cm4gVVJJKHdpbmRvdy5BUElfTE9DQVRJT04pXG4gICAgLnBhdGgoW3dpbmRvdy5BUElfVkVSU0lPTiwgJ25hbWVzJywgcmVzb3VyY2UsICcnXS5qb2luKCcvJykpXG4gICAgLnF1ZXJ5KHtcbiAgICAgIHE6ICclUVVFUlknLFxuICAgICAgYXBpX2tleTogd2luZG93LkFQSV9LRVlcbiAgICB9KVxuICAgIC5yZWFkYWJsZSgpO1xufVxuXG52YXIgZW5naW5lT3B0cyA9IHtcbiAgZGF0dW1Ub2tlbml6ZXI6IEJsb29kaG91bmQudG9rZW5pemVycy5vYmoud2hpdGVzcGFjZSgndmFsdWUnKSxcbiAgcXVlcnlUb2tlbml6ZXI6IEJsb29kaG91bmQudG9rZW5pemVycy53aGl0ZXNwYWNlLFxuICBsaW1pdDogMTBcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZShvcHRzKSB7XG4gIHJldHVybiBuZXcgQmxvb2Rob3VuZChfLmV4dGVuZCh7fSwgZW5naW5lT3B0cywgb3B0cykpO1xufVxuXG52YXIgY2FuZGlkYXRlRW5naW5lID0gY3JlYXRlRW5naW5lKHtcbiAgcmVtb3RlOiB7XG4gICAgdXJsOiBnZXRVcmwoJ2NhbmRpZGF0ZXMnKSxcbiAgICB3aWxkY2FyZDogJyVRVUVSWScsXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIF8ubWFwKHJlc3BvbnNlLnJlc3VsdHMsIGZvcm1hdENhbmRpZGF0ZSk7XG4gICAgfVxuICB9XG59KTtcblxudmFyIGNvbW1pdHRlZUVuZ2luZSA9IGNyZWF0ZUVuZ2luZSh7XG4gIHJlbW90ZToge1xuICAgIHVybDogZ2V0VXJsKCdjb21taXR0ZWVzJyksXG4gICAgd2lsZGNhcmQ6ICclUVVFUlknLFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBfLm1hcChyZXNwb25zZS5yZXN1bHRzLCBmb3JtYXRDb21taXR0ZWUpO1xuICAgIH0sXG4gIH1cbn0pO1xuXG52YXIgY2FuZGlkYXRlRGF0YXNldCA9IHtcbiAgbmFtZTogJ2NhbmRpZGF0ZScsXG4gIGRpc3BsYXk6ICduYW1lJyxcbiAgbGltaXQ6IDUsXG4gIHNvdXJjZTogY2FuZGlkYXRlRW5naW5lLFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBoZWFkZXI6ICc8c3BhbiBjbGFzcz1cInR0LXN1Z2dlc3Rpb25fX2hlYWRlclwiPlNlbGVjdCBhIGNhbmRpZGF0ZTo8L3NwYW4+JyxcbiAgICBwZW5kaW5nOiAnPHNwYW4gY2xhc3M9XCJ0dC1zdWdnZXN0aW9uX19sb2FkaW5nXCI+TG9hZGluZyBjYW5kaWRhdGVzLi4uPC9zcGFuPicsXG4gICAgbm90Rm91bmQ6IEhhbmRsZWJhcnMuY29tcGlsZSgnJyksIC8vIFRoaXMgaGFzIHRvIGJlIGVtcHR5IHRvIG5vdCBzaG93IGFueXRoaW5nXG4gICAgc3VnZ2VzdGlvbjogSGFuZGxlYmFycy5jb21waWxlKFxuICAgICAgJzxzcGFuPicgK1xuICAgICAgJzxzcGFuIGNsYXNzPVwidHQtc3VnZ2VzdGlvbl9fbmFtZVwiPnt7IG5hbWUgfX0gKHt7IGlkIH19KTwvc3Bhbj4nICtcbiAgICAgICc8c3BhbiBjbGFzcz1cInR0LXN1Z2dlc3Rpb25fX29mZmljZVwiPnt7IG9mZmljZSB9fTwvc3Bhbj4nICtcbiAgICAgICc8L3NwYW4+J1xuICAgIClcbiAgfVxufTtcblxudmFyIGNvbW1pdHRlZURhdGFzZXQgPSB7XG4gIG5hbWU6ICdjb21taXR0ZWUnLFxuICBkaXNwbGF5OiAnbmFtZScsXG4gIGxpbWl0OiAxMCxcbiAgc291cmNlOiBjb21taXR0ZWVFbmdpbmUsXG4gIHRlbXBsYXRlczoge1xuICAgIGhlYWRlcjogJzxzcGFuIGNsYXNzPVwidHQtc3VnZ2VzdGlvbl9faGVhZGVyXCI+U2VsZWN0IGEgY29tbWl0dGVlOjwvc3Bhbj4nLFxuICAgIHBlbmRpbmc6ICc8c3BhbiBjbGFzcz1cInR0LXN1Z2dlc3Rpb25fX2xvYWRpbmdcIj5Mb2FkaW5nIGNvbW1pdHRlZXMuLi48L3NwYW4+JyxcbiAgICBub3RGb3VuZDogSGFuZGxlYmFycy5jb21waWxlKCcnKSwgLy8gVGhpcyBoYXMgdG8gYmUgZW1wdHkgdG8gbm90IHNob3cgYW55dGhpbmdcbiAgICBzdWdnZXN0aW9uOiBIYW5kbGViYXJzLmNvbXBpbGUoXG4gICAgICAnPHNwYW4gY2xhc3M9XCJ0dC1zdWdnZXN0aW9uX19uYW1lXCI+e3sgbmFtZSB9fSAoe3sgaWQgfX0pPC9zcGFuPidcbiAgICApXG4gIH1cbn07XG5cbi8qIFRoaXMgaXMgYSBmYWtlIGRhdGFzZXQgZm9yIHNob3dpbmcgYW4gZW1wdHkgb3B0aW9uIHdpdGggdGhlIHF1ZXJ5XG4gKiB3aGVuIGNsaWNrZWQsIHRoaXMgd2lsbCBsb2FkIHRoZSByZWNlaXB0cyBwYWdlLFxuICogZmlsdGVyZWQgdG8gY29udHJpYnV0aW9ucyBmcm9tIHRoaXMgcGVyc29uXG4gKi9cbnZhciBpbmRpdmlkdWFsRGF0YXNldCA9IHtcbiAgZGlzcGxheTogJ2lkJyxcbiAgc291cmNlOiBmdW5jdGlvbihxdWVyeSwgc3luY1Jlc3VsdHMpIHtcbiAgICBzeW5jUmVzdWx0cyhbe1xuICAgICAgaWQ6IGhlbHBlcnMuc2FuaXRpemVWYWx1ZShxdWVyeSksXG4gICAgICB0eXBlOiAnaW5kaXZpZHVhbCdcbiAgICB9XSk7XG4gIH0sXG4gIHRlbXBsYXRlczoge1xuICAgIHN1Z2dlc3Rpb246IGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICByZXR1cm4gJzxzcGFuPjxzdHJvbmc+U2VhcmNoIGluZGl2aWR1YWwgY29udHJpYnV0aW9ucyBmcm9tOjwvc3Ryb25nPiBcIicgKyBkYXR1bS5pZCArICdcIjwvc3Bhbj4nO1xuICAgIH1cbiAgfVxufTtcblxuLyogVGhpcyBpcyBhIGZha2UgZGF0YXNldCBmb3Igc2hvd2luZyBhbiBlbXB0eSBvcHRpb24gd2l0aCB0aGUgcXVlcnlcbiAqIHdoZW4gY2xpY2tlZCwgdGhpcyB3aWxsIHN1Ym1pdCB0aGUgZm9ybSB0byB0aGUgRGlnaXRhbEdvdiBzZWFyY2ggc2l0ZVxuICovXG52YXIgc2l0ZURhdGFzZXQgPSB7XG4gIGRpc3BsYXk6ICdpZCcsXG4gIHNvdXJjZTogZnVuY3Rpb24ocXVlcnksIHN5bmNSZXN1bHRzKSB7XG4gICAgc3luY1Jlc3VsdHMoW3tcbiAgICAgIGlkOiBoZWxwZXJzLnNhbml0aXplVmFsdWUocXVlcnkpLFxuICAgICAgdHlwZTogJ3NpdGUnXG4gICAgfV0pO1xuICB9LFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBzdWdnZXN0aW9uOiBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgcmV0dXJuICc8c3Bhbj48c3Ryb25nPlNlYXJjaCBvdGhlciBwYWdlczo8L3N0cm9uZz4gXCInICsgZGF0dW0uaWQgKyAnXCI8L3NwYW4+JztcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkYXRhc2V0cyA9IHtcbiAgY2FuZGlkYXRlczogY2FuZGlkYXRlRGF0YXNldCxcbiAgY29tbWl0dGVlczogY29tbWl0dGVlRGF0YXNldCxcbiAgYWxsRGF0YTogW2NhbmRpZGF0ZURhdGFzZXQsIGNvbW1pdHRlZURhdGFzZXRdLFxuICBhbGw6IFtjYW5kaWRhdGVEYXRhc2V0LCBjb21taXR0ZWVEYXRhc2V0LCBpbmRpdmlkdWFsRGF0YXNldCwgc2l0ZURhdGFzZXRdXG59O1xuXG52YXIgdHlwZWFoZWFkT3B0cyA9IHtcbiAgbWluTGVuZ3RoOiAzLFxuICBoaWdobGlnaHQ6IHRydWUsXG4gIGhpbnQ6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBUeXBlYWhlYWQoc2VsZWN0b3IsIHR5cGUsIHVybCkge1xuICB0aGlzLiRpbnB1dCA9ICQoc2VsZWN0b3IpO1xuICB0aGlzLnVybCA9IHVybCB8fCAnLyc7XG4gIHRoaXMudHlwZWFoZWFkID0gbnVsbDtcblxuICB0aGlzLmRhdGFzZXQgPSBkYXRhc2V0c1t0eXBlXTtcblxuICB0aGlzLmluaXQoKTtcblxuICBldmVudHMub24oJ3NlYXJjaFR5cGVDaGFuZ2VkJywgdGhpcy5oYW5kbGVDaGFuZ2VFdmVudC5iaW5kKHRoaXMpKTtcbn1cblxuVHlwZWFoZWFkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnR5cGVhaGVhZCkge1xuICAgIHRoaXMuJGlucHV0LnR5cGVhaGVhZCgnZGVzdHJveScpO1xuICB9XG4gIHRoaXMudHlwZWFoZWFkID0gdGhpcy4kaW5wdXQudHlwZWFoZWFkKHR5cGVhaGVhZE9wdHMsIHRoaXMuZGF0YXNldCk7XG4gIHRoaXMuJGVsZW1lbnQgPSB0aGlzLiRpbnB1dC5wYXJlbnQoJy50d2l0dGVyLXR5cGVhaGVhZCcpO1xuICB0aGlzLiRlbGVtZW50LmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICB0aGlzLiRlbGVtZW50LmZpbmQoJy50dC1tZW51JykuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICB0aGlzLiRpbnB1dC5vbigndHlwZWFoZWFkOnNlbGVjdCcsIHRoaXMuc2VsZWN0LmJpbmQodGhpcykpO1xufTtcblxuVHlwZWFoZWFkLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5pbml0KGRhdGEudHlwZSk7XG59O1xuXG5UeXBlYWhlYWQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXR1bSkge1xuICBpZiAoZGF0dW0udHlwZSA9PT0gJ2luZGl2aWR1YWwnKSB7XG4gICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy51cmwgKyAncmVjZWlwdHMvaW5kaXZpZHVhbC1jb250cmlidXRpb25zLz9jb250cmlidXRvcl9uYW1lPScgKyBkYXR1bS5pZDtcbiAgfSBlbHNlIGlmIChkYXR1bS50eXBlID09PSAnc2l0ZScpIHtcbiAgICB0aGlzLnNlYXJjaFNpdGUoZGF0dW0uaWQpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMudXJsICsgZGF0dW0udHlwZSArICcvJyArIGRhdHVtLmlkO1xuICB9XG59O1xuXG5UeXBlYWhlYWQucHJvdG90eXBlLnNlYXJjaFNpdGUgPSBmdW5jdGlvbihxdWVyeSkge1xuICAvKiBJZiB0aGUgc2l0ZSBzZWFyY2ggb3B0aW9uIGlzIHNlbGVjdGVkLCB0aGlzIGZ1bmN0aW9uIGhhbmRsZXMgc3VibWl0dGluZ1xuICAgKiBhIG5ldyBzZWFyY2ggb24gL3NlYXJjaFxuICAgKi9cblxuICB2YXIgJGZvcm0gPSB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJyk7XG4gIHZhciBhY3Rpb24gPSAkZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgdGhpcy4kaW5wdXQudmFsKHF1ZXJ5KTtcbiAgJGZvcm0uYXR0cignYWN0aW9uJywgYWN0aW9uKTtcbiAgJGZvcm0uc3VibWl0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHlwZWFoZWFkOiBUeXBlYWhlYWQsXG4gIGRhdGFzZXRzOiBkYXRhc2V0c1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL3R5cGVhaGVhZC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYgNyAxMiIsIi8qIVxuICogRXZlbnRFbWl0dGVyMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hpajFueC9FdmVudEVtaXR0ZXIyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIGhpajFueFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG47IWZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiBfaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfTtcbiAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGlmICh0aGlzLl9jb25mKSB7XG4gICAgICBjb25maWd1cmUuY2FsbCh0aGlzLCB0aGlzLl9jb25mKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmUoY29uZikge1xuICAgIGlmIChjb25mKSB7XG5cbiAgICAgIHRoaXMuX2NvbmYgPSBjb25mO1xuXG4gICAgICBjb25mLmRlbGltaXRlciAmJiAodGhpcy5kZWxpbWl0ZXIgPSBjb25mLmRlbGltaXRlcik7XG4gICAgICBjb25mLm1heExpc3RlbmVycyAmJiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IGNvbmYubWF4TGlzdGVuZXJzKTtcbiAgICAgIGNvbmYud2lsZGNhcmQgJiYgKHRoaXMud2lsZGNhcmQgPSBjb25mLndpbGRjYXJkKTtcbiAgICAgIGNvbmYubmV3TGlzdGVuZXIgJiYgKHRoaXMubmV3TGlzdGVuZXIgPSBjb25mLm5ld0xpc3RlbmVyKTtcblxuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lclRyZWUgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoY29uZikge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHRoaXMubmV3TGlzdGVuZXIgPSBmYWxzZTtcbiAgICBjb25maWd1cmUuY2FsbCh0aGlzLCBjb25mKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEF0dGVudGlvbiwgZnVuY3Rpb24gcmV0dXJuIHR5cGUgbm93IGlzIGFycmF5LCBhbHdheXMgIVxuICAvLyBJdCBoYXMgemVybyBlbGVtZW50cyBpZiBubyBhbnkgbWF0Y2hlcyBmb3VuZCBhbmQgb25lIG9yIG1vcmVcbiAgLy8gZWxlbWVudHMgKGxlYWZzKSBpZiB0aGVyZSBhcmUgbWF0Y2hlc1xuICAvL1xuICBmdW5jdGlvbiBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIGkpIHtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycz1bXSwgbGVhZiwgbGVuLCBicmFuY2gsIHhUcmVlLCB4eFRyZWUsIGlzb2xhdGVkQnJhbmNoLCBlbmRSZWFjaGVkLFxuICAgICAgICB0eXBlTGVuZ3RoID0gdHlwZS5sZW5ndGgsIGN1cnJlbnRUeXBlID0gdHlwZVtpXSwgbmV4dFR5cGUgPSB0eXBlW2krMV07XG4gICAgaWYgKGkgPT09IHR5cGVMZW5ndGggJiYgdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQocykgbGlzdCBhbmQgdGhlIHRyZWUgaGFzIGxpc3RlbmVyc1xuICAgICAgLy8gaW52b2tlIHRob3NlIGxpc3RlbmVycy5cbiAgICAgIC8vXG4gICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVycyk7XG4gICAgICAgIHJldHVybiBbdHJlZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxlYWYgPSAwLCBsZW4gPSB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoOyBsZWFmIDwgbGVuOyBsZWFmKyspIHtcbiAgICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVyc1tsZWFmXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0cmVlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKGN1cnJlbnRUeXBlID09PSAnKicgfHwgY3VycmVudFR5cGUgPT09ICcqKicpIHx8IHRyZWVbY3VycmVudFR5cGVdKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIGV2ZW50IGVtaXR0ZWQgaXMgJyonIGF0IHRoaXMgcGFydFxuICAgICAgLy8gb3IgdGhlcmUgaXMgYSBjb25jcmV0ZSBtYXRjaCBhdCB0aGlzIHBhdGNoXG4gICAgICAvL1xuICAgICAgaWYgKGN1cnJlbnRUeXBlID09PSAnKicpIHtcbiAgICAgICAgZm9yIChicmFuY2ggaW4gdHJlZSkge1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB0cmVlLmhhc093blByb3BlcnR5KGJyYW5jaCkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkrMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIGlmKGN1cnJlbnRUeXBlID09PSAnKionKSB7XG4gICAgICAgIGVuZFJlYWNoZWQgPSAoaSsxID09PSB0eXBlTGVuZ3RoIHx8IChpKzIgPT09IHR5cGVMZW5ndGggJiYgbmV4dFR5cGUgPT09ICcqJykpO1xuICAgICAgICBpZihlbmRSZWFjaGVkICYmIHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIFRoZSBuZXh0IGVsZW1lbnQgaGFzIGEgX2xpc3RlbmVycywgYWRkIGl0IHRvIHRoZSBoYW5kbGVycy5cbiAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgdHlwZUxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChicmFuY2ggaW4gdHJlZSkge1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB0cmVlLmhhc093blByb3BlcnR5KGJyYW5jaCkpIHtcbiAgICAgICAgICAgIGlmKGJyYW5jaCA9PT0gJyonIHx8IGJyYW5jaCA9PT0gJyoqJykge1xuICAgICAgICAgICAgICBpZih0cmVlW2JyYW5jaF0uX2xpc3RlbmVycyAmJiAhZW5kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIHR5cGVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKzIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vIG1hdGNoIG9uIHRoaXMgb25lLCBzaGlmdCBpbnRvIHRoZSB0cmVlIGJ1dCBub3QgaW4gdGhlIHR5cGUgYXJyYXkuXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbY3VycmVudFR5cGVdLCBpKzEpKTtcbiAgICB9XG5cbiAgICB4VHJlZSA9IHRyZWVbJyonXTtcbiAgICBpZiAoeFRyZWUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgdHJlZSB3aWxsIGFsbG93IGFueSBtYXRjaCBmb3IgdGhpcyBwYXJ0LFxuICAgICAgLy8gdGhlbiByZWN1cnNpdmVseSBleHBsb3JlIGFsbCBicmFuY2hlcyBvZiB0aGUgdHJlZVxuICAgICAgLy9cbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeFRyZWUsIGkrMSk7XG4gICAgfVxuXG4gICAgeHhUcmVlID0gdHJlZVsnKionXTtcbiAgICBpZih4eFRyZWUpIHtcbiAgICAgIGlmKGkgPCB0eXBlTGVuZ3RoKSB7XG4gICAgICAgIGlmKHh4VHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGxpc3RlbmVyIG9uIGEgJyoqJywgaXQgd2lsbCBjYXRjaCBhbGwsIHNvIGFkZCBpdHMgaGFuZGxlci5cbiAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBhcnJheXMgb2YgbWF0Y2hpbmcgbmV4dCBicmFuY2hlcyBhbmQgb3RoZXJzLlxuICAgICAgICBmb3IoYnJhbmNoIGluIHh4VHJlZSkge1xuICAgICAgICAgIGlmKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnICYmIHh4VHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XG4gICAgICAgICAgICBpZihicmFuY2ggPT09IG5leHRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIG5leHQgZWxlbWVudCB3aWxsIG1hdGNoLCBzbyBqdW1wIHR3aWNlLlxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpKzIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGJyYW5jaCA9PT0gY3VycmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCBub2RlIG1hdGNoZXMsIG1vdmUgaW50byB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSsxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoID0ge307XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoW2JyYW5jaF0gPSB4eFRyZWVbYnJhbmNoXTtcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB7ICcqKic6IGlzb2xhdGVkQnJhbmNoIH0sIGkrMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgYW5kIHN0aWxsIG9uIGEgJyoqJ1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYoeHhUcmVlWycqJ10gJiYgeHhUcmVlWycqJ10uX2xpc3RlbmVycykge1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVsnKiddLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdGVuZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ3Jvd0xpc3RlbmVyVHJlZSh0eXBlLCBsaXN0ZW5lcikge1xuXG4gICAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuXG4gICAgLy9cbiAgICAvLyBMb29rcyBmb3IgdHdvIGNvbnNlY3V0aXZlICcqKicsIGlmIHNvLCBkb24ndCBhZGQgdGhlIGV2ZW50IGF0IGFsbC5cbiAgICAvL1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHR5cGUubGVuZ3RoOyBpKzEgPCBsZW47IGkrKykge1xuICAgICAgaWYodHlwZVtpXSA9PT0gJyoqJyAmJiB0eXBlW2krMV0gPT09ICcqKicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmVlID0gdGhpcy5saXN0ZW5lclRyZWU7XG4gICAgdmFyIG5hbWUgPSB0eXBlLnNoaWZ0KCk7XG5cbiAgICB3aGlsZSAobmFtZSkge1xuXG4gICAgICBpZiAoIXRyZWVbbmFtZV0pIHtcbiAgICAgICAgdHJlZVtuYW1lXSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0cmVlID0gdHJlZVtuYW1lXTtcblxuICAgICAgaWYgKHR5cGUubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgaWYgKCF0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBbdHJlZS5fbGlzdGVuZXJzLCBsaXN0ZW5lcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh0cmVlLl9saXN0ZW5lcnMpKSB7XG5cbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgICAgICBpZiAoIXRyZWUuX2xpc3RlbmVycy53YXJuZWQpIHtcblxuICAgICAgICAgICAgdmFyIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobSA+IDAgJiYgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCA+IG0pIHtcblxuICAgICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBuYW1lID0gdHlwZS5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbiAgLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4gIC8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuICAvL1xuICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kZWxpbWl0ZXIgPSAnLic7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcbiAgICBpZiAoIXRoaXMuX2NvbmYpIHRoaXMuX2NvbmYgPSB7fTtcbiAgICB0aGlzLl9jb25mLm1heExpc3RlbmVycyA9IG47XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudCA9ICcnO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgIHRoaXMubWFueShldmVudCwgMSwgZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmICgtLXR0bCA9PT0gMCkge1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lci5fb3JpZ2luID0gZm47XG5cbiAgICB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLm5ld0xpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlICpfYWxsKiBmdW5jdGlvbnMgYW5kIGludm9rZSB0aGVtLlxuICAgIGlmICh0aGlzLl9hbGwpIHtcbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbDsgaSsrKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9hbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICB0aGlzLl9hbGxbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG5cbiAgICAgIGlmICghdGhpcy5fYWxsICYmXG4gICAgICAgICF0aGlzLl9ldmVudHMuZXJyb3IgJiZcbiAgICAgICAgISh0aGlzLndpbGRjYXJkICYmIHRoaXMubGlzdGVuZXJUcmVlLmVycm9yKSkge1xuXG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgaGFuZGxlciA9IFtdO1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBzbG93ZXJcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsOyBpKyspIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbDsgaSsrKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkgfHwgISF0aGlzLl9hbGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICEhdGhpcy5fYWxsO1xuICAgIH1cblxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uQW55KHR5cGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbiBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIGdyb3dMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgZWxzZSBpZih0eXBlb2YgdGhpcy5fZXZlbnRzW3R5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcblxuICAgICAgICB2YXIgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG5cbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbkFueSA9IGZ1bmN0aW9uKGZuKSB7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uQW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5fYWxsKSB7XG4gICAgICB0aGlzLl9hbGwgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBldmVudCBsaXN0ZW5lciBjb2xsZWN0aW9uLlxuICAgIHRoaXMuX2FsbC5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyxsZWFmcz1bXTtcblxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuICAgICAgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICBsZWFmcy5wdXNoKHtfbGlzdGVuZXJzOmhhbmRsZXJzfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaUxlYWY9MDsgaUxlYWY8bGVhZnMubGVuZ3RoOyBpTGVhZisrKSB7XG4gICAgICB2YXIgbGVhZiA9IGxlYWZzW2lMZWFmXTtcbiAgICAgIGhhbmRsZXJzID0gbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLmxpc3RlbmVyICYmIGhhbmRsZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5fb3JpZ2luICYmIGhhbmRsZXJzW2ldLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgICAgIGxlYWYuX2xpc3RlbmVycy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFmLl9saXN0ZW5lcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChoYW5kbGVycyA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgKGhhbmRsZXJzLmxpc3RlbmVyICYmIGhhbmRsZXJzLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgKGhhbmRsZXJzLl9vcmlnaW4gJiYgaGFuZGxlcnMuX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZkFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGkgPSAwLCBsID0gMCwgZm5zO1xuICAgIGlmIChmbiAmJiB0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcbiAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYoZm4gPT09IGZuc1tpXSkge1xuICAgICAgICAgIGZucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWxsID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgIXRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIHZhciBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG5cbiAgICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xuICAgICAgICB2YXIgbGVhZiA9IGxlYWZzW2lMZWFmXTtcbiAgICAgICAgbGVhZi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcblxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnNBbnkgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbC5cbiAgICB3aW5kb3cuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcbiAgfVxufSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjIvbGliL2V2ZW50ZW1pdHRlcjIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IDcgMTIgMTMiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cdHJldHVybiBmbjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgncGVyZmVjdC1zY3JvbGxiYXIvanF1ZXJ5JykoJCk7XG5cbnZhciBsaXN0ZW5lcnMgPSByZXF1aXJlKCcuL2xpc3RlbmVycycpO1xuXG52YXIgS0VZQ09ERV9FU0MgPSAyNztcbnZhciBLRVlDT0RFX0VOVEVSID0gMTM7XG5cbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgY2hlY2tib3hlczogdHJ1ZSxcbn07XG5cbi8qKlxuICogRHJvcGRvd24gdG9nZ2xlc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBDU1Mgc2VsZWN0b3IgZm9yIHRoZSBmaWVsZHNldCB0aGF0IGNvbnRhaW5zIGV2ZXJ5dGhpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gT3B0aW9uc1xuICovXG5mdW5jdGlvbiBEcm9wZG93bihzZWxlY3Rvciwgb3B0cykge1xuICB0aGlzLm9wdHMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdE9wdHMsIG9wdHMpO1xuXG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy4kYm9keSA9ICQoc2VsZWN0b3IpO1xuICB0aGlzLiRidXR0b24gPSB0aGlzLiRib2R5LmZpbmQoJy5kcm9wZG93bl9fYnV0dG9uJyk7XG4gIHRoaXMuJHBhbmVsID0gdGhpcy4kYm9keS5maW5kKCcuZHJvcGRvd25fX3BhbmVsJyk7XG5cbiAgaWYgKHRoaXMub3B0cy5jaGVja2JveGVzKSB7XG4gICAgdGhpcy4kc2VsZWN0ZWQgPSB0aGlzLiRib2R5LmZpbmQoJy5kcm9wZG93bl9fc2VsZWN0ZWQnKTtcbiAgICB0aGlzLiRwYW5lbC5vbigna2V5dXAnLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgdGhpcy5oYW5kbGVDaGVja0tleXVwLmJpbmQodGhpcykpO1xuICAgIHRoaXMuJHBhbmVsLm9uKCdjaGFuZ2UnLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgdGhpcy5oYW5kbGVDaGVjay5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiRwYW5lbC5vbignY2xpY2snLCAnLmRyb3Bkb3duX19pdGVtLS1zZWxlY3RlZCcsIHRoaXMuaGFuZGxlRHJvcGRvd25JdGVtQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLiRzZWxlY3RlZC5vbignY2xpY2snLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgdGhpcy5oYW5kbGVTZWxlY3RlZElucHV0Q2xpY2suYmluZCh0aGlzKSk7XG4gICAgdGhpcy4kc2VsZWN0ZWQub24oJ2NsaWNrJywgJy5kcm9wZG93bl9fcmVtb3ZlJywgdGhpcy5oYW5kbGVSZW1vdmVDbGljay5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmVQYW5lbCgpO1xuICAgIH1cbiAgfVxuXG4gICQoZG9jdW1lbnQuYm9keSkub24oJ3RhZzpyZW1vdmVBbGwnLCB0aGlzLmhhbmRsZUNsZWFyRmlsdGVycy5iaW5kKHRoaXMpKTtcblxuICB0aGlzLiRidXR0b24ub24oJ2NsaWNrJywgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5ldmVudHMgPSBuZXcgbGlzdGVuZXJzLkxpc3RlbmVycygpO1xuICB0aGlzLmV2ZW50cy5vbihkb2N1bWVudC5ib2R5LCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrQXdheS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ldmVudHMub24oZG9jdW1lbnQuYm9keSwgJ2ZvY3VzaW4nLCB0aGlzLmhhbmRsZUZvY3VzQXdheS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ldmVudHMub24oZG9jdW1lbnQuYm9keSwgJ2tleXVwJywgdGhpcy5oYW5kbGVLZXl1cC5iaW5kKHRoaXMpKTtcblxuICAvLyBTZXQgQVJJQSBhdHRyaWJ1dGVzXG4gIHRoaXMuJGJ1dHRvbi5hdHRyKCdhcmlhLWhhc3BvcHVwJywgJ3RydWUnKTtcbiAgdGhpcy4kcGFuZWwuYXR0cignYXJpYS1sYWJlbCcsJ01vcmUgb3B0aW9ucycpO1xufVxuXG5Ecm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciBtZXRob2QgPSB0aGlzLmlzT3BlbiA/IHRoaXMuaGlkZSA6IHRoaXMuc2hvdztcbiAgbWV0aG9kLmFwcGx5KHRoaXMpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJHBhbmVsLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG4gIHRoaXMuJHBhbmVsLnBlcmZlY3RTY3JvbGxiYXIoe3N1cHByZXNzU2Nyb2xsWDogdHJ1ZX0pO1xuICB0aGlzLiRwYW5lbC5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl06Zmlyc3QnKS5mb2N1cygpO1xuICB0aGlzLiRidXR0b24uYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICB0aGlzLmlzT3BlbiA9IHRydWU7XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRwYW5lbC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gIHRoaXMuJGJ1dHRvbi5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaGFuZGxlQ2xpY2tBd2F5ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICBpZiAoIXRoaXMuJGJvZHkuaGFzKCR0YXJnZXQpLmxlbmd0aCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICB9XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaGFuZGxlRm9jdXNBd2F5ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICBpZiAodGhpcy5pc09wZW4gJiYgIXRoaXMuJHBhbmVsLmhhcygkdGFyZ2V0KS5sZW5ndGggJiZcbiAgICAgICF0aGlzLiRwYW5lbC5pcygkdGFyZ2V0KSAmJiAhJHRhcmdldC5pcyh0aGlzLiRidXR0b24pKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cbn07XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5oYW5kbGVLZXl1cCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9FU0MpIHtcbiAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgdGhpcy4kYnV0dG9uLmZvY3VzKCk7XG4gICAgfVxuICB9XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaGFuZGxlQ2hlY2tLZXl1cCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9FTlRFUikge1xuICAgICQoZS50YXJnZXQpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKS5jaGFuZ2UoKTtcbiAgfVxufTtcblxuRHJvcGRvd24ucHJvdG90eXBlLmhhbmRsZUNoZWNrID0gZnVuY3Rpb24oZSkge1xuICB2YXIgJGlucHV0ID0gJChlLnRhcmdldCk7XG4gIGlmICgkaW5wdXQuaXMoJzpjaGVja2VkJykpIHtcbiAgICB0aGlzLnNlbGVjdEl0ZW0oJGlucHV0KTtcbiAgfVxufTtcblxuRHJvcGRvd24ucHJvdG90eXBlLmhhbmRsZURyb3Bkb3duSXRlbUNsaWNrID0gZnVuY3Rpb24oZSkge1xuICB2YXIgJGJ1dHRvbiA9ICQoZS50YXJnZXQpO1xuICB2YXIgJGlucHV0ID0gdGhpcy4kc2VsZWN0ZWQuZmluZCgnIycgKyAkYnV0dG9uLmRhdGEoJ2xhYmVsJykpO1xuXG4gIGlmICghJGJ1dHRvbi5oYXNDbGFzcygnaXMtY2hlY2tlZCcpKSB7XG4gICAgJGlucHV0LmNsaWNrKCk7XG4gIH1cbn07XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RlZElucHV0Q2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gIHZhciAkYnV0dG9uID0gdGhpcy4kcGFuZWwuZmluZCgnYnV0dG9uW2RhdGEtbGFiZWw9JyArIGUudGFyZ2V0LmlkICsgJ10nKTtcblxuICAkYnV0dG9uLnRvZ2dsZUNsYXNzKCdpcy1jaGVja2VkJyk7XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaGFuZGxlQ2hlY2tib3hSZW1vdmFsID0gZnVuY3Rpb24oJGlucHV0KSB7XG4gIHZhciAkaXRlbSA9ICRpbnB1dC5wYXJlbnQoKTtcbiAgdmFyICRsYWJlbCA9ICRpbnB1dC5wYXJlbnQoKS5maW5kKCdsYWJlbCcpO1xuICB2YXIgJGJ1dHRvbiA9IHRoaXMuJHBhbmVsLmZpbmQoJ2J1dHRvbltkYXRhLWxhYmVsPVwiJyArICRpbnB1dC5hdHRyKCdpZCcpICsnXCJdJyk7XG5cbiAgaWYgKCRidXR0b24ubGVuZ3RoID4gMCkge1xuICAgICRidXR0b24ucGFyZW50KCkuYXBwZW5kKCRpbnB1dCk7XG4gICAgJGJ1dHRvbi5wYXJlbnQoKS5hcHBlbmQoJGxhYmVsKTtcbiAgICAkYnV0dG9uLnJlbW92ZSgpO1xuXG4gICAgJGl0ZW0ucmVtb3ZlKCk7XG4gIH1cbn07XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5oYW5kbGVSZW1vdmVDbGljayA9IGZ1bmN0aW9uKGUsIG9wdHMpIHtcbiAgdmFyICRpbnB1dCA9ICQoZS50YXJnZXQpLnBhcmVudCgpLmZpbmQoJ2lucHV0Jyk7XG5cbiAgLy8gdGFnIHJlbW92YWxcbiAgaWYgKG9wdHMpIHtcbiAgICAkaW5wdXQgPSB0aGlzLiRzZWxlY3RlZC5maW5kKCcjJyArIG9wdHMua2V5KTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlQ2hlY2tib3hSZW1vdmFsKCRpbnB1dCk7XG59O1xuXG4vLyBcIkNsZWFyIGFsbCBmaWx0ZXJzXCIgd2lsbCByZW1vdmUgdW5jaGVja2VkIGRyb3Bkb3duIGNoZWNrYm94ZXNcbkRyb3Bkb3duLnByb3RvdHlwZS5oYW5kbGVDbGVhckZpbHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy4kc2VsZWN0ZWQpIHtcbiAgICB0aGlzLiRzZWxlY3RlZC5maW5kKCdpbnB1dDpjaGVja2JveDpub3QoOmNoZWNrZWQpJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmhhbmRsZUNoZWNrYm94UmVtb3ZhbCgkKHRoaXMpKTtcbiAgICB9KTtcbiAgfVxufTtcblxuRHJvcGRvd24ucHJvdG90eXBlLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbigkaW5wdXQpIHtcbiAgdmFyICRpdGVtID0gJGlucHV0LnBhcmVudCgnLmRyb3Bkb3duX19pdGVtJyk7XG4gIHZhciAkbGFiZWwgPSAkaXRlbS5maW5kKCdsYWJlbCcpO1xuICB2YXIgcHJldiA9ICRpdGVtLnByZXZBbGwoJy5kcm9wZG93bl9faXRlbScpO1xuICB2YXIgbmV4dCA9ICRpdGVtLm5leHRBbGwoJy5kcm9wZG93bl9faXRlbScpO1xuXG4gICRpdGVtLmFmdGVyKCc8bGkgY2xhc3M9XCJkcm9wZG93bl9faXRlbVwiPicgK1xuICAgICc8YnV0dG9uIGNsYXNzPVwiZHJvcGRvd25fX2l0ZW0tLXNlbGVjdGVkIGlzLWNoZWNrZWRcIicgK1xuICAgICcgZGF0YS1sYWJlbD1cIicgKyAkbGFiZWwuYXR0cignZm9yJykgKyAnXCIgPicgK1xuICAgICRsYWJlbC50ZXh0KCkgKyAnPC9idXR0b24+PC9saT4nKTtcblxuICB0aGlzLiRzZWxlY3RlZC5hcHBlbmQoJGl0ZW0pO1xuXG4gICRpdGVtLmFwcGVuZCgnPGJ1dHRvbiBjbGFzcz1cImRyb3Bkb3duX19yZW1vdmVcIj4nICtcbiAgICAnPHNwYW4gY2xhc3M9XCJ1LXZpc3VhbGx5LWhpZGRlblwiPlJlbW92ZTwvc3Bhbj48L2J1dHRvbj4nKTtcblxuICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgaWYgKG5leHQubGVuZ3RoKSB7XG4gICAgICAkKG5leHRbMF0pLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2Lmxlbmd0aCkge1xuICAgICAgJChwcmV2WzBdKS5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKS5mb2N1cygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbW92ZVBhbmVsKCk7XG4gICAgdGhpcy4kc2VsZWN0ZWQuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykuZm9jdXMoKTtcbiAgfVxufTtcblxuRHJvcGRvd24ucHJvdG90eXBlLnJlbW92ZVBhbmVsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJHBhbmVsLnJlbW92ZSgpO1xuICB0aGlzLiRidXR0b24ucmVtb3ZlKCk7XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy4kcGFuZWwuZmluZCgnaW5wdXQnKS5sZW5ndGggPT09IDA7XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50cy5jbGVhcigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7RHJvcGRvd246IERyb3Bkb3dufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL2Ryb3Bkb3ducy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuZnVuY3Rpb24gTGlzdGVuZXJzKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG5MaXN0ZW5lcnMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxtKSB7XG4gIHZhciAkZWxtID0gJChlbG0pO1xuICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpO1xuICB0aGlzLmxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCBbXTtcbiAgdGhpcy5saXN0ZW5lcnMucHVzaCh7JGVsbTogJGVsbSwgYXJnczogYXJnc30pO1xuICAkZWxtLm9uLmFwcGx5KCRlbG0sIGFyZ3MpO1xufTtcblxuTGlzdGVuZXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdmFyICRlbG0gPSBsaXN0ZW5lci4kZWxtO1xuICAgIHZhciBhcmdzID0gbGlzdGVuZXIuYXJncztcbiAgICAkZWxtLm9mZi5hcHBseSgkZWxtLCBhcmdzKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtMaXN0ZW5lcnM6IExpc3RlbmVyc307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9saXN0ZW5lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBzZXR0aW5nIG9yIHJlbW92aW5nIHRhYmluZGV4IG9uIGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAqIGluIGEgcGFyZW50IGRpdi4gVXNlZnVsIGZvciBoaWRpbmcgZWxlbWVudHMgb2ZmLWNhbnZhcyB3aXRob3V0IHNldHRpbmdcbiAqIGRpc3BsYXk6bm9uZSwgd2hpbGUgc3RpbGwgcmVtb3ZpbmcgZnJvbSB0aGUgdGFiIG9yZGVyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVGFiaW5kZXgoJGVsbSkge1xuICAkZWxtXG4gICAgLmZpbmQoJ2EsIGJ1dHRvbiwgOmlucHV0LCBbdGFiaW5kZXhdJylcbiAgICAuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVRhYmluZGV4KCRlbG0pIHtcbiAgJGVsbVxuICAgIC5maW5kKCdhLCBidXR0b24sIDppbnB1dCwgW3RhYmluZGV4XScpXG4gICAgLmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZVRhYmluZGV4OiByZW1vdmVUYWJpbmRleCxcbiAgcmVzdG9yZVRhYmluZGV4OiByZXN0b3JlVGFiaW5kZXhcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9hY2Nlc3NpYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiA3IiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2pzL2FkYXB0b3IvanF1ZXJ5Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHBzID0gcmVxdWlyZSgnLi4vbWFpbicpXG4gICwgcHNJbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9wbHVnaW4vaW5zdGFuY2VzJyk7XG5cbmZ1bmN0aW9uIG1vdW50SlF1ZXJ5KGpRdWVyeSkge1xuICBqUXVlcnkuZm4ucGVyZmVjdFNjcm9sbGJhciA9IGZ1bmN0aW9uIChzZXR0aW5nT3JDb21tYW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdPckNvbW1hbmQgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIHNldHRpbmdPckNvbW1hbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIElmIGl0J3MgYW4gb2JqZWN0IG9yIG5vbmUsIGluaXRpYWxpemUuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHNldHRpbmdPckNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKCFwc0luc3RhbmNlcy5nZXQodGhpcykpIHtcbiAgICAgICAgICBwcy5pbml0aWFsaXplKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVW5sZXNzLCBpdCBtYXkgYmUgYSBjb21tYW5kLlxuICAgICAgICB2YXIgY29tbWFuZCA9IHNldHRpbmdPckNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKGNvbW1hbmQgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgcHMudXBkYXRlKHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09ICdkZXN0cm95Jykge1xuICAgICAgICAgIHBzLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpRdWVyeSh0aGlzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gIGRlZmluZShbJ2pxdWVyeSddLCBtb3VudEpRdWVyeSk7XG59IGVsc2Uge1xuICB2YXIganEgPSB3aW5kb3cualF1ZXJ5ID8gd2luZG93LmpRdWVyeSA6IHdpbmRvdy4kO1xuICBpZiAodHlwZW9mIGpxICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vdW50SlF1ZXJ5KGpxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdW50SlF1ZXJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9hZGFwdG9yL2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZXN0cm95ID0gcmVxdWlyZSgnLi9wbHVnaW4vZGVzdHJveScpXG4gICwgaW5pdGlhbGl6ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL2luaXRpYWxpemUnKVxuICAsIHVwZGF0ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL3VwZGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIGRlc3Ryb3k6IGRlc3Ryb3lcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpLmV2ZW50LnVuYmluZEFsbCgpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclgpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclkpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhclhSYWlsKTtcbiAgZC5yZW1vdmUoaS5zY3JvbGxiYXJZUmFpbCk7XG4gIGgucmVtb3ZlUHNDbGFzc2VzKGVsZW1lbnQpO1xuXG4gIGluc3RhbmNlcy5yZW1vdmUoZWxlbWVudCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vZGVzdHJveS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3aGVlbFNwZWVkOiAxLFxuICB3aGVlbFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgc3dpcGVQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IGZhbHNlLFxuICB1c2VLZXlib2FyZDogdHJ1ZSxcbiAgc3VwcHJlc3NTY3JvbGxYOiBmYWxzZSxcbiAgc3VwcHJlc3NTY3JvbGxZOiBmYWxzZSxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2RlZmF1bHQtc2V0dGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmV2ZW50cyA9IHt9O1xufTtcblxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICB9XG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGlzSGFuZGxlclByb3ZpZGVkID0gKHR5cGVvZiBoYW5kbGVyICE9PSAndW5kZWZpbmVkJyk7XG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZpbHRlcihmdW5jdGlvbiAoaGRscikge1xuICAgIGlmIChpc0hhbmRsZXJQcm92aWRlZCAmJiBoZGxyICE9PSBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoZGxyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCB0aGlzKTtcbn07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMuZXZlbnRzKSB7XG4gICAgdGhpcy51bmJpbmQobmFtZSk7XG4gIH1cbn07XG5cbnZhciBFdmVudE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5ldmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgZWUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZXZlbnRFbGVtZW50LmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH0pWzBdO1xuICBpZiAodHlwZW9mIGVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGVlID0gbmV3IEV2ZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlZSk7XG4gIH1cbiAgcmV0dXJuIGVlO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICB0aGlzLmV2ZW50RWxlbWVudChlbGVtZW50KS5iaW5kKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCkudW5iaW5kKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHNbaV0udW5iaW5kQWxsKCk7XG4gIH1cbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBvbmNlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZWUudW5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xuICAgIGhhbmRsZXIoZSk7XG4gIH07XG4gIGVlLmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2V2ZW50LW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHM0KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKVxuICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcbiAgICAgICAgICAgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbi8vIEhhbmRsZXJzXG52YXIgY2xpY2tSYWlsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9jbGljay1yYWlsJylcbiAgLCBkcmFnU2Nyb2xsYmFySGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9kcmFnLXNjcm9sbGJhcicpXG4gICwga2V5Ym9hcmRIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL2tleWJvYXJkJylcbiAgLCBtb3VzZVdoZWVsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9tb3VzZS13aGVlbCcpXG4gICwgbmF0aXZlU2Nyb2xsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsJylcbiAgLCBzZWxlY3Rpb25IYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL3NlbGVjdGlvbicpXG4gICwgdG91Y2hIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL3RvdWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHVzZXJTZXR0aW5ncykge1xuICB1c2VyU2V0dGluZ3MgPSB0eXBlb2YgdXNlclNldHRpbmdzID09PSAnb2JqZWN0JyA/IHVzZXJTZXR0aW5ncyA6IHt9O1xuXG4gIGNscy5hZGQoZWxlbWVudCwgJ3BzLWNvbnRhaW5lcicpO1xuXG4gIC8vIENyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZS5cbiAgdmFyIGkgPSBpbnN0YW5jZXMuYWRkKGVsZW1lbnQpO1xuXG4gIGkuc2V0dGluZ3MgPSBoLmV4dGVuZChpLnNldHRpbmdzLCB1c2VyU2V0dGluZ3MpO1xuXG4gIGNsaWNrUmFpbEhhbmRsZXIoZWxlbWVudCk7XG4gIGRyYWdTY3JvbGxiYXJIYW5kbGVyKGVsZW1lbnQpO1xuICBtb3VzZVdoZWVsSGFuZGxlcihlbGVtZW50KTtcbiAgbmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50KTtcbiAgc2VsZWN0aW9uSGFuZGxlcihlbGVtZW50KTtcblxuICBpZiAoaC5lbnYuc3VwcG9ydHNUb3VjaCB8fCBoLmVudi5zdXBwb3J0c0llUG9pbnRlcikge1xuICAgIHRvdWNoSGFuZGxlcihlbGVtZW50LCBoLmVudi5zdXBwb3J0c1RvdWNoLCBoLmVudi5zdXBwb3J0c0llUG9pbnRlcik7XG4gIH1cbiAgaWYgKGkuc2V0dGluZ3MudXNlS2V5Ym9hcmQpIHtcbiAgICBrZXlib2FyZEhhbmRsZXIoZWxlbWVudCk7XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9pbml0aWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbmZ1bmN0aW9uIGJpbmRDbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgZnVuY3Rpb24gcGFnZU9mZnNldChlbCkge1xuICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gd2luZG93LkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uYmluZDtcblxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoID0gaC50b0ludChpLnNjcm9sbGJhcllIZWlnaHQgLyAyKTtcbiAgICB2YXIgcG9zaXRpb25Ub3AgPSBpLnJhaWxZUmF0aW8gKiAoZS5wYWdlWSAtIHdpbmRvdy5zY3JvbGxZIC0gcGFnZU9mZnNldChpLnNjcm9sbGJhcllSYWlsKS50b3AgLSBoYWxmT2ZTY3JvbGxiYXJMZW5ndGgpO1xuICAgIHZhciBtYXhQb3NpdGlvblRvcCA9IGkucmFpbFlSYXRpbyAqIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KTtcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uVG9wIC8gbWF4UG9zaXRpb25Ub3A7XG5cbiAgICBpZiAocG9zaXRpb25SYXRpbyA8IDApIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25SYXRpbyA+IDEpIHtcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxO1xuICAgIH1cblxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSAqIHBvc2l0aW9uUmF0aW87XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcblxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoID0gaC50b0ludChpLnNjcm9sbGJhclhXaWR0aCAvIDIpO1xuICAgIHZhciBwb3NpdGlvbkxlZnQgPSBpLnJhaWxYUmF0aW8gKiAoZS5wYWdlWCAtIHdpbmRvdy5zY3JvbGxYIC0gcGFnZU9mZnNldChpLnNjcm9sbGJhclhSYWlsKS5sZWZ0IC0gaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoKTtcbiAgICB2YXIgbWF4UG9zaXRpb25MZWZ0ID0gaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKTtcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uTGVmdCAvIG1heFBvc2l0aW9uTGVmdDtcblxuICAgIGlmIChwb3NpdGlvblJhdGlvIDwgMCkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblJhdGlvID4gMSkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDE7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkgKiBwb3NpdGlvblJhdGlvO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kQ2xpY2tSYWlsSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2NsaWNrLXJhaWwuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbmZ1bmN0aW9uIGJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgdmFyIGN1cnJlbnRMZWZ0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQYWdlWCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsTGVmdChkZWx0YVgpIHtcbiAgICB2YXIgbmV3TGVmdCA9IGN1cnJlbnRMZWZ0ICsgKGRlbHRhWCAqIGkucmFpbFhSYXRpbyk7XG4gICAgdmFyIG1heExlZnQgPSBpLnNjcm9sbGJhclhSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyAoaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSk7XG5cbiAgICBpZiAobmV3TGVmdCA8IDApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xuICAgIH0gZWxzZSBpZiAobmV3TGVmdCA+IG1heExlZnQpIHtcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBtYXhMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gbmV3TGVmdDtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGgudG9JbnQoaS5zY3JvbGxiYXJYTGVmdCAqIChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIC8gKGkuY29udGFpbmVyV2lkdGggLSAoaS5yYWlsWFJhdGlvICogaS5zY3JvbGxiYXJYV2lkdGgpKSk7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgfVxuXG4gIHZhciBtb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB1cGRhdGVTY3JvbGxMZWZ0KGUucGFnZVggLSBjdXJyZW50UGFnZVgpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBoLnN0b3BTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcbiAgICBpLmV2ZW50LnVuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgfTtcblxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBjdXJyZW50UGFnZVggPSBlLnBhZ2VYO1xuICAgIGN1cnJlbnRMZWZ0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclgsICdsZWZ0JykpICogaS5yYWlsWFJhdGlvO1xuICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcblxuICAgIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBpLmV2ZW50Lm9uY2UoaS5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsWUhhbmRsZXIoZWxlbWVudCwgaSkge1xuICB2YXIgY3VycmVudFRvcCA9IG51bGw7XG4gIHZhciBjdXJyZW50UGFnZVkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChkZWx0YVkpIHtcbiAgICB2YXIgbmV3VG9wID0gY3VycmVudFRvcCArIChkZWx0YVkgKiBpLnJhaWxZUmF0aW8pO1xuICAgIHZhciBtYXhUb3AgPSBpLnNjcm9sbGJhcllSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIChpLnJhaWxZUmF0aW8gKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkpO1xuXG4gICAgaWYgKG5ld1RvcCA8IDApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XG4gICAgfSBlbHNlIGlmIChuZXdUb3AgPiBtYXhUb3ApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IG1heFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gbmV3VG9wO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxUb3AgPSBoLnRvSW50KGkuc2Nyb2xsYmFyWVRvcCAqIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgLyAoaS5jb250YWluZXJIZWlnaHQgLSAoaS5yYWlsWVJhdGlvICogaS5zY3JvbGxiYXJZSGVpZ2h0KSkpO1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB9XG5cbiAgdmFyIG1vdXNlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHVwZGF0ZVNjcm9sbFRvcChlLnBhZ2VZIC0gY3VycmVudFBhZ2VZKTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaC5zdG9wU2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIH07XG5cbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgY3VycmVudFBhZ2VZID0gZS5wYWdlWTtcbiAgICBjdXJyZW50VG9wID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclksICd0b3AnKSkgKiBpLnJhaWxZUmF0aW87XG4gICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xuXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGkuZXZlbnQub25jZShpLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZE1vdXNlU2Nyb2xsWEhhbmRsZXIoZWxlbWVudCwgaSk7XG4gIGJpbmRNb3VzZVNjcm9sbFlIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvZHJhZy1zY3JvbGxiYXIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKTtcblxuZnVuY3Rpb24gYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBob3ZlcmVkID0gZmFsc2U7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBob3ZlcmVkID0gdHJ1ZTtcbiAgfSk7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBob3ZlcmVkID0gZmFsc2U7XG4gIH0pO1xuXG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGlmIChkZWx0YVggPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApIHx8IChzY3JvbGxUb3AgPj0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgaWYgKGRlbHRhWSA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhclhBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApIHx8IChzY3JvbGxMZWZ0ID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCAmJiBkZWx0YVggPiAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkICYmIGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhvdmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogaS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIC8vIGdvIGRlZXBlciBpZiBlbGVtZW50IGlzIGEgd2ViY29tcG9uZW50XG4gICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGlmIChoLmlzRWRpdGFibGUoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWx0YVggPSAwO1xuICAgIHZhciBkZWx0YVkgPSAwO1xuXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgY2FzZSAzNzogLy8gbGVmdFxuICAgICAgZGVsdGFYID0gLTMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzODogLy8gdXBcbiAgICAgIGRlbHRhWSA9IDMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOTogLy8gcmlnaHRcbiAgICAgIGRlbHRhWCA9IDMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0MDogLy8gZG93blxuICAgICAgZGVsdGFZID0gLTMwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzMzogLy8gcGFnZSB1cFxuICAgICAgZGVsdGFZID0gOTA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDMyOiAvLyBzcGFjZSBiYXJcbiAgICBjYXNlIDM0OiAvLyBwYWdlIGRvd25cbiAgICAgIGRlbHRhWSA9IC05MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzU6IC8vIGVuZFxuICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICBkZWx0YVkgPSAtaS5jb250ZW50SGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzNjogLy8gaG9tZVxuICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICBkZWx0YVkgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhWSA9IGkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gZGVsdGFZO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCArIGRlbHRhWDtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICAgIHNob3VsZFByZXZlbnQgPSBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2tleWJvYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XG5cbmZ1bmN0aW9uIGJpbmRNb3VzZVdoZWVsSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgaWYgKGRlbHRhWCA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhcllBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHwgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBpZiAoZGVsdGFZID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHwgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbHRhRnJvbUV2ZW50KGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgdmFyIGRlbHRhWSA9IC0xICogZS5kZWx0YVk7XG5cbiAgICBpZiAodHlwZW9mIGRlbHRhWCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZGVsdGFZID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBPUyBYIFNhZmFyaVxuICAgICAgZGVsdGFYID0gLTEgKiBlLndoZWVsRGVsdGFYIC8gNjtcbiAgICAgIGRlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyA2O1xuICAgIH1cblxuICAgIGlmIChlLmRlbHRhTW9kZSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkge1xuICAgICAgLy8gRmlyZWZveCBpbiBkZWx0YU1vZGUgMTogTGluZSBzY3JvbGxpbmdcbiAgICAgIGRlbHRhWCAqPSAxMDtcbiAgICAgIGRlbHRhWSAqPSAxMDtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFYICE9PSBkZWx0YVggJiYgZGVsdGFZICE9PSBkZWx0YVkvKiBOYU4gY2hlY2tzICovKSB7XG4gICAgICAvLyBJRSBpbiBzb21lIG1vdXNlIGRyaXZlcnNcbiAgICAgIGRlbHRhWCA9IDA7XG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCZUNvbnN1bWVkQnlUZXh0YXJlYShkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBob3ZlcmVkVGV4dGFyZWEgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhOmhvdmVyJyk7XG4gICAgaWYgKGhvdmVyZWRUZXh0YXJlYSkge1xuICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxIZWlnaHQgLSBob3ZlcmVkVGV4dGFyZWEuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKG1heFNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgaWYgKCEoaG92ZXJlZFRleHRhcmVhLnNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSAmJlxuICAgICAgICAgICAgIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsVG9wID09PSBtYXhTY3JvbGxUb3AgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1heFNjcm9sbExlZnQgPSBob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCAtIGhvdmVyZWRUZXh0YXJlYS5jbGllbnRXaWR0aDtcbiAgICAgIGlmIChtYXhTY3JvbGxMZWZ0ID4gMCkge1xuICAgICAgICBpZiAoIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSAmJlxuICAgICAgICAgICAgIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCA9PT0gbWF4U2Nyb2xsTGVmdCAmJiBkZWx0YVggPiAwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNld2hlZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHF1aWNrIGZpeCBmb3IgdGhlIHNlbGVjdCBwcm9ibGVtIGluIEZGIGFuZCBJRS5cbiAgICAvLyBJZiB0aGVyZSBjb21lcyBhbiBlZmZlY3RpdmUgd2F5IHRvIGRlYWwgd2l0aCB0aGUgcHJvYmxlbSxcbiAgICAvLyB0aGlzIGxpbmVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgIGlmICghaC5lbnYuaXNXZWJLaXQgJiYgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzZWxlY3Q6Zm9jdXMnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IGdldERlbHRhRnJvbUV2ZW50KGUpO1xuXG4gICAgdmFyIGRlbHRhWCA9IGRlbHRhWzBdO1xuICAgIHZhciBkZWx0YVkgPSBkZWx0YVsxXTtcblxuICAgIGlmIChzaG91bGRCZUNvbnN1bWVkQnlUZXh0YXJlYShkZWx0YVgsIGRlbHRhWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMpIHtcbiAgICAgIC8vIGRlbHRhWCB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYW5kIGRlbHRhWSB3aWxsXG4gICAgICAvLyBvbmx5IGJlIHVzZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyAtIHRoaXMgaXMgdGhlIGRlZmF1bHRcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3AgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKTtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpO1xuICAgIH0gZWxzZSBpZiAoaS5zY3JvbGxiYXJZQWN0aXZlICYmICFpLnNjcm9sbGJhclhBY3RpdmUpIHtcbiAgICAgIC8vIG9ubHkgdmVydGljYWwgc2Nyb2xsYmFyIGlzIGFjdGl2ZSBhbmQgdXNlQm90aFdoZWVsQXhlcyBvcHRpb24gaXNcbiAgICAgIC8vIGFjdGl2ZSwgc28gbGV0J3Mgc2Nyb2xsIHZlcnRpY2FsIGJhciB1c2luZyBib3RoIG1vdXNlIHdoZWVsIGF4ZXNcbiAgICAgIGlmIChkZWx0YVkpIHtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhclhBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgLy8gdXNlQm90aFdoZWVsQXhlcyBhbmQgb25seSBob3Jpem9udGFsIGJhciBpcyBhY3RpdmUsIHNvIHVzZSBib3RoXG4gICAgICAvLyB3aGVlbCBheGVzIGZvciBob3Jpem9udGFsIGJhclxuICAgICAgaWYgKGRlbHRhWCkge1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gKHNob3VsZFByZXZlbnQgfHwgc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpKTtcbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5vbndoZWVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZE1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvbW91c2Utd2hlZWwuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG5mdW5jdGlvbiBiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmROYXRpdmVTY3JvbGxIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvbmF0aXZlLXNjcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA4IDkgMTAgMTEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG5mdW5jdGlvbiBiaW5kU2VsZWN0aW9uSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIGZ1bmN0aW9uIGdldFJhbmdlTm9kZSgpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSA6XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldFNlbGVjdGlvbiA/IGRvY3VtZW50LmdldFNlbGVjdGlvbigpIDogJyc7XG4gICAgaWYgKHNlbGVjdGlvbi50b1N0cmluZygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2Nyb2xsaW5nTG9vcCA9IG51bGw7XG4gIHZhciBzY3JvbGxEaWZmID0ge3RvcDogMCwgbGVmdDogMH07XG4gIGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgIGlmICghc2Nyb2xsaW5nTG9vcCkge1xuICAgICAgc2Nyb2xsaW5nTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsRGlmZi50b3A7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCArIHNjcm9sbERpZmYubGVmdDtcbiAgICAgICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gICAgICB9LCA1MCk7IC8vIGV2ZXJ5IC4xIHNlY1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wU2Nyb2xsaW5nKCkge1xuICAgIGlmIChzY3JvbGxpbmdMb29wKSB7XG4gICAgICBjbGVhckludGVydmFsKHNjcm9sbGluZ0xvb3ApO1xuICAgICAgc2Nyb2xsaW5nTG9vcCA9IG51bGw7XG4gICAgfVxuICAgIGguc3RvcFNjcm9sbGluZyhlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBpc1NlbGVjdGVkID0gZmFsc2U7XG4gIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZ2V0UmFuZ2VOb2RlKCkpKSB7XG4gICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgc3RvcFNjcm9sbGluZygpO1xuICAgIH1cbiAgfSk7XG4gIGkuZXZlbnQuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICBzdG9wU2Nyb2xsaW5nKCk7XG4gICAgfVxuICB9KTtcblxuICBpLmV2ZW50LmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB7eDogZS5wYWdlWCwgeTogZS5wYWdlWX07XG4gICAgICB2YXIgY29udGFpbmVyR2VvbWV0cnkgPSB7XG4gICAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICAgICAgcmlnaHQ6IGVsZW1lbnQub2Zmc2V0TGVmdCArIGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICAgIGJvdHRvbTogZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodFxuICAgICAgfTtcblxuICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueCA8IGNvbnRhaW5lckdlb21ldHJ5LmxlZnQgKyAzKSB7XG4gICAgICAgIHNjcm9sbERpZmYubGVmdCA9IC01O1xuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlUG9zaXRpb24ueCA+IGNvbnRhaW5lckdlb21ldHJ5LnJpZ2h0IC0gMykge1xuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSA1O1xuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW91c2VQb3NpdGlvbi55IDwgY29udGFpbmVyR2VvbWV0cnkudG9wICsgMykge1xuICAgICAgICBpZiAoY29udGFpbmVyR2VvbWV0cnkudG9wICsgMyAtIG1vdXNlUG9zaXRpb24ueSA8IDUpIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IC01O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gLTIwO1xuICAgICAgICB9XG4gICAgICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcbiAgICAgIH0gZWxzZSBpZiAobW91c2VQb3NpdGlvbi55ID4gY29udGFpbmVyR2VvbWV0cnkuYm90dG9tIC0gMykge1xuICAgICAgICBpZiAobW91c2VQb3NpdGlvbi55IC0gY29udGFpbmVyR2VvbWV0cnkuYm90dG9tICsgMyA8IDUpIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAyMDtcbiAgICAgICAgfVxuICAgICAgICBoLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxEaWZmLnRvcCA9PT0gMCAmJiBzY3JvbGxEaWZmLmxlZnQgPT09IDApIHtcbiAgICAgICAgc3RvcFNjcm9sbGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZFNlbGVjdGlvbkhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9zZWxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG5mdW5jdGlvbiBiaW5kVG91Y2hIYW5kbGVyKGVsZW1lbnQsIGksIHN1cHBvcnRzVG91Y2gsIHN1cHBvcnRzSWVQb2ludGVyKSB7XG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIHZhciBtYWduaXR1ZGVYID0gTWF0aC5hYnMoZGVsdGFYKTtcbiAgICB2YXIgbWFnbml0dWRlWSA9IE1hdGguYWJzKGRlbHRhWSk7XG5cbiAgICBpZiAobWFnbml0dWRlWSA+IG1hZ25pdHVkZVgpIHtcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgdXAvZG93biB0aGUgcGFnZVxuXG4gICAgICBpZiAoKChkZWx0YVkgPCAwKSAmJiAoc2Nyb2xsVG9wID09PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkpIHx8XG4gICAgICAgICAgKChkZWx0YVkgPiAwKSAmJiAoc2Nyb2xsVG9wID09PSAwKSkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYWduaXR1ZGVYID4gbWFnbml0dWRlWSkge1xuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSBsZWZ0L3JpZ2h0IGFjcm9zcyB0aGUgcGFnZVxuXG4gICAgICBpZiAoKChkZWx0YVggPCAwKSAmJiAoc2Nyb2xsTGVmdCA9PT0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSkgfHxcbiAgICAgICAgICAoKGRlbHRhWCA+IDApICYmIChzY3JvbGxMZWZ0ID09PSAwKSkpIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gZGlmZmVyZW5jZVk7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0IC0gZGlmZmVyZW5jZVg7XG5cbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBzdGFydE9mZnNldCA9IHt9O1xuICB2YXIgc3RhcnRUaW1lID0gMDtcbiAgdmFyIHNwZWVkID0ge307XG4gIHZhciBlYXNpbmdMb29wID0gbnVsbDtcbiAgdmFyIGluR2xvYmFsVG91Y2ggPSBmYWxzZTtcbiAgdmFyIGluTG9jYWxUb3VjaCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGdsb2JhbFRvdWNoU3RhcnQoKSB7XG4gICAgaW5HbG9iYWxUb3VjaCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZ2xvYmFsVG91Y2hFbmQoKSB7XG4gICAgaW5HbG9iYWxUb3VjaCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2goZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1heWJlIElFIHBvaW50ZXJcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzaG91bGRIYW5kbGUoZSkge1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlLnBvaW50ZXJUeXBlICYmIGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB0b3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICBpbkxvY2FsVG91Y2ggPSB0cnVlO1xuXG4gICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaChlKTtcblxuICAgICAgc3RhcnRPZmZzZXQucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHN0YXJ0T2Zmc2V0LnBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgIGlmIChlYXNpbmdMb29wICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICB9XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoTW92ZShlKSB7XG4gICAgaWYgKCFpbkdsb2JhbFRvdWNoICYmIGluTG9jYWxUb3VjaCAmJiBzaG91bGRIYW5kbGUoZSkpIHtcbiAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoKGUpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHtwYWdlWDogdG91Y2gucGFnZVgsIHBhZ2VZOiB0b3VjaC5wYWdlWX07XG5cbiAgICAgIHZhciBkaWZmZXJlbmNlWCA9IGN1cnJlbnRPZmZzZXQucGFnZVggLSBzdGFydE9mZnNldC5wYWdlWDtcbiAgICAgIHZhciBkaWZmZXJlbmNlWSA9IGN1cnJlbnRPZmZzZXQucGFnZVkgLSBzdGFydE9mZnNldC5wYWdlWTtcblxuICAgICAgYXBwbHlUb3VjaE1vdmUoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gY3VycmVudE9mZnNldDtcblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgdmFyIHRpbWVHYXAgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIGlmICh0aW1lR2FwID4gMCkge1xuICAgICAgICBzcGVlZC54ID0gZGlmZmVyZW5jZVggLyB0aW1lR2FwO1xuICAgICAgICBzcGVlZC55ID0gZGlmZmVyZW5jZVkgLyB0aW1lR2FwO1xuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFByZXZlbnREZWZhdWx0KGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEVuZCgpIHtcbiAgICBpZiAoIWluR2xvYmFsVG91Y2ggJiYgaW5Mb2NhbFRvdWNoKSB7XG4gICAgICBpbkxvY2FsVG91Y2ggPSBmYWxzZTtcblxuICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgIGVhc2luZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VzLmdldChlbGVtZW50KSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkLngpIDwgMC4wMSAmJiBNYXRoLmFicyhzcGVlZC55KSA8IDAuMDEpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5VG91Y2hNb3ZlKHNwZWVkLnggKiAzMCwgc3BlZWQueSAqIDMwKTtcblxuICAgICAgICBzcGVlZC54ICo9IDAuODtcbiAgICAgICAgc3BlZWQueSAqPSAwLjg7XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnRzVG91Y2gpIHtcbiAgICBpLmV2ZW50LmJpbmQod2luZG93LCAndG91Y2hzdGFydCcsIGdsb2JhbFRvdWNoU3RhcnQpO1xuICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGdsb2JhbFRvdWNoRW5kKTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0KTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c0llUG9pbnRlcikge1xuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAncG9pbnRlcmRvd24nLCBnbG9iYWxUb3VjaFN0YXJ0KTtcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdwb2ludGVydXAnLCBnbG9iYWxUb3VjaEVuZCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJkb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJtb3ZlJywgdG91Y2hNb3ZlKTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcnVwJywgdG91Y2hFbmQpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAnTVNQb2ludGVyRG93bicsIGdsb2JhbFRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ01TUG9pbnRlclVwJywgZ2xvYmFsVG91Y2hFbmQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJEb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlck1vdmUnLCB0b3VjaE1vdmUpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJVcCcsIHRvdWNoRW5kKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3VwcG9ydHNUb3VjaCwgc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kVG91Y2hIYW5kbGVyKGVsZW1lbnQsIGksIHN1cHBvcnRzVG91Y2gsIHN1cHBvcnRzSWVQb2ludGVyKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL3RvdWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDggOSAxMCAxMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi91cGRhdGUtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG5cbiAgLy8gUmVjYWxjdWxhdGUgcmFpbCBtYXJnaW5zXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIGkucmFpbFhNYXJnaW5XaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpbkxlZnQnKSkgKyBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5SaWdodCcpKTtcbiAgaS5yYWlsWU1hcmdpbkhlaWdodCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpblRvcCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpbkJvdHRvbScpKTtcblxuICAvLyBIaWRlIHNjcm9sbGJhcnMgbm90IHRvIGFmZmVjdCBzY3JvbGxXaWR0aCBhbmQgc2Nyb2xsSGVpZ2h0XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJycpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi91cGRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgOCA5IDEwIDExIiwiLyohXG4gKiB0eXBlYWhlYWQuanMgMC4xMS4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdpdHRlci90eXBlYWhlYWQuanNcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgVHdpdHRlciwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVRcbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJ0eXBlYWhlYWQuanNcIiwgWyBcImpxdWVyeVwiIF0sIGZ1bmN0aW9uKGEwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShhMCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbigkKSB7XG4gICAgdmFyIF8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc01zaWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID8gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKG1zaWUgfHJ2OikoXFxkKyguXFxkKyk/KS9pKVsyXSA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQmxhbmtTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3RyIHx8IC9eXFxzKiQvLnRlc3Qoc3RyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlc2NhcGVSZWdFeENoYXJzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXJyYXk6ICQuaXNBcnJheSxcbiAgICAgICAgICAgIGlzRnVuY3Rpb246ICQuaXNGdW5jdGlvbixcbiAgICAgICAgICAgIGlzT2JqZWN0OiAkLmlzUGxhaW5PYmplY3QsXG4gICAgICAgICAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFbGVtZW50OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNKUXVlcnk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyOiBmdW5jdGlvbiB0b1N0cihzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQocykgfHwgcyA9PT0gbnVsbCA/IFwiXCIgOiBzICsgXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiaW5kOiAkLnByb3h5LFxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24oY29sbGVjdGlvbiwgY2IpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goY29sbGVjdGlvbiwgcmV2ZXJzZUFyZ3MpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJldmVyc2VBcmdzKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwOiAkLm1hcCxcbiAgICAgICAgICAgIGZpbHRlcjogJC5ncmVwLFxuICAgICAgICAgICAgZXZlcnk6IGZ1bmN0aW9uKG9iaiwgdGVzdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3VsdCA9IHRlc3QuY2FsbChudWxsLCB2YWwsIGtleSwgb2JqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb21lOiBmdW5jdGlvbihvYmosIHRlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9IHRlc3QuY2FsbChudWxsLCB2YWwsIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1peGluOiAkLmV4dGVuZCxcbiAgICAgICAgICAgIGlkZW50aXR5OiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJZEdlbmVyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRpZnk6IGZ1bmN0aW9uIHRlbXBsYXRpZnkob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuaXNGdW5jdGlvbihvYmopID8gb2JqIDogdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2U6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHMsIGxhdGVyLCBjYWxsTm93O1xuICAgICAgICAgICAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCwgYXJncywgdGltZW91dCwgcmVzdWx0LCBwcmV2aW91cywgbGF0ZXI7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgICAgICAgICAgIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmlzU3RyaW5nKHZhbCkgPyB2YWwgOiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vb3A6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfTtcbiAgICB9KCk7XG4gICAgdmFyIFdXVyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGRlZmF1bHRDbGFzc05hbWVzID0ge1xuICAgICAgICAgICAgd3JhcHBlcjogXCJ0d2l0dGVyLXR5cGVhaGVhZFwiLFxuICAgICAgICAgICAgaW5wdXQ6IFwidHQtaW5wdXRcIixcbiAgICAgICAgICAgIGhpbnQ6IFwidHQtaGludFwiLFxuICAgICAgICAgICAgbWVudTogXCJ0dC1tZW51XCIsXG4gICAgICAgICAgICBkYXRhc2V0OiBcInR0LWRhdGFzZXRcIixcbiAgICAgICAgICAgIHN1Z2dlc3Rpb246IFwidHQtc3VnZ2VzdGlvblwiLFxuICAgICAgICAgICAgc2VsZWN0YWJsZTogXCJ0dC1zZWxlY3RhYmxlXCIsXG4gICAgICAgICAgICBlbXB0eTogXCJ0dC1lbXB0eVwiLFxuICAgICAgICAgICAgb3BlbjogXCJ0dC1vcGVuXCIsXG4gICAgICAgICAgICBjdXJzb3I6IFwidHQtY3Vyc29yXCIsXG4gICAgICAgICAgICBoaWdobGlnaHQ6IFwidHQtaGlnaGxpZ2h0XCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgICBmdW5jdGlvbiBidWlsZChvKSB7XG4gICAgICAgICAgICB2YXIgd3d3LCBjbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3NlcyA9IF8ubWl4aW4oe30sIGRlZmF1bHRDbGFzc05hbWVzLCBvKTtcbiAgICAgICAgICAgIHd3dyA9IHtcbiAgICAgICAgICAgICAgICBjc3M6IGJ1aWxkQ3NzKCksXG4gICAgICAgICAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgICAgICAgICBodG1sOiBidWlsZEh0bWwoY2xhc3NlcyksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBidWlsZFNlbGVjdG9ycyhjbGFzc2VzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3NzOiB3d3cuY3NzLFxuICAgICAgICAgICAgICAgIGh0bWw6IHd3dy5odG1sLFxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IHd3dy5jbGFzc2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczogd3d3LnNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgICBtaXhpbjogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICBfLm1peGluKG8sIHd3dyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZEh0bWwoYykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyOiAnPHNwYW4gY2xhc3M9XCInICsgYy53cmFwcGVyICsgJ1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgIG1lbnU6ICc8ZGl2IGNsYXNzPVwiJyArIGMubWVudSArICdcIj48L2Rpdj4nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3JzKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChjbGFzc2VzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzW2tdID0gXCIuXCIgKyB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkQ3NzKCkge1xuICAgICAgICAgICAgdmFyIGNzcyA9IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRXaXRoTm9IaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogXCIxMDBcIixcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGx0cjoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGw6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcIiAwXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKF8uaXNNc2llKCkpIHtcbiAgICAgICAgICAgICAgICBfLm1peGluKGNzcy5pbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNylcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgRXZlbnRCdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBuYW1lc3BhY2UsIGRlcHJlY2F0aW9uTWFwO1xuICAgICAgICBuYW1lc3BhY2UgPSBcInR5cGVhaGVhZDpcIjtcbiAgICAgICAgZGVwcmVjYXRpb25NYXAgPSB7XG4gICAgICAgICAgICByZW5kZXI6IFwicmVuZGVyZWRcIixcbiAgICAgICAgICAgIGN1cnNvcmNoYW5nZTogXCJjdXJzb3JjaGFuZ2VkXCIsXG4gICAgICAgICAgICBzZWxlY3Q6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogXCJhdXRvY29tcGxldGVkXCJcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRCdXMobykge1xuICAgICAgICAgICAgaWYgKCFvIHx8ICFvLmVsKSB7XG4gICAgICAgICAgICAgICAgJC5lcnJvcihcIkV2ZW50QnVzIGluaXRpYWxpemVkIHdpdGhvdXQgZWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRlbCA9ICQoby5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5taXhpbihFdmVudEJ1cy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIF90cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyICRlO1xuICAgICAgICAgICAgICAgICRlID0gJC5FdmVudChuYW1lc3BhY2UgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICAoYXJncyA9IGFyZ3MgfHwgW10pLnVuc2hpZnQoJGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLnRyaWdnZXIuYXBwbHkodGhpcy4kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncywgJGU7XG4gICAgICAgICAgICAgICAgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAkZSA9IHRoaXMuX3RyaWdnZXIoXCJiZWZvcmVcIiArIHR5cGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHJlY2F0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIodHlwZSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwcmVjYXRlZFR5cGUgPSBkZXByZWNhdGlvbk1hcFt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKGRlcHJlY2F0ZWRUeXBlLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFdmVudEJ1cztcbiAgICB9KCk7XG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHNwbGl0dGVyID0gL1xccysvLCBuZXh0VGljayA9IGdldE5leHRUaWNrKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblN5bmM6IG9uU3luYyxcbiAgICAgICAgICAgIG9uQXN5bmM6IG9uQXN5bmMsXG4gICAgICAgICAgICBvZmY6IG9mZixcbiAgICAgICAgICAgIHRyaWdnZXI6IHRyaWdnZXJcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gb24obWV0aG9kLCB0eXBlcywgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcy5zcGxpdChzcGxpdHRlcik7XG4gICAgICAgICAgICBjYiA9IGNvbnRleHQgPyBiaW5kQ29udGV4dChjYiwgY29udGV4dCkgOiBjYjtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlID0gdHlwZXMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9IHRoaXMuX2NhbGxiYWNrc1t0eXBlXSB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1t0eXBlXVttZXRob2RdLnB1c2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Bc3luYyh0eXBlcywgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvbi5jYWxsKHRoaXMsIFwiYXN5bmNcIiwgdHlwZXMsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblN5bmModHlwZXMsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gb24uY2FsbCh0aGlzLCBcInN5bmNcIiwgdHlwZXMsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvZmYodHlwZXMpIHtcbiAgICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzID0gdHlwZXMuc3BsaXQoc3BsaXR0ZXIpO1xuICAgICAgICAgICAgd2hpbGUgKHR5cGUgPSB0eXBlcy5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXIodHlwZXMpIHtcbiAgICAgICAgICAgIHZhciB0eXBlLCBjYWxsYmFja3MsIGFyZ3MsIHN5bmNGbHVzaCwgYXN5bmNGbHVzaDtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzLnNwbGl0KHNwbGl0dGVyKTtcbiAgICAgICAgICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB3aGlsZSAoKHR5cGUgPSB0eXBlcy5zaGlmdCgpKSAmJiAoY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW3R5cGVdKSkge1xuICAgICAgICAgICAgICAgIHN5bmNGbHVzaCA9IGdldEZsdXNoKGNhbGxiYWNrcy5zeW5jLCB0aGlzLCBbIHR5cGUgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIGFzeW5jRmx1c2ggPSBnZXRGbHVzaChjYWxsYmFja3MuYXN5bmMsIHRoaXMsIFsgdHlwZSBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgc3luY0ZsdXNoKCkgJiYgbmV4dFRpY2soYXN5bmNGbHVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRGbHVzaChjYWxsYmFja3MsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVzaDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7ICFjYW5jZWxsZWQgJiYgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0LCBhcmdzKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhY2FuY2VsbGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRUaWNrKCkge1xuICAgICAgICAgICAgdmFyIG5leHRUaWNrRm47XG4gICAgICAgICAgICBpZiAod2luZG93LnNldEltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIG5leHRUaWNrRm4gPSBmdW5jdGlvbiBuZXh0VGlja1NldEltbWVkaWF0ZShmbikge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0VGlja0ZuID0gZnVuY3Rpb24gbmV4dFRpY2tTZXRUaW1lb3V0KGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrRm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmluZENvbnRleHQoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5iaW5kID8gZm4uYmluZChjb250ZXh0KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBoaWdobGlnaHQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJzdHJvbmdcIixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICAgICAgICAgIHdvcmRzT25seTogZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGlnaHRsaWdodChvKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXg7XG4gICAgICAgICAgICBvID0gXy5taXhpbih7fSwgZGVmYXVsdHMsIG8pO1xuICAgICAgICAgICAgaWYgKCFvLm5vZGUgfHwgIW8ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8ucGF0dGVybiA9IF8uaXNBcnJheShvLnBhdHRlcm4pID8gby5wYXR0ZXJuIDogWyBvLnBhdHRlcm4gXTtcbiAgICAgICAgICAgIHJlZ2V4ID0gZ2V0UmVnZXgoby5wYXR0ZXJuLCBvLmNhc2VTZW5zaXRpdmUsIG8ud29yZHNPbmx5KTtcbiAgICAgICAgICAgIHRyYXZlcnNlKG8ubm9kZSwgaGlnaHRsaWdodFRleHROb2RlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZ2h0bGlnaHRUZXh0Tm9kZSh0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCwgcGF0dGVybk5vZGUsIHdyYXBwZXJOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IHJlZ2V4LmV4ZWModGV4dE5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlck5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChvLnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBvLmNsYXNzTmFtZSAmJiAod3JhcHBlck5vZGUuY2xhc3NOYW1lID0gby5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuTm9kZSA9IHRleHROb2RlLnNwbGl0VGV4dChtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5Ob2RlLnNwbGl0VGV4dChtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyTm9kZS5hcHBlbmRDaGlsZChwYXR0ZXJuTm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh3cmFwcGVyTm9kZSwgcGF0dGVybk5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISFtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlKGVsLCBoaWdodGxpZ2h0VGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlLCBURVhUX05PREVfVFlQRSA9IDM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVsLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGhpZ2h0bGlnaHRUZXh0Tm9kZShjaGlsZE5vZGUpID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShjaGlsZE5vZGUsIGhpZ2h0bGlnaHRUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldFJlZ2V4KHBhdHRlcm5zLCBjYXNlU2Vuc2l0aXZlLCB3b3Jkc09ubHkpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGVkUGF0dGVybnMgPSBbXSwgcmVnZXhTdHI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkUGF0dGVybnMucHVzaChfLmVzY2FwZVJlZ0V4Q2hhcnMocGF0dGVybnNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2V4U3RyID0gd29yZHNPbmx5ID8gXCJcXFxcYihcIiArIGVzY2FwZWRQYXR0ZXJucy5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIgOiBcIihcIiArIGVzY2FwZWRQYXR0ZXJucy5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIGNhc2VTZW5zaXRpdmUgPyBuZXcgUmVnRXhwKHJlZ2V4U3RyKSA6IG5ldyBSZWdFeHAocmVnZXhTdHIsIFwiaVwiKTtcbiAgICAgICAgfVxuICAgIH0od2luZG93LmRvY3VtZW50KTtcbiAgICB2YXIgSW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBzcGVjaWFsS2V5Q29kZU1hcDtcbiAgICAgICAgc3BlY2lhbEtleUNvZGVNYXAgPSB7XG4gICAgICAgICAgICA5OiBcInRhYlwiLFxuICAgICAgICAgICAgMjc6IFwiZXNjXCIsXG4gICAgICAgICAgICAzNzogXCJsZWZ0XCIsXG4gICAgICAgICAgICAzOTogXCJyaWdodFwiLFxuICAgICAgICAgICAgMTM6IFwiZW50ZXJcIixcbiAgICAgICAgICAgIDM4OiBcInVwXCIsXG4gICAgICAgICAgICA0MDogXCJkb3duXCJcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gSW5wdXQobywgd3d3KSB7XG4gICAgICAgICAgICBvID0gbyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJpbnB1dCBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3d3Lm1peGluKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kaGludCA9ICQoby5oaW50KTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gJChvLmlucHV0KTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlXaGVuRm9jdXNlZCA9IHRoaXMuaGFzRm9jdXMoKSA/IHRoaXMucXVlcnkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy4kb3ZlcmZsb3dIZWxwZXIgPSBidWlsZE92ZXJmbG93SGVscGVyKHRoaXMuJGlucHV0KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTGFuZ3VhZ2VEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRoaW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGludCA9IHRoaXMuZ2V0SGludCA9IHRoaXMuY2xlYXJIaW50ID0gdGhpcy5jbGVhckhpbnRJZkludmFsaWQgPSBfLm5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSW5wdXQubm9ybWFsaXplUXVlcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBfLnRvU3RyKHN0cikucmVwbGFjZSgvXlxccyovZywgXCJcIikucmVwbGFjZSgvXFxzezIsfS9nLCBcIiBcIik7XG4gICAgICAgIH07XG4gICAgICAgIF8ubWl4aW4oSW5wdXQucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIF9vbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImJsdXJyZWRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeVdoZW5Gb2N1c2VkID0gdGhpcy5xdWVyeTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJmb2N1c2VkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bigkZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlOYW1lID0gc3BlY2lhbEtleUNvZGVNYXBbJGUud2hpY2ggfHwgJGUua2V5Q29kZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlUHJldmVudERlZmF1bHQoa2V5TmFtZSwgJGUpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lICYmIHRoaXMuX3Nob3VsZFRyaWdnZXIoa2V5TmFtZSwgJGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihrZXlOYW1lICsgXCJLZXllZFwiLCAkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbklucHV0OiBmdW5jdGlvbiBvbklucHV0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFF1ZXJ5KHRoaXMuZ2V0SW5wdXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySGludElmSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrTGFuZ3VhZ2VEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWFuYWdlUHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIG1hbmFnZVByZXZlbnREZWZhdWx0KGtleU5hbWUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9ICF3aXRoTW9kaWZpZXIoJGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgJiYgJGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkVHJpZ2dlcjogZnVuY3Rpb24gc2hvdWxkVHJpZ2dlcihrZXlOYW1lLCAkZSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmlnZ2VyO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhYlwiOlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyID0gIXdpdGhNb2RpZmllcigkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NoZWNrTGFuZ3VhZ2VEaXJlY3Rpb246IGZ1bmN0aW9uIGNoZWNrTGFuZ3VhZ2VEaXJlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9ICh0aGlzLiRpbnB1dC5jc3MoXCJkaXJlY3Rpb25cIikgfHwgXCJsdHJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXIgIT09IGRpcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaGludC5hdHRyKFwiZGlyXCIsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImxhbmdEaXJDaGFuZ2VkXCIsIGRpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXRRdWVyeTogZnVuY3Rpb24gc2V0UXVlcnkodmFsLCBzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJlRXF1aXZhbGVudCwgaGFzRGlmZmVyZW50V2hpdGVzcGFjZTtcbiAgICAgICAgICAgICAgICBhcmVFcXVpdmFsZW50ID0gYXJlUXVlcmllc0VxdWl2YWxlbnQodmFsLCB0aGlzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBoYXNEaWZmZXJlbnRXaGl0ZXNwYWNlID0gYXJlRXF1aXZhbGVudCA/IHRoaXMucXVlcnkubGVuZ3RoICE9PSB2YWwubGVuZ3RoIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiAhYXJlRXF1aXZhbGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJxdWVyeUNoYW5nZWRcIiwgdGhpcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc2lsZW50ICYmIGhhc0RpZmZlcmVudFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwid2hpdGVzcGFjZUNoYW5nZWRcIiwgdGhpcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgb25CbHVyLCBvbkZvY3VzLCBvbktleWRvd24sIG9uSW5wdXQ7XG4gICAgICAgICAgICAgICAgb25CbHVyID0gXy5iaW5kKHRoaXMuX29uQmx1ciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgb25Gb2N1cyA9IF8uYmluZCh0aGlzLl9vbkZvY3VzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBvbktleWRvd24gPSBfLmJpbmQodGhpcy5fb25LZXlkb3duLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBvbklucHV0ID0gXy5iaW5kKHRoaXMuX29uSW5wdXQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKFwiYmx1ci50dFwiLCBvbkJsdXIpLm9uKFwiZm9jdXMudHRcIiwgb25Gb2N1cykub24oXCJrZXlkb3duLnR0XCIsIG9uS2V5ZG93bik7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzTXNpZSgpIHx8IF8uaXNNc2llKCkgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKFwiaW5wdXQudHRcIiwgb25JbnB1dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oXCJrZXlkb3duLnR0IGtleXByZXNzLnR0IGN1dC50dCBwYXN0ZS50dFwiLCBmdW5jdGlvbigkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXlDb2RlTWFwWyRlLndoaWNoIHx8ICRlLmtleUNvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5kZWZlcihfLmJpbmQodGhhdC5fb25JbnB1dCwgdGhhdCwgJGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldExhbmdEaXI6IGZ1bmN0aW9uIGdldExhbmdEaXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFF1ZXJ5OiBmdW5jdGlvbiBnZXRRdWVyeSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSB8fCBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFF1ZXJ5OiBmdW5jdGlvbiBzZXRRdWVyeSh2YWwsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh2YWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFF1ZXJ5KHZhbCwgc2lsZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNRdWVyeUNoYW5nZWRTaW5jZUxhc3RGb2N1czogZnVuY3Rpb24gaGFzUXVlcnlDaGFuZ2VkU2luY2VMYXN0Rm9jdXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnkgIT09IHRoaXMucXVlcnlXaGVuRm9jdXNlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBnZXRJbnB1dFZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySGludElmSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrTGFuZ3VhZ2VEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldElucHV0VmFsdWU6IGZ1bmN0aW9uIHJlc2V0SW5wdXRWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUodGhpcy5xdWVyeSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SGludDogZnVuY3Rpb24gZ2V0SGludCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGludC52YWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRIaW50OiBmdW5jdGlvbiBzZXRIaW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGludC52YWwodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFySGludDogZnVuY3Rpb24gY2xlYXJIaW50KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGludChcIlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckhpbnRJZkludmFsaWQ6IGZ1bmN0aW9uIGNsZWFySGludElmSW52YWxpZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsLCBoaW50LCB2YWxJc1ByZWZpeE9mSGludCwgaXNWYWxpZDtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBoaW50ID0gdGhpcy5nZXRIaW50KCk7XG4gICAgICAgICAgICAgICAgdmFsSXNQcmVmaXhPZkhpbnQgPSB2YWwgIT09IGhpbnQgJiYgaGludC5pbmRleE9mKHZhbCkgPT09IDA7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCAhPT0gXCJcIiAmJiB2YWxJc1ByZWZpeE9mSGludCAmJiAhdGhpcy5oYXNPdmVyZmxvdygpO1xuICAgICAgICAgICAgICAgICFpc1ZhbGlkICYmIHRoaXMuY2xlYXJIaW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzRm9jdXM6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC5pcyhcIjpmb2N1c1wiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNPdmVyZmxvdzogZnVuY3Rpb24gaGFzT3ZlcmZsb3coKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB0aGlzLiRpbnB1dC53aWR0aCgpIC0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLiRvdmVyZmxvd0hlbHBlci50ZXh0KHRoaXMuZ2V0SW5wdXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kb3ZlcmZsb3dIZWxwZXIud2lkdGgoKSA+PSBjb25zdHJhaW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQ3Vyc29yQXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZUxlbmd0aCwgc2VsZWN0aW9uU3RhcnQsIHJhbmdlO1xuICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy4kaW5wdXRbMF0uc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIoc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25TdGFydCA9PT0gdmFsdWVMZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIC12YWx1ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUxlbmd0aCA9PT0gcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGludC5vZmYoXCIudHRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKFwiLnR0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuJG92ZXJmbG93SGVscGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhpbnQgPSB0aGlzLiRpbnB1dCA9IHRoaXMuJG92ZXJmbG93SGVscGVyID0gJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElucHV0O1xuICAgICAgICBmdW5jdGlvbiBidWlsZE92ZXJmbG93SGVscGVyKCRpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuICQoJzxwcmUgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9wcmU+JykuY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAkaW5wdXQuY3NzKFwiZm9udC1mYW1pbHlcIiksXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICRpbnB1dC5jc3MoXCJmb250LXNpemVcIiksXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiAkaW5wdXQuY3NzKFwiZm9udC1zdHlsZVwiKSxcbiAgICAgICAgICAgICAgICBmb250VmFyaWFudDogJGlucHV0LmNzcyhcImZvbnQtdmFyaWFudFwiKSxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAkaW5wdXQuY3NzKFwiZm9udC13ZWlnaHRcIiksXG4gICAgICAgICAgICAgICAgd29yZFNwYWNpbmc6ICRpbnB1dC5jc3MoXCJ3b3JkLXNwYWNpbmdcIiksXG4gICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogJGlucHV0LmNzcyhcImxldHRlci1zcGFjaW5nXCIpLFxuICAgICAgICAgICAgICAgIHRleHRJbmRlbnQ6ICRpbnB1dC5jc3MoXCJ0ZXh0LWluZGVudFwiKSxcbiAgICAgICAgICAgICAgICB0ZXh0UmVuZGVyaW5nOiAkaW5wdXQuY3NzKFwidGV4dC1yZW5kZXJpbmdcIiksXG4gICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybTogJGlucHV0LmNzcyhcInRleHQtdHJhbnNmb3JtXCIpXG4gICAgICAgICAgICB9KS5pbnNlcnRBZnRlcigkaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFyZVF1ZXJpZXNFcXVpdmFsZW50KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnB1dC5ub3JtYWxpemVRdWVyeShhKSA9PT0gSW5wdXQubm9ybWFsaXplUXVlcnkoYik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2l0aE1vZGlmaWVyKCRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJGUuYWx0S2V5IHx8ICRlLmN0cmxLZXkgfHwgJGUubWV0YUtleSB8fCAkZS5zaGlmdEtleTtcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgRGF0YXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGtleXMsIG5hbWVHZW5lcmF0b3I7XG4gICAgICAgIGtleXMgPSB7XG4gICAgICAgICAgICB2YWw6IFwidHQtc2VsZWN0YWJsZS1kaXNwbGF5XCIsXG4gICAgICAgICAgICBvYmo6IFwidHQtc2VsZWN0YWJsZS1vYmplY3RcIlxuICAgICAgICB9O1xuICAgICAgICBuYW1lR2VuZXJhdG9yID0gXy5nZXRJZEdlbmVyYXRvcigpO1xuICAgICAgICBmdW5jdGlvbiBEYXRhc2V0KG8sIHd3dykge1xuICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICBvLnRlbXBsYXRlcyA9IG8udGVtcGxhdGVzIHx8IHt9O1xuICAgICAgICAgICAgby50ZW1wbGF0ZXMubm90Rm91bmQgPSBvLnRlbXBsYXRlcy5ub3RGb3VuZCB8fCBvLnRlbXBsYXRlcy5lbXB0eTtcbiAgICAgICAgICAgIGlmICghby5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwibWlzc2luZyBzb3VyY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW8ubm9kZSkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJtaXNzaW5nIG5vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoby5uYW1lICYmICFpc1ZhbGlkTmFtZShvLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgJC5lcnJvcihcImludmFsaWQgZGF0YXNldCBuYW1lOiBcIiArIG8ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3d3cubWl4aW4odGhpcyk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodCA9ICEhby5oaWdobGlnaHQ7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvLm5hbWUgfHwgbmFtZUdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhpcy5saW1pdCA9IG8ubGltaXQgfHwgNTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUZuID0gZ2V0RGlzcGxheUZuKG8uZGlzcGxheSB8fCBvLmRpc3BsYXlLZXkpO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZXMgPSBnZXRUZW1wbGF0ZXMoby50ZW1wbGF0ZXMsIHRoaXMuZGlzcGxheUZuKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gby5zb3VyY2UuX190dEFkYXB0ZXIgPyBvLnNvdXJjZS5fX3R0QWRhcHRlcigpIDogby5zb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmFzeW5jID0gXy5pc1VuZGVmaW5lZChvLmFzeW5jKSA/IHRoaXMuc291cmNlLmxlbmd0aCA+IDIgOiAhIW8uYXN5bmM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldExhc3RTdWdnZXN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLiRlbCA9ICQoby5ub2RlKS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZGF0YXNldCkuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmRhdGFzZXQgKyBcIi1cIiArIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgRGF0YXNldC5leHRyYWN0RGF0YSA9IGZ1bmN0aW9uIGV4dHJhY3REYXRhKGVsKSB7XG4gICAgICAgICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICAgICAgICBpZiAoJGVsLmRhdGEoa2V5cy5vYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiAkZWwuZGF0YShrZXlzLnZhbCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgb2JqOiAkZWwuZGF0YShrZXlzLm9iaikgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgXy5taXhpbihEYXRhc2V0LnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLCB7XG4gICAgICAgICAgICBfb3ZlcndyaXRlOiBmdW5jdGlvbiBvdmVyd3JpdGUocXVlcnksIHN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucyB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN1Z2dlc3Rpb25zKHF1ZXJ5LCBzdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFzeW5jICYmIHRoaXMudGVtcGxhdGVzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUGVuZGluZyhxdWVyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5hc3luYyAmJiB0aGlzLnRlbXBsYXRlcy5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJOb3RGb3VuZChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwicmVuZGVyZWRcIiwgdGhpcy5uYW1lLCBzdWdnZXN0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChxdWVyeSwgc3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggJiYgdGhpcy4kbGFzdFN1Z2dlc3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZFN1Z2dlc3Rpb25zKHF1ZXJ5LCBzdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdWdnZXN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3VnZ2VzdGlvbnMocXVlcnksIHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLiRsYXN0U3VnZ2VzdGlvbi5sZW5ndGggJiYgdGhpcy50ZW1wbGF0ZXMubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyTm90Rm91bmQocXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZW5kZXJlZFwiLCB0aGlzLm5hbWUsIHN1Z2dlc3Rpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVuZGVyU3VnZ2VzdGlvbnM6IGZ1bmN0aW9uIHJlbmRlclN1Z2dlc3Rpb25zKHF1ZXJ5LCBzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciAkZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgJGZyYWdtZW50ID0gdGhpcy5fZ2V0U3VnZ2VzdGlvbnNGcmFnbWVudChxdWVyeSwgc3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGxhc3RTdWdnZXN0aW9uID0gJGZyYWdtZW50LmNoaWxkcmVuKCkubGFzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmh0bWwoJGZyYWdtZW50KS5wcmVwZW5kKHRoaXMuX2dldEhlYWRlcihxdWVyeSwgc3VnZ2VzdGlvbnMpKS5hcHBlbmQodGhpcy5fZ2V0Rm9vdGVyKHF1ZXJ5LCBzdWdnZXN0aW9ucykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hcHBlbmRTdWdnZXN0aW9uczogZnVuY3Rpb24gYXBwZW5kU3VnZ2VzdGlvbnMocXVlcnksIHN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyICRmcmFnbWVudCwgJGxhc3RTdWdnZXN0aW9uO1xuICAgICAgICAgICAgICAgICRmcmFnbWVudCA9IHRoaXMuX2dldFN1Z2dlc3Rpb25zRnJhZ21lbnQocXVlcnksIHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgICAgICAkbGFzdFN1Z2dlc3Rpb24gPSAkZnJhZ21lbnQuY2hpbGRyZW4oKS5sYXN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kbGFzdFN1Z2dlc3Rpb24uYWZ0ZXIoJGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXN0U3VnZ2VzdGlvbiA9ICRsYXN0U3VnZ2VzdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVuZGVyUGVuZGluZzogZnVuY3Rpb24gcmVuZGVyUGVuZGluZyhxdWVyeSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVzLnBlbmRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRMYXN0U3VnZ2VzdGlvbigpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlICYmIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHRoaXMubmFtZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVuZGVyTm90Rm91bmQ6IGZ1bmN0aW9uIHJlbmRlck5vdEZvdW5kKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZXMubm90Rm91bmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRMYXN0U3VnZ2VzdGlvbigpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlICYmIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHRoaXMubmFtZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRMYXN0U3VnZ2VzdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRTdWdnZXN0aW9uc0ZyYWdtZW50OiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uc0ZyYWdtZW50KHF1ZXJ5LCBzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHN1Z2dlc3Rpb25zLCBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uTm9kZShzdWdnZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkZWwsIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGF0Ll9pbmplY3RRdWVyeShxdWVyeSwgc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICRlbCA9ICQodGhhdC50ZW1wbGF0ZXMuc3VnZ2VzdGlvbihjb250ZXh0KSkuZGF0YShrZXlzLm9iaiwgc3VnZ2VzdGlvbikuZGF0YShrZXlzLnZhbCwgdGhhdC5kaXNwbGF5Rm4oc3VnZ2VzdGlvbikpLmFkZENsYXNzKHRoYXQuY2xhc3Nlcy5zdWdnZXN0aW9uICsgXCIgXCIgKyB0aGF0LmNsYXNzZXMuc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCRlbFswXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgJiYgaGlnaGxpZ2h0KHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzZXMuaGlnaGxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBmcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcXVlcnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJChmcmFnbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEZvb3RlcjogZnVuY3Rpb24gZ2V0Rm9vdGVyKHF1ZXJ5LCBzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlcy5mb290ZXIgPyB0aGlzLnRlbXBsYXRlcy5mb290ZXIoe1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zOiBzdWdnZXN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogdGhpcy5uYW1lXG4gICAgICAgICAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRIZWFkZXI6IGZ1bmN0aW9uIGdldEhlYWRlcihxdWVyeSwgc3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZXMuaGVhZGVyID8gdGhpcy50ZW1wbGF0ZXMuaGVhZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogc3VnZ2VzdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHRoaXMubmFtZVxuICAgICAgICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVzZXRMYXN0U3VnZ2VzdGlvbjogZnVuY3Rpb24gcmVzZXRMYXN0U3VnZ2VzdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRsYXN0U3VnZ2VzdGlvbiA9ICQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5qZWN0UXVlcnk6IGZ1bmN0aW9uIGluamVjdFF1ZXJ5KHF1ZXJ5LCBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pc09iamVjdChvYmopID8gXy5taXhpbih7XG4gICAgICAgICAgICAgICAgICAgIF9xdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICB9LCBvYmopIDogb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBjYW5jZWxlZCA9IGZhbHNlLCBzeW5jQ2FsbGVkID0gZmFsc2UsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2FuY2VsID0gJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFzeW5jICYmIHRoYXQudHJpZ2dlcihcImFzeW5jQ2FuY2VsZWRcIiwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UocXVlcnksIHN5bmMsIGFzeW5jKTtcbiAgICAgICAgICAgICAgICAhc3luY0NhbGxlZCAmJiBzeW5jKFtdKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzeW5jKHN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW5jQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3luY0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zID0gKHN1Z2dlc3Rpb25zIHx8IFtdKS5zbGljZSgwLCB0aGF0LmxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQgPSBzdWdnZXN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX292ZXJ3cml0ZShxdWVyeSwgc3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWQgPCB0aGF0LmxpbWl0ICYmIHRoYXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihcImFzeW5jUmVxdWVzdGVkXCIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3luYyhzdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkICYmIHJlbmRlcmVkIDwgdGhhdC5saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jYW5jZWwgPSAkLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCArPSBzdWdnZXN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9hcHBlbmQocXVlcnksIHN1Z2dlc3Rpb25zLnNsaWNlKDAsIHRoYXQubGltaXQgLSByZW5kZXJlZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hc3luYyAmJiB0aGF0LnRyaWdnZXIoXCJhc3luY1JlY2VpdmVkXCIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6ICQubm9vcCxcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2xlYXJlZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5pcyhcIjplbXB0eVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsID0gJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERhdGFzZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGdldERpc3BsYXlGbihkaXNwbGF5KSB7XG4gICAgICAgICAgICBkaXNwbGF5ID0gZGlzcGxheSB8fCBfLnN0cmluZ2lmeTtcbiAgICAgICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oZGlzcGxheSkgPyBkaXNwbGF5IDogZGlzcGxheUZuO1xuICAgICAgICAgICAgZnVuY3Rpb24gZGlzcGxheUZuKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbZGlzcGxheV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVzKHRlbXBsYXRlcywgZGlzcGxheUZuKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kOiB0ZW1wbGF0ZXMubm90Rm91bmQgJiYgXy50ZW1wbGF0aWZ5KHRlbXBsYXRlcy5ub3RGb3VuZCksXG4gICAgICAgICAgICAgICAgcGVuZGluZzogdGVtcGxhdGVzLnBlbmRpbmcgJiYgXy50ZW1wbGF0aWZ5KHRlbXBsYXRlcy5wZW5kaW5nKSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRlbXBsYXRlcy5oZWFkZXIgJiYgXy50ZW1wbGF0aWZ5KHRlbXBsYXRlcy5oZWFkZXIpLFxuICAgICAgICAgICAgICAgIGZvb3RlcjogdGVtcGxhdGVzLmZvb3RlciAmJiBfLnRlbXBsYXRpZnkodGVtcGxhdGVzLmZvb3RlciksXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbjogdGVtcGxhdGVzLnN1Z2dlc3Rpb24gfHwgc3VnZ2VzdGlvblRlbXBsYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gc3VnZ2VzdGlvblRlbXBsYXRlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJChcIjxkaXY+XCIpLnRleHQoZGlzcGxheUZuKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkTmFtZShzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAvXltfYS16QS1aMC05LV0rJC8udGVzdChzdHIpO1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBNZW51KG8sIHd3dykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICBpZiAoIW8ubm9kZSkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJub2RlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3d3Lm1peGluKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kbm9kZSA9ICQoby5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhc2V0cyA9IF8ubWFwKG8uZGF0YXNldHMsIGluaXRpYWxpemVEYXRhc2V0KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhc2V0KG9EYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGF0LiRub2RlLmZpbmQob0RhdGFzZXQubm9kZSkuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICBvRGF0YXNldC5ub2RlID0gbm9kZS5sZW5ndGggPyBub2RlIDogJChcIjxkaXY+XCIpLmFwcGVuZFRvKHRoYXQuJG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YXNldChvRGF0YXNldCwgd3d3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKE1lbnUucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIF9vblNlbGVjdGFibGVDbGljazogZnVuY3Rpb24gb25TZWxlY3RhYmxlQ2xpY2soJGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJzZWxlY3RhYmxlQ2xpY2tlZFwiLCAkKCRlLmN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25SZW5kZXJlZDogZnVuY3Rpb24gb25SZW5kZXJlZCh0eXBlLCBkYXRhc2V0LCBzdWdnZXN0aW9ucywgYXN5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRub2RlLnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3Nlcy5lbXB0eSwgdGhpcy5fYWxsRGF0YXNldHNFbXB0eSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJkYXRhc2V0UmVuZGVyZWRcIiwgZGF0YXNldCwgc3VnZ2VzdGlvbnMsIGFzeW5jKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DbGVhcmVkOiBmdW5jdGlvbiBvbkNsZWFyZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbm9kZS50b2dnbGVDbGFzcyh0aGlzLmNsYXNzZXMuZW1wdHksIHRoaXMuX2FsbERhdGFzZXRzRW1wdHkoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZGF0YXNldENsZWFyZWRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Byb3BhZ2F0ZTogZnVuY3Rpb24gcHJvcGFnYXRlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hbGxEYXRhc2V0c0VtcHR5OiBmdW5jdGlvbiBhbGxEYXRhc2V0c0VtcHR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmV2ZXJ5KHRoaXMuZGF0YXNldHMsIGlzRGF0YXNldEVtcHR5KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0RhdGFzZXRFbXB0eShkYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhc2V0LmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFNlbGVjdGFibGVzOiBmdW5jdGlvbiBnZXRTZWxlY3RhYmxlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbm9kZS5maW5kKHRoaXMuc2VsZWN0b3JzLnNlbGVjdGFibGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZW1vdmVDdXJzb3I6IGZ1bmN0aW9uIF9yZW1vdmVDdXJzb3IoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzZWxlY3RhYmxlID0gdGhpcy5nZXRBY3RpdmVTZWxlY3RhYmxlKCk7XG4gICAgICAgICAgICAgICAgJHNlbGVjdGFibGUgJiYgJHNlbGVjdGFibGUucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmN1cnNvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Vuc3VyZVZpc2libGU6IGZ1bmN0aW9uIGVuc3VyZVZpc2libGUoJGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsVG9wLCBlbEJvdHRvbSwgbm9kZVNjcm9sbFRvcCwgbm9kZUhlaWdodDtcbiAgICAgICAgICAgICAgICBlbFRvcCA9ICRlbC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICBlbEJvdHRvbSA9IGVsVG9wICsgJGVsLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgICAgIG5vZGVTY3JvbGxUb3AgPSB0aGlzLiRub2RlLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgIG5vZGVIZWlnaHQgPSB0aGlzLiRub2RlLmhlaWdodCgpICsgcGFyc2VJbnQodGhpcy4kbm9kZS5jc3MoXCJwYWRkaW5nVG9wXCIpLCAxMCkgKyBwYXJzZUludCh0aGlzLiRub2RlLmNzcyhcInBhZGRpbmdCb3R0b21cIiksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxUb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG5vZGUuc2Nyb2xsVG9wKG5vZGVTY3JvbGxUb3AgKyBlbFRvcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlSGVpZ2h0IDwgZWxCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5zY3JvbGxUb3Aobm9kZVNjcm9sbFRvcCArIChlbEJvdHRvbSAtIG5vZGVIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBvblNlbGVjdGFibGVDbGljaztcbiAgICAgICAgICAgICAgICBvblNlbGVjdGFibGVDbGljayA9IF8uYmluZCh0aGlzLl9vblNlbGVjdGFibGVDbGljaywgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5vbihcImNsaWNrLnR0XCIsIHRoaXMuc2VsZWN0b3JzLnNlbGVjdGFibGUsIG9uU2VsZWN0YWJsZUNsaWNrKTtcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0Lm9uU3luYyhcImFzeW5jUmVxdWVzdGVkXCIsIHRoYXQuX3Byb3BhZ2F0ZSwgdGhhdCkub25TeW5jKFwiYXN5bmNDYW5jZWxlZFwiLCB0aGF0Ll9wcm9wYWdhdGUsIHRoYXQpLm9uU3luYyhcImFzeW5jUmVjZWl2ZWRcIiwgdGhhdC5fcHJvcGFnYXRlLCB0aGF0KS5vblN5bmMoXCJyZW5kZXJlZFwiLCB0aGF0Ll9vblJlbmRlcmVkLCB0aGF0KS5vblN5bmMoXCJjbGVhcmVkXCIsIHRoYXQuX29uQ2xlYXJlZCwgdGhhdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNPcGVuOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5vZGUuaGFzQ2xhc3ModGhpcy5jbGFzc2VzLm9wZW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMub3Blbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5vZGUucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLm9wZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnNvcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldExhbmd1YWdlRGlyZWN0aW9uOiBmdW5jdGlvbiBzZXRMYW5ndWFnZURpcmVjdGlvbihkaXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRub2RlLmF0dHIoXCJkaXJcIiwgZGlyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RhYmxlUmVsYXRpdmVUb0N1cnNvcjogZnVuY3Rpb24gc2VsZWN0YWJsZVJlbGF0aXZlVG9DdXJzb3IoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHNlbGVjdGFibGVzLCAkb2xkQ3Vyc29yLCBvbGRJbmRleCwgbmV3SW5kZXg7XG4gICAgICAgICAgICAgICAgJG9sZEN1cnNvciA9IHRoaXMuZ2V0QWN0aXZlU2VsZWN0YWJsZSgpO1xuICAgICAgICAgICAgICAgICRzZWxlY3RhYmxlcyA9IHRoaXMuX2dldFNlbGVjdGFibGVzKCk7XG4gICAgICAgICAgICAgICAgb2xkSW5kZXggPSAkb2xkQ3Vyc29yID8gJHNlbGVjdGFibGVzLmluZGV4KCRvbGRDdXJzb3IpIDogLTE7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBvbGRJbmRleCArIGRlbHRhO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gKG5ld0luZGV4ICsgMSkgJSAoJHNlbGVjdGFibGVzLmxlbmd0aCArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4IDwgLTEgPyAkc2VsZWN0YWJsZXMubGVuZ3RoIC0gMSA6IG5ld0luZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdJbmRleCA9PT0gLTEgPyBudWxsIDogJHNlbGVjdGFibGVzLmVxKG5ld0luZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uIHNldEN1cnNvcigkc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnNvcigpO1xuICAgICAgICAgICAgICAgIGlmICgkc2VsZWN0YWJsZSA9ICRzZWxlY3RhYmxlICYmICRzZWxlY3RhYmxlLmZpcnN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdGFibGUuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVZpc2libGUoJHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTZWxlY3RhYmxlRGF0YTogZnVuY3Rpb24gZ2V0U2VsZWN0YWJsZURhdGEoJGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbCAmJiAkZWwubGVuZ3RoID8gRGF0YXNldC5leHRyYWN0RGF0YSgkZWwpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRBY3RpdmVTZWxlY3RhYmxlOiBmdW5jdGlvbiBnZXRBY3RpdmVTZWxlY3RhYmxlKCkge1xuICAgICAgICAgICAgICAgIHZhciAkc2VsZWN0YWJsZSA9IHRoaXMuX2dldFNlbGVjdGFibGVzKCkuZmlsdGVyKHRoaXMuc2VsZWN0b3JzLmN1cnNvcikuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHNlbGVjdGFibGUubGVuZ3RoID8gJHNlbGVjdGFibGUgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRvcFNlbGVjdGFibGU6IGZ1bmN0aW9uIGdldFRvcFNlbGVjdGFibGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzZWxlY3RhYmxlID0gdGhpcy5fZ2V0U2VsZWN0YWJsZXMoKS5maXJzdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkc2VsZWN0YWJsZS5sZW5ndGggPyAkc2VsZWN0YWJsZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUocXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZFVwZGF0ZSA9IHF1ZXJ5ICE9PSB0aGlzLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMuZGF0YXNldHMsIHVwZGF0ZURhdGFzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZFVwZGF0ZTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVEYXRhc2V0KGRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldC51cGRhdGUocXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMuZGF0YXNldHMsIGNsZWFyRGF0YXNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyRGF0YXNldChkYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRub2RlLm9mZihcIi50dFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRub2RlID0gJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgICAgIF8uZWFjaCh0aGlzLmRhdGFzZXRzLCBkZXN0cm95RGF0YXNldCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVzdHJveURhdGFzZXQoZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTWVudTtcbiAgICB9KCk7XG4gICAgdmFyIERlZmF1bHRNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcyA9IE1lbnUucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0TWVudSgpIHtcbiAgICAgICAgICAgIE1lbnUuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKERlZmF1bHRNZW51LnByb3RvdHlwZSwgTWVudS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgICAgICAgICAgIXRoaXMuX2FsbERhdGFzZXRzRW1wdHkoKSAmJiB0aGlzLl9zaG93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMub3Blbi5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuY2xvc2UuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25SZW5kZXJlZDogZnVuY3Rpb24gb25SZW5kZXJlZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWxsRGF0YXNldHNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbigpICYmIHRoaXMuX3Nob3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuX29uUmVuZGVyZWQuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DbGVhcmVkOiBmdW5jdGlvbiBvbkNsZWFyZWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFzZXRzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wZW4oKSAmJiB0aGlzLl9zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzLl9vbkNsZWFyZWQuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRMYW5ndWFnZURpcmVjdGlvbjogZnVuY3Rpb24gc2V0TGFuZ3VhZ2VEaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5jc3MoZGlyID09PSBcImx0clwiID8gdGhpcy5jc3MubHRyIDogdGhpcy5jc3MucnRsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5zZXRMYW5ndWFnZURpcmVjdGlvbi5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5vZGUuaGlkZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG5vZGUuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRNZW51O1xuICAgIH0oKTtcbiAgICB2YXIgVHlwZWFoZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBUeXBlYWhlYWQobywgd3d3KSB7XG4gICAgICAgICAgICB2YXIgb25Gb2N1c2VkLCBvbkJsdXJyZWQsIG9uRW50ZXJLZXllZCwgb25UYWJLZXllZCwgb25Fc2NLZXllZCwgb25VcEtleWVkLCBvbkRvd25LZXllZCwgb25MZWZ0S2V5ZWQsIG9uUmlnaHRLZXllZCwgb25RdWVyeUNoYW5nZWQsIG9uV2hpdGVzcGFjZUNoYW5nZWQ7XG4gICAgICAgICAgICBvID0gbyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJtaXNzaW5nIGlucHV0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvLm1lbnUpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwibWlzc2luZyBtZW51XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvLmV2ZW50QnVzKSB7XG4gICAgICAgICAgICAgICAgJC5lcnJvcihcIm1pc3NpbmcgZXZlbnQgYnVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3d3Lm1peGluKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cyA9IG8uZXZlbnRCdXM7XG4gICAgICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IF8uaXNOdW1iZXIoby5taW5MZW5ndGgpID8gby5taW5MZW5ndGggOiAxO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG8uaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLm1lbnUgPSBvLm1lbnU7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaGFzRm9jdXMoKSAmJiB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuaW5wdXQuZ2V0TGFuZ0RpcigpO1xuICAgICAgICAgICAgdGhpcy5faGFja3MoKTtcbiAgICAgICAgICAgIHRoaXMubWVudS5iaW5kKCkub25TeW5jKFwic2VsZWN0YWJsZUNsaWNrZWRcIiwgdGhpcy5fb25TZWxlY3RhYmxlQ2xpY2tlZCwgdGhpcykub25TeW5jKFwiYXN5bmNSZXF1ZXN0ZWRcIiwgdGhpcy5fb25Bc3luY1JlcXVlc3RlZCwgdGhpcykub25TeW5jKFwiYXN5bmNDYW5jZWxlZFwiLCB0aGlzLl9vbkFzeW5jQ2FuY2VsZWQsIHRoaXMpLm9uU3luYyhcImFzeW5jUmVjZWl2ZWRcIiwgdGhpcy5fb25Bc3luY1JlY2VpdmVkLCB0aGlzKS5vblN5bmMoXCJkYXRhc2V0UmVuZGVyZWRcIiwgdGhpcy5fb25EYXRhc2V0UmVuZGVyZWQsIHRoaXMpLm9uU3luYyhcImRhdGFzZXRDbGVhcmVkXCIsIHRoaXMuX29uRGF0YXNldENsZWFyZWQsIHRoaXMpO1xuICAgICAgICAgICAgb25Gb2N1c2VkID0gYyh0aGlzLCBcImFjdGl2YXRlXCIsIFwib3BlblwiLCBcIl9vbkZvY3VzZWRcIik7XG4gICAgICAgICAgICBvbkJsdXJyZWQgPSBjKHRoaXMsIFwiZGVhY3RpdmF0ZVwiLCBcIl9vbkJsdXJyZWRcIik7XG4gICAgICAgICAgICBvbkVudGVyS2V5ZWQgPSBjKHRoaXMsIFwiaXNBY3RpdmVcIiwgXCJpc09wZW5cIiwgXCJfb25FbnRlcktleWVkXCIpO1xuICAgICAgICAgICAgb25UYWJLZXllZCA9IGModGhpcywgXCJpc0FjdGl2ZVwiLCBcImlzT3BlblwiLCBcIl9vblRhYktleWVkXCIpO1xuICAgICAgICAgICAgb25Fc2NLZXllZCA9IGModGhpcywgXCJpc0FjdGl2ZVwiLCBcIl9vbkVzY0tleWVkXCIpO1xuICAgICAgICAgICAgb25VcEtleWVkID0gYyh0aGlzLCBcImlzQWN0aXZlXCIsIFwib3BlblwiLCBcIl9vblVwS2V5ZWRcIik7XG4gICAgICAgICAgICBvbkRvd25LZXllZCA9IGModGhpcywgXCJpc0FjdGl2ZVwiLCBcIm9wZW5cIiwgXCJfb25Eb3duS2V5ZWRcIik7XG4gICAgICAgICAgICBvbkxlZnRLZXllZCA9IGModGhpcywgXCJpc0FjdGl2ZVwiLCBcImlzT3BlblwiLCBcIl9vbkxlZnRLZXllZFwiKTtcbiAgICAgICAgICAgIG9uUmlnaHRLZXllZCA9IGModGhpcywgXCJpc0FjdGl2ZVwiLCBcImlzT3BlblwiLCBcIl9vblJpZ2h0S2V5ZWRcIik7XG4gICAgICAgICAgICBvblF1ZXJ5Q2hhbmdlZCA9IGModGhpcywgXCJfb3BlbklmQWN0aXZlXCIsIFwiX29uUXVlcnlDaGFuZ2VkXCIpO1xuICAgICAgICAgICAgb25XaGl0ZXNwYWNlQ2hhbmdlZCA9IGModGhpcywgXCJfb3BlbklmQWN0aXZlXCIsIFwiX29uV2hpdGVzcGFjZUNoYW5nZWRcIik7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmJpbmQoKS5vblN5bmMoXCJmb2N1c2VkXCIsIG9uRm9jdXNlZCwgdGhpcykub25TeW5jKFwiYmx1cnJlZFwiLCBvbkJsdXJyZWQsIHRoaXMpLm9uU3luYyhcImVudGVyS2V5ZWRcIiwgb25FbnRlcktleWVkLCB0aGlzKS5vblN5bmMoXCJ0YWJLZXllZFwiLCBvblRhYktleWVkLCB0aGlzKS5vblN5bmMoXCJlc2NLZXllZFwiLCBvbkVzY0tleWVkLCB0aGlzKS5vblN5bmMoXCJ1cEtleWVkXCIsIG9uVXBLZXllZCwgdGhpcykub25TeW5jKFwiZG93bktleWVkXCIsIG9uRG93bktleWVkLCB0aGlzKS5vblN5bmMoXCJsZWZ0S2V5ZWRcIiwgb25MZWZ0S2V5ZWQsIHRoaXMpLm9uU3luYyhcInJpZ2h0S2V5ZWRcIiwgb25SaWdodEtleWVkLCB0aGlzKS5vblN5bmMoXCJxdWVyeUNoYW5nZWRcIiwgb25RdWVyeUNoYW5nZWQsIHRoaXMpLm9uU3luYyhcIndoaXRlc3BhY2VDaGFuZ2VkXCIsIG9uV2hpdGVzcGFjZUNoYW5nZWQsIHRoaXMpLm9uU3luYyhcImxhbmdEaXJDaGFuZ2VkXCIsIHRoaXMuX29uTGFuZ0RpckNoYW5nZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIF8ubWl4aW4oVHlwZWFoZWFkLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgX2hhY2tzOiBmdW5jdGlvbiBoYWNrcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGlucHV0LCAkbWVudTtcbiAgICAgICAgICAgICAgICAkaW5wdXQgPSB0aGlzLmlucHV0LiRpbnB1dCB8fCAkKFwiPGRpdj5cIik7XG4gICAgICAgICAgICAgICAgJG1lbnUgPSB0aGlzLm1lbnUuJG5vZGUgfHwgJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgICAgICRpbnB1dC5vbihcImJsdXIudHRcIiwgZnVuY3Rpb24oJGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSwgaXNBY3RpdmUsIGhhc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUgPSAkbWVudS5pcyhhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBoYXNBY3RpdmUgPSAkbWVudS5oYXMoYWN0aXZlKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc01zaWUoKSAmJiAoaXNBY3RpdmUgfHwgaGFzQWN0aXZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJG1lbnUub24oXCJtb3VzZWRvd24udHRcIiwgZnVuY3Rpb24oJGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25TZWxlY3RhYmxlQ2xpY2tlZDogZnVuY3Rpb24gb25TZWxlY3RhYmxlQ2xpY2tlZCh0eXBlLCAkZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCgkZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkRhdGFzZXRDbGVhcmVkOiBmdW5jdGlvbiBvbkRhdGFzZXRDbGVhcmVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25EYXRhc2V0UmVuZGVyZWQ6IGZ1bmN0aW9uIG9uRGF0YXNldFJlbmRlcmVkKHR5cGUsIGRhdGFzZXQsIHN1Z2dlc3Rpb25zLCBhc3luYykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoXCJyZW5kZXJcIiwgc3VnZ2VzdGlvbnMsIGFzeW5jLCBkYXRhc2V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Bc3luY1JlcXVlc3RlZDogZnVuY3Rpb24gb25Bc3luY1JlcXVlc3RlZCh0eXBlLCBkYXRhc2V0LCBxdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcImFzeW5jcmVxdWVzdFwiLCBxdWVyeSwgZGF0YXNldCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQXN5bmNDYW5jZWxlZDogZnVuY3Rpb24gb25Bc3luY0NhbmNlbGVkKHR5cGUsIGRhdGFzZXQsIHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKFwiYXN5bmNjYW5jZWxcIiwgcXVlcnksIGRhdGFzZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkFzeW5jUmVjZWl2ZWQ6IGZ1bmN0aW9uIG9uQXN5bmNSZWNlaXZlZCh0eXBlLCBkYXRhc2V0LCBxdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcImFzeW5jcmVjZWl2ZVwiLCBxdWVyeSwgZGF0YXNldCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRm9jdXNlZDogZnVuY3Rpb24gb25Gb2N1c2VkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbkxlbmd0aE1ldCgpICYmIHRoaXMubWVudS51cGRhdGUodGhpcy5pbnB1dC5nZXRRdWVyeSgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25CbHVycmVkOiBmdW5jdGlvbiBvbkJsdXJyZWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuaGFzUXVlcnlDaGFuZ2VkU2luY2VMYXN0Rm9jdXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoXCJjaGFuZ2VcIiwgdGhpcy5pbnB1dC5nZXRRdWVyeSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRW50ZXJLZXllZDogZnVuY3Rpb24gb25FbnRlcktleWVkKHR5cGUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzZWxlY3RhYmxlO1xuICAgICAgICAgICAgICAgIGlmICgkc2VsZWN0YWJsZSA9IHRoaXMubWVudS5nZXRBY3RpdmVTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoJHNlbGVjdGFibGUpICYmICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblRhYktleWVkOiBmdW5jdGlvbiBvblRhYktleWVkKHR5cGUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzZWxlY3RhYmxlO1xuICAgICAgICAgICAgICAgIGlmICgkc2VsZWN0YWJsZSA9IHRoaXMubWVudS5nZXRBY3RpdmVTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoJHNlbGVjdGFibGUpICYmICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2VsZWN0YWJsZSA9IHRoaXMubWVudS5nZXRUb3BTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUoJHNlbGVjdGFibGUpICYmICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVzY0tleWVkOiBmdW5jdGlvbiBvbkVzY0tleWVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcEtleWVkOiBmdW5jdGlvbiBvblVwS2V5ZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Eb3duS2V5ZWQ6IGZ1bmN0aW9uIG9uRG93bktleWVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcigrMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uTGVmdEtleWVkOiBmdW5jdGlvbiBvbkxlZnRLZXllZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXIgPT09IFwicnRsXCIgJiYgdGhpcy5pbnB1dC5pc0N1cnNvckF0RW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUodGhpcy5tZW51LmdldFRvcFNlbGVjdGFibGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblJpZ2h0S2V5ZWQ6IGZ1bmN0aW9uIG9uUmlnaHRLZXllZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXIgPT09IFwibHRyXCIgJiYgdGhpcy5pbnB1dC5pc0N1cnNvckF0RW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUodGhpcy5tZW51LmdldFRvcFNlbGVjdGFibGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblF1ZXJ5Q2hhbmdlZDogZnVuY3Rpb24gb25RdWVyeUNoYW5nZWQoZSwgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5MZW5ndGhNZXQocXVlcnkpID8gdGhpcy5tZW51LnVwZGF0ZShxdWVyeSkgOiB0aGlzLm1lbnUuZW1wdHkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25XaGl0ZXNwYWNlQ2hhbmdlZDogZnVuY3Rpb24gb25XaGl0ZXNwYWNlQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVIaW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uTGFuZ0RpckNoYW5nZWQ6IGZ1bmN0aW9uIG9uTGFuZ0RpckNoYW5nZWQoZSwgZGlyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5zZXRMYW5ndWFnZURpcmVjdGlvbihkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb3BlbklmQWN0aXZlOiBmdW5jdGlvbiBvcGVuSWZBY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSgpICYmIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9taW5MZW5ndGhNZXQ6IGZ1bmN0aW9uIG1pbkxlbmd0aE1ldChxdWVyeSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gXy5pc1N0cmluZyhxdWVyeSkgPyBxdWVyeSA6IHRoaXMuaW5wdXQuZ2V0UXVlcnkoKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5sZW5ndGggPj0gdGhpcy5taW5MZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VwZGF0ZUhpbnQ6IGZ1bmN0aW9uIHVwZGF0ZUhpbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRzZWxlY3RhYmxlLCBkYXRhLCB2YWwsIHF1ZXJ5LCBlc2NhcGVkUXVlcnksIGZyb250TWF0Y2hSZWdFeCwgbWF0Y2g7XG4gICAgICAgICAgICAgICAgJHNlbGVjdGFibGUgPSB0aGlzLm1lbnUuZ2V0VG9wU2VsZWN0YWJsZSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLm1lbnUuZ2V0U2VsZWN0YWJsZURhdGEoJHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuaW5wdXQuZ2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmICFfLmlzQmxhbmtTdHJpbmcodmFsKSAmJiAhdGhpcy5pbnB1dC5oYXNPdmVyZmxvdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gSW5wdXQubm9ybWFsaXplUXVlcnkodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFF1ZXJ5ID0gXy5lc2NhcGVSZWdFeENoYXJzKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbnRNYXRjaFJlZ0V4ID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIGVzY2FwZWRRdWVyeSArIFwiKSguKyQpXCIsIFwiaVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmcm9udE1hdGNoUmVnRXguZXhlYyhkYXRhLnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoICYmIHRoaXMuaW5wdXQuc2V0SGludCh2YWwgKyBtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5jbGVhckhpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzRW5hYmxlZCgpIHx8IHRoaXMuZXZlbnRCdXMuYmVmb3JlKFwiYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50QnVzLmJlZm9yZShcImlkbGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKFwiaWRsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzT3BlbjogZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnUuaXNPcGVuKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKCkgJiYgIXRoaXMuZXZlbnRCdXMuYmVmb3JlKFwib3BlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVIaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT3BlbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oKSAmJiAhdGhpcy5ldmVudEJ1cy5iZWZvcmUoXCJjbG9zZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5jbGVhckhpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5yZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc09wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRWYWw6IGZ1bmN0aW9uIHNldFZhbCh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldFF1ZXJ5KF8udG9TdHIodmFsKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VmFsOiBmdW5jdGlvbiBnZXRWYWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCgkc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5tZW51LmdldFNlbGVjdGFibGVEYXRhKCRzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAhdGhpcy5ldmVudEJ1cy5iZWZvcmUoXCJzZWxlY3RcIiwgZGF0YS5vYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0UXVlcnkoZGF0YS52YWwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoXCJzZWxlY3RcIiwgZGF0YS5vYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBmdW5jdGlvbiBhdXRvY29tcGxldGUoJHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnksIGRhdGEsIGlzVmFsaWQ7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMubWVudS5nZXRTZWxlY3RhYmxlRGF0YSgkc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGRhdGEgJiYgcXVlcnkgIT09IGRhdGEudmFsO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkICYmICF0aGlzLmV2ZW50QnVzLmJlZm9yZShcImF1dG9jb21wbGV0ZVwiLCBkYXRhLm9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRRdWVyeShkYXRhLnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcImF1dG9jb21wbGV0ZVwiLCBkYXRhLm9iaik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZUN1cnNvcjogZnVuY3Rpb24gbW92ZUN1cnNvcihkZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSwgJGNhbmRpZGF0ZSwgZGF0YSwgcGF5bG9hZCwgY2FuY2VsTW92ZTtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHRoaXMuaW5wdXQuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICAkY2FuZGlkYXRlID0gdGhpcy5tZW51LnNlbGVjdGFibGVSZWxhdGl2ZVRvQ3Vyc29yKGRlbHRhKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5tZW51LmdldFNlbGVjdGFibGVEYXRhKCRjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBkYXRhID8gZGF0YS5vYmogOiBudWxsO1xuICAgICAgICAgICAgICAgIGNhbmNlbE1vdmUgPSB0aGlzLl9taW5MZW5ndGhNZXQoKSAmJiB0aGlzLm1lbnUudXBkYXRlKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbE1vdmUgJiYgIXRoaXMuZXZlbnRCdXMuYmVmb3JlKFwiY3Vyc29yY2hhbmdlXCIsIHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5zZXRDdXJzb3IoJGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldElucHV0VmFsdWUoZGF0YS52YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5yZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoXCJjdXJzb3JjaGFuZ2VcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVhaGVhZDtcbiAgICAgICAgZnVuY3Rpb24gYyhjdHgpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFttZXRob2RdLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBvbGQsIGtleXMsIG1ldGhvZHM7XG4gICAgICAgIG9sZCA9ICQuZm4udHlwZWFoZWFkO1xuICAgICAgICBrZXlzID0ge1xuICAgICAgICAgICAgd3d3OiBcInR0LXd3d1wiLFxuICAgICAgICAgICAgYXR0cnM6IFwidHQtYXR0cnNcIixcbiAgICAgICAgICAgIHR5cGVhaGVhZDogXCJ0dC10eXBlYWhlYWRcIlxuICAgICAgICB9O1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShvLCBkYXRhc2V0cykge1xuICAgICAgICAgICAgICAgIHZhciB3d3c7XG4gICAgICAgICAgICAgICAgZGF0YXNldHMgPSBfLmlzQXJyYXkoZGF0YXNldHMpID8gZGF0YXNldHMgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICAgICAgd3d3ID0gV1dXKG8uY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChhdHRhY2gpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCwgJHdyYXBwZXIsICRoaW50LCAkbWVudSwgZGVmYXVsdEhpbnQsIGRlZmF1bHRNZW51LCBldmVudEJ1cywgaW5wdXQsIG1lbnUsIHR5cGVhaGVhZCwgTWVudUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuaGlnaGxpZ2h0ID0gISFvLmhpZ2hsaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICRpbnB1dCA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICR3cmFwcGVyID0gJCh3d3cuaHRtbC53cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgJGhpbnQgPSAkZWxPck51bGwoby5oaW50KTtcbiAgICAgICAgICAgICAgICAgICAgJG1lbnUgPSAkZWxPck51bGwoby5tZW51KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEhpbnQgPSBvLmhpbnQgIT09IGZhbHNlICYmICEkaGludDtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1lbnUgPSBvLm1lbnUgIT09IGZhbHNlICYmICEkbWVudTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEhpbnQgJiYgKCRoaW50ID0gYnVpbGRIaW50RnJvbUlucHV0KCRpbnB1dCwgd3d3KSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRNZW51ICYmICgkbWVudSA9ICQod3d3Lmh0bWwubWVudSkuY3NzKHd3dy5jc3MubWVudSkpO1xuICAgICAgICAgICAgICAgICAgICAkaGludCAmJiAkaGludC52YWwoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICRpbnB1dCA9IHByZXBJbnB1dCgkaW5wdXQsIHd3dyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0SGludCB8fCBkZWZhdWx0TWVudSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHdyYXBwZXIuY3NzKHd3dy5jc3Mud3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQuY3NzKGRlZmF1bHRIaW50ID8gd3d3LmNzcy5pbnB1dCA6IHd3dy5jc3MuaW5wdXRXaXRoTm9IaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC53cmFwKCR3cmFwcGVyKS5wYXJlbnQoKS5wcmVwZW5kKGRlZmF1bHRIaW50ID8gJGhpbnQgOiBudWxsKS5hcHBlbmQoZGVmYXVsdE1lbnUgPyAkbWVudSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE1lbnVDb25zdHJ1Y3RvciA9IGRlZmF1bHRNZW51ID8gRGVmYXVsdE1lbnUgOiBNZW51O1xuICAgICAgICAgICAgICAgICAgICBldmVudEJ1cyA9IG5ldyBFdmVudEJ1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogJGlucHV0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBJbnB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50OiAkaGludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAkaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgfSwgd3d3KTtcbiAgICAgICAgICAgICAgICAgICAgbWVudSA9IG5ldyBNZW51Q29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogJG1lbnUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0czogZGF0YXNldHNcbiAgICAgICAgICAgICAgICAgICAgfSwgd3d3KTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkID0gbmV3IFR5cGVhaGVhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51OiBtZW51LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRCdXM6IGV2ZW50QnVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoOiBvLm1pbkxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9LCB3d3cpO1xuICAgICAgICAgICAgICAgICAgICAkaW5wdXQuZGF0YShrZXlzLnd3dywgd3d3KTtcbiAgICAgICAgICAgICAgICAgICAgJGlucHV0LmRhdGEoa2V5cy50eXBlYWhlYWQsIHR5cGVhaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmFibGVkO1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLmZpcnN0KCksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IHQuaXNFbmFibGVkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgICAgICAgICAgdHRFYWNoKHRoaXMsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlO1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLmZpcnN0KCksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdC5pc0FjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbiBkZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzT3BlbjogZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcGVuO1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLmZpcnN0KCksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHQuaXNPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgICAgICAgICB0dEVhY2godGhpcywgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICB0Lm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgdHRFYWNoKHRoaXMsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmYWxzZSwgJGVsID0gJChlbCk7XG4gICAgICAgICAgICAgICAgdHRFYWNoKHRoaXMuZmlyc3QoKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdC5zZWxlY3QoJGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGZ1bmN0aW9uIGF1dG9jb21wbGV0ZShlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2UsICRlbCA9ICQoZWwpO1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLmZpcnN0KCksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHQuYXV0b2NvbXBsZXRlKCRlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZUN1cnNvcjogZnVuY3Rpb24gbW92ZUN1cnNvZShkZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHRFYWNoKHRoaXMuZmlyc3QoKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdC5tb3ZlQ3Vyc29yKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uIHZhbChuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLmZpcnN0KCksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdC5nZXRWYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dEVhY2godGhpcywgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRWYWwobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHR0RWFjaCh0aGlzLCBmdW5jdGlvbih0eXBlYWhlYWQsICRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnQoJGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJC5mbi50eXBlYWhlYWQgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJC5mbi50eXBlYWhlYWQubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICAgICAgICAkLmZuLnR5cGVhaGVhZCA9IG9sZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiB0dEVhY2goJGVscywgZm4pIHtcbiAgICAgICAgICAgICRlbHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGlucHV0ID0gJCh0aGlzKSwgdHlwZWFoZWFkO1xuICAgICAgICAgICAgICAgICh0eXBlYWhlYWQgPSAkaW5wdXQuZGF0YShrZXlzLnR5cGVhaGVhZCkpICYmIGZuKHR5cGVhaGVhZCwgJGlucHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkSGludEZyb21JbnB1dCgkaW5wdXQsIHd3dykge1xuICAgICAgICAgICAgcmV0dXJuICRpbnB1dC5jbG9uZSgpLmFkZENsYXNzKHd3dy5jbGFzc2VzLmhpbnQpLnJlbW92ZURhdGEoKS5jc3Mod3d3LmNzcy5oaW50KS5jc3MoZ2V0QmFja2dyb3VuZFN0eWxlcygkaW5wdXQpKS5wcm9wKFwicmVhZG9ubHlcIiwgdHJ1ZSkucmVtb3ZlQXR0cihcImlkIG5hbWUgcGxhY2Vob2xkZXIgcmVxdWlyZWRcIikuYXR0cih7XG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBcIm9mZlwiLFxuICAgICAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByZXBJbnB1dCgkaW5wdXQsIHd3dykge1xuICAgICAgICAgICAgJGlucHV0LmRhdGEoa2V5cy5hdHRycywge1xuICAgICAgICAgICAgICAgIGRpcjogJGlucHV0LmF0dHIoXCJkaXJcIiksXG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAkaW5wdXQuYXR0cihcImF1dG9jb21wbGV0ZVwiKSxcbiAgICAgICAgICAgICAgICBzcGVsbGNoZWNrOiAkaW5wdXQuYXR0cihcInNwZWxsY2hlY2tcIiksXG4gICAgICAgICAgICAgICAgc3R5bGU6ICRpbnB1dC5hdHRyKFwic3R5bGVcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGlucHV0LmFkZENsYXNzKHd3dy5jbGFzc2VzLmlucHV0KS5hdHRyKHtcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IFwib2ZmXCIsXG4gICAgICAgICAgICAgICAgc3BlbGxjaGVjazogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAhJGlucHV0LmF0dHIoXCJkaXJcIikgJiYgJGlucHV0LmF0dHIoXCJkaXJcIiwgXCJhdXRvXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIHJldHVybiAkaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFN0eWxlcygkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIiksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENsaXA6ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLWNsaXBcIiksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAkZWwuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRPcmlnaW46ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLW9yaWdpblwiKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLXJlcGVhdFwiKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogJGVsLmNzcyhcImJhY2tncm91bmQtc2l6ZVwiKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXZlcnQoJGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd3d3LCAkd3JhcHBlcjtcbiAgICAgICAgICAgIHd3dyA9ICRpbnB1dC5kYXRhKGtleXMud3d3KTtcbiAgICAgICAgICAgICR3cmFwcGVyID0gJGlucHV0LnBhcmVudCgpLmZpbHRlcih3d3cuc2VsZWN0b3JzLndyYXBwZXIpO1xuICAgICAgICAgICAgXy5lYWNoKCRpbnB1dC5kYXRhKGtleXMuYXR0cnMpLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgIF8uaXNVbmRlZmluZWQodmFsKSA/ICRpbnB1dC5yZW1vdmVBdHRyKGtleSkgOiAkaW5wdXQuYXR0cihrZXksIHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRpbnB1dC5yZW1vdmVEYXRhKGtleXMudHlwZWFoZWFkKS5yZW1vdmVEYXRhKGtleXMud3d3KS5yZW1vdmVEYXRhKGtleXMuYXR0cikucmVtb3ZlQ2xhc3Mod3d3LmNsYXNzZXMuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKCR3cmFwcGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRpbnB1dC5kZXRhY2goKS5pbnNlcnRBZnRlcigkd3JhcHBlcik7XG4gICAgICAgICAgICAgICAgJHdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gJGVsT3JOdWxsKG9iaikge1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQsICRlbDtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBfLmlzSlF1ZXJ5KG9iaikgfHwgXy5pc0VsZW1lbnQob2JqKTtcbiAgICAgICAgICAgICRlbCA9IGlzVmFsaWQgPyAkKG9iaikuZmlyc3QoKSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuICRlbC5sZW5ndGggPyAkZWwgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSkoKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy90eXBlYWhlYWQuanMvZGlzdC90eXBlYWhlYWQuanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiA3IDEyIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IDcgMTIiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYgNyAxMiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiA3IDEyIiwiLyohXG4gKiB0eXBlYWhlYWQuanMgMC4xMS4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdpdHRlci90eXBlYWhlYWQuanNcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgVHdpdHRlciwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVRcbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJibG9vZGhvdW5kXCIsIFsgXCJqcXVlcnlcIiBdLCBmdW5jdGlvbihhMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RbXCJCbG9vZGhvdW5kXCJdID0gZmFjdG9yeShhMCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RbXCJCbG9vZGhvdW5kXCJdID0gZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTXNpZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPyBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8obXNpZSB8cnY6KShcXGQrKC5cXGQrKT8pL2kpWzJdIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNCbGFua1N0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzdHIgfHwgL15cXHMqJC8udGVzdChzdHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVzY2FwZVJlZ0V4Q2hhcnM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBcnJheTogJC5pc0FycmF5LFxuICAgICAgICAgICAgaXNGdW5jdGlvbjogJC5pc0Z1bmN0aW9uLFxuICAgICAgICAgICAgaXNPYmplY3Q6ICQuaXNQbGFpbk9iamVjdCxcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VsZW1lbnQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0pRdWVyeTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9TdHI6IGZ1bmN0aW9uIHRvU3RyKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChzKSB8fCBzID09PSBudWxsID8gXCJcIiA6IHMgKyBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpbmQ6ICQucHJveHksXG4gICAgICAgICAgICBlYWNoOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYikge1xuICAgICAgICAgICAgICAgICQuZWFjaChjb2xsZWN0aW9uLCByZXZlcnNlQXJncyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmV2ZXJzZUFyZ3MoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXA6ICQubWFwLFxuICAgICAgICAgICAgZmlsdGVyOiAkLmdyZXAsXG4gICAgICAgICAgICBldmVyeTogZnVuY3Rpb24ob2JqLCB0ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gdGVzdC5jYWxsKG51bGwsIHZhbCwga2V5LCBvYmopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvbWU6IGZ1bmN0aW9uKG9iaiwgdGVzdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID0gdGVzdC5jYWxsKG51bGwsIHZhbCwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWl4aW46ICQuZXh0ZW5kLFxuICAgICAgICAgICAgaWRlbnRpdHk6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHRydWUsIHt9LCBvYmopO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldElkR2VuZXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGlmeTogZnVuY3Rpb24gdGVtcGxhdGlmeShvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5pc0Z1bmN0aW9uKG9iaikgPyBvYmogOiB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZlcjogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJvdW5jZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQsIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cywgbGF0ZXIsIGNhbGxOb3c7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0LCBhcmdzLCB0aW1lb3V0LCByZXN1bHQsIHByZXZpb3VzLCBsYXRlcjtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IDA7XG4gICAgICAgICAgICAgICAgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCksIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNTdHJpbmcodmFsKSA/IHZhbCA6IEpTT04uc3RyaW5naWZ5KHZhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7fVxuICAgICAgICB9O1xuICAgIH0oKTtcbiAgICB2YXIgVkVSU0lPTiA9IFwiMC4xMS4xXCI7XG4gICAgdmFyIHRva2VuaXplcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub253b3JkOiBub253b3JkLFxuICAgICAgICAgICAgd2hpdGVzcGFjZTogd2hpdGVzcGFjZSxcbiAgICAgICAgICAgIG9iajoge1xuICAgICAgICAgICAgICAgIG5vbndvcmQ6IGdldE9ialRva2VuaXplcihub253b3JkKSxcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlOiBnZXRPYmpUb2tlbml6ZXIod2hpdGVzcGFjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gd2hpdGVzcGFjZShzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IF8udG9TdHIoc3RyKTtcbiAgICAgICAgICAgIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vbndvcmQoc3RyKSB7XG4gICAgICAgICAgICBzdHIgPSBfLnRvU3RyKHN0cik7XG4gICAgICAgICAgICByZXR1cm4gc3RyID8gc3RyLnNwbGl0KC9cXFcrLykgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRPYmpUb2tlbml6ZXIodG9rZW5pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0S2V5KGtleXMpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gXy5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9rZW5pemUobykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChrZXlzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KHRva2VuaXplcihfLnRvU3RyKG9ba10pKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBMcnVDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgZnVuY3Rpb24gTHJ1Q2FjaGUobWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXhTaXplID0gXy5pc051bWJlcihtYXhTaXplKSA/IG1heFNpemUgOiAxMDA7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhTaXplIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRoaXMuZ2V0ID0gJC5ub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF8ubWl4aW4oTHJ1Q2FjaGUucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWlsSXRlbSA9IHRoaXMubGlzdC50YWlsLCBub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpemUgPj0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmUodGFpbEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5oYXNoW3RhaWxJdGVtLmtleV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9IHRoaXMuaGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3QubW92ZVRvRnJvbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBOb2RlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNoW2tleV0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3QubW92ZVRvRnJvbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNoID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ID0gbmV3IExpc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIExpc3QoKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF8ubWl4aW4oTGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbCB8fCBub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByZXYgPyBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dCA6IHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICBub2RlLm5leHQgPyBub2RlLm5leHQucHJldiA9IG5vZGUucHJldiA6IHRoaXMudGFpbCA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3ZlVG9Gcm9udDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gTm9kZShrZXksIHZhbCkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMucHJldiA9IHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExydUNhY2hlO1xuICAgIH0oKTtcbiAgICB2YXIgUGVyc2lzdGVudFN0b3JhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBMT0NBTF9TVE9SQUdFO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTE9DQUxfU1RPUkFHRSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICBMT0NBTF9TVE9SQUdFLnNldEl0ZW0oXCJ+fn5cIiwgXCIhXCIpO1xuICAgICAgICAgICAgTE9DQUxfU1RPUkFHRS5yZW1vdmVJdGVtKFwifn5+XCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIExPQ0FMX1NUT1JBR0UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFBlcnNpc3RlbnRTdG9yYWdlKG5hbWVzcGFjZSwgb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gWyBcIl9fXCIsIG5hbWVzcGFjZSwgXCJfX1wiIF0uam9pbihcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudHRsS2V5ID0gXCJfX3R0bF9fXCI7XG4gICAgICAgICAgICB0aGlzLmtleU1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgXy5lc2NhcGVSZWdFeENoYXJzKHRoaXMucHJlZml4KSk7XG4gICAgICAgICAgICB0aGlzLmxzID0gb3ZlcnJpZGUgfHwgTE9DQUxfU1RPUkFHRTtcbiAgICAgICAgICAgICF0aGlzLmxzICYmIHRoaXMuX25vb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKFBlcnNpc3RlbnRTdG9yYWdlLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgX3ByZWZpeDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4ICsga2V5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90dGxLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXgoa2V5KSArIHRoaXMudHRsS2V5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9ub29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldCA9IHRoaXMuc2V0ID0gdGhpcy5yZW1vdmUgPSB0aGlzLmNsZWFyID0gdGhpcy5pc0V4cGlyZWQgPSBfLm5vb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NhZmVTZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5scy5zZXRJdGVtKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub29wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0V4cGlyZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMubHMuZ2V0SXRlbSh0aGlzLl9wcmVmaXgoa2V5KSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIHR0bCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzTnVtYmVyKHR0bCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2FmZVNldCh0aGlzLl90dGxLZXkoa2V5KSwgZW5jb2RlKG5vdygpICsgdHRsKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5scy5yZW1vdmVJdGVtKHRoaXMuX3R0bEtleShrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NhZmVTZXQodGhpcy5fcHJlZml4KGtleSksIGVuY29kZSh2YWwpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMubHMucmVtb3ZlSXRlbSh0aGlzLl90dGxLZXkoa2V5KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5scy5yZW1vdmVJdGVtKHRoaXMuX3ByZWZpeChrZXkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGtleXMgPSBnYXRoZXJNYXRjaGluZ0tleXModGhpcy5rZXlNYXRjaGVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrZXlzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRXhwaXJlZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR0bCA9IGRlY29kZSh0aGlzLmxzLmdldEl0ZW0odGhpcy5fdHRsS2V5KGtleSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5pc051bWJlcih0dGwpICYmIG5vdygpID4gdHRsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbnRTdG9yYWdlO1xuICAgICAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KF8uaXNVbmRlZmluZWQodmFsKSA/IG51bGwgOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkLnBhcnNlSlNPTih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdhdGhlck1hdGNoaW5nS2V5cyhrZXlNYXRjaGVyKSB7XG4gICAgICAgICAgICB2YXIgaSwga2V5LCBrZXlzID0gW10sIGxlbiA9IExPQ0FMX1NUT1JBR0UubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChrZXkgPSBMT0NBTF9TVE9SQUdFLmtleShpKSkubWF0Y2goa2V5TWF0Y2hlcikpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleS5yZXBsYWNlKGtleU1hdGNoZXIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgVHJhbnNwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcGVuZGluZ1JlcXVlc3RzQ291bnQgPSAwLCBwZW5kaW5nUmVxdWVzdHMgPSB7fSwgbWF4UGVuZGluZ1JlcXVlc3RzID0gNiwgc2hhcmVkQ2FjaGUgPSBuZXcgTHJ1Q2FjaGUoMTApO1xuICAgICAgICBmdW5jdGlvbiBUcmFuc3BvcnQobykge1xuICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVxID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3NlbmQgPSBvLnRyYW5zcG9ydDtcbiAgICAgICAgICAgIHRoaXMuX2dldCA9IG8ubGltaXRlciA/IG8ubGltaXRlcih0aGlzLl9nZXQpIDogdGhpcy5fZ2V0O1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBvLmNhY2hlID09PSBmYWxzZSA/IG5ldyBMcnVDYWNoZSgwKSA6IHNoYXJlZENhY2hlO1xuICAgICAgICB9XG4gICAgICAgIFRyYW5zcG9ydC5zZXRNYXhQZW5kaW5nUmVxdWVzdHMgPSBmdW5jdGlvbiBzZXRNYXhQZW5kaW5nUmVxdWVzdHMobnVtKSB7XG4gICAgICAgICAgICBtYXhQZW5kaW5nUmVxdWVzdHMgPSBudW07XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zcG9ydC5yZXNldENhY2hlID0gZnVuY3Rpb24gcmVzZXRDYWNoZSgpIHtcbiAgICAgICAgICAgIHNoYXJlZENhY2hlLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIF8ubWl4aW4oVHJhbnNwb3J0LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgX2ZpbmdlcnByaW50OiBmdW5jdGlvbiBmaW5nZXJwcmludChvKSB7XG4gICAgICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8udXJsICsgby50eXBlICsgJC5wYXJhbShvLmRhdGEgfHwge30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXQ6IGZ1bmN0aW9uKG8sIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBmaW5nZXJwcmludCwganFYaHI7XG4gICAgICAgICAgICAgICAgZmluZ2VycHJpbnQgPSB0aGlzLl9maW5nZXJwcmludChvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQgfHwgZmluZ2VycHJpbnQgIT09IHRoaXMubGFzdFJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqcVhociA9IHBlbmRpbmdSZXF1ZXN0c1tmaW5nZXJwcmludF0pIHtcbiAgICAgICAgICAgICAgICAgICAganFYaHIuZG9uZShkb25lKS5mYWlsKGZhaWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVuZGluZ1JlcXVlc3RzQ291bnQgPCBtYXhQZW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3RzQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3RzW2ZpbmdlcnByaW50XSA9IHRoaXMuX3NlbmQobykuZG9uZShkb25lKS5mYWlsKGZhaWwpLmFsd2F5cyhhbHdheXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EZWNrUmVxdWVzdEFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUocmVzcCkge1xuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fY2FjaGUuc2V0KGZpbmdlcnByaW50LCByZXNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFsd2F5cygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3RzQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1tmaW5nZXJwcmludF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9uRGVja1JlcXVlc3RBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9nZXQuYXBwbHkodGhhdCwgdGhhdC5vbkRlY2tSZXF1ZXN0QXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9uRGVja1JlcXVlc3RBcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKG8sIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3AsIGZpbmdlcnByaW50O1xuICAgICAgICAgICAgICAgIGNiID0gY2IgfHwgJC5ub29wO1xuICAgICAgICAgICAgICAgIG8gPSBfLmlzU3RyaW5nKG8pID8ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IG9cbiAgICAgICAgICAgICAgICB9IDogbyB8fCB7fTtcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCA9IHRoaXMuX2ZpbmdlcnByaW50KG8pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVxID0gZmluZ2VycHJpbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3AgPSB0aGlzLl9jYWNoZS5nZXQoZmluZ2VycHJpbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldChvLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydDtcbiAgICB9KCk7XG4gICAgdmFyIFNlYXJjaEluZGV4ID0gd2luZG93LlNlYXJjaEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgQ0hJTERSRU4gPSBcImNcIiwgSURTID0gXCJpXCI7XG4gICAgICAgIGZ1bmN0aW9uIFNlYXJjaEluZGV4KG8pIHtcbiAgICAgICAgICAgIG8gPSBvIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFvLmRhdHVtVG9rZW5pemVyIHx8ICFvLnF1ZXJ5VG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgJC5lcnJvcihcImRhdHVtVG9rZW5pemVyIGFuZCBxdWVyeVRva2VuaXplciBhcmUgYm90aCByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZnkgPSBvLmlkZW50aWZ5IHx8IF8uc3RyaW5naWZ5O1xuICAgICAgICAgICAgdGhpcy5kYXR1bVRva2VuaXplciA9IG8uZGF0dW1Ub2tlbml6ZXI7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5VG9rZW5pemVyID0gby5xdWVyeVRva2VuaXplcjtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKFNlYXJjaEluZGV4LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgYm9vdHN0cmFwOiBmdW5jdGlvbiBib290c3RyYXAobykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0dW1zID0gby5kYXR1bXM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmllID0gby50cmllO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBkYXRhID0gXy5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFsgZGF0YSBdO1xuICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQsIHRva2VucztcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5kYXR1bXNbaWQgPSB0aGF0LmlkZW50aWZ5KGRhdHVtKV0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gbm9ybWFsaXplVG9rZW5zKHRoYXQuZGF0dW1Ub2tlbml6ZXIoZGF0dW0pKTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRva2VucywgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBjaGFycywgY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhhdC50cmllO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSB0b2tlbi5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9IGNoYXJzLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtDSElMRFJFTl1bY2hdIHx8IChub2RlW0NISUxEUkVOXVtjaF0gPSBuZXdOb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbSURTXS5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaWRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfLm1hcChpZHMsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmRhdHVtc1tpZF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHRva2VucywgbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSBub3JtYWxpemVUb2tlbnModGhpcy5xdWVyeVRva2VuaXplcihxdWVyeSkpO1xuICAgICAgICAgICAgICAgIF8uZWFjaCh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBjaGFycywgY2gsIGlkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhhdC50cmllO1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IHRva2VuLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAmJiAoY2ggPSBjaGFycy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVbQ0hJTERSRU5dW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBjaGFycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcyA9IG5vZGVbSURTXS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzID8gZ2V0SW50ZXJzZWN0aW9uKG1hdGNoZXMsIGlkcykgOiBpZHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcyA/IF8ubWFwKHVuaXF1ZShtYXRjaGVzKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZGF0dW1zW2lkXTtcbiAgICAgICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbDogZnVuY3Rpb24gYWxsKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXR1bXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kYXR1bXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0dW1zID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy50cmllID0gbmV3Tm9kZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtczogdGhpcy5kYXR1bXMsXG4gICAgICAgICAgICAgICAgICAgIHRyaWU6IHRoaXMudHJpZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU2VhcmNoSW5kZXg7XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgICAgIHRva2VucyA9IF8uZmlsdGVyKHRva2VucywgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0b2tlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5zID0gXy5tYXAodG9rZW5zLCBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHt9O1xuICAgICAgICAgICAgbm9kZVtJRFNdID0gW107XG4gICAgICAgICAgICBub2RlW0NISUxEUkVOXSA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgc2VlbiA9IHt9LCB1bmlxdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bYXJyYXlbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlcy5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24oYXJyYXlBLCBhcnJheUIpIHtcbiAgICAgICAgICAgIHZhciBhaSA9IDAsIGJpID0gMCwgaW50ZXJzZWN0aW9uID0gW107XG4gICAgICAgICAgICBhcnJheUEgPSBhcnJheUEuc29ydCgpO1xuICAgICAgICAgICAgYXJyYXlCID0gYXJyYXlCLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBsZW5BcnJheUEgPSBhcnJheUEubGVuZ3RoLCBsZW5BcnJheUIgPSBhcnJheUIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGFpIDwgbGVuQXJyYXlBICYmIGJpIDwgbGVuQXJyYXlCKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5QVthaV0gPCBhcnJheUJbYmldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJheUFbYWldID4gYXJyYXlCW2JpXSkge1xuICAgICAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5wdXNoKGFycmF5QVthaV0pO1xuICAgICAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIFByZWZldGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAga2V5cyA9IHtcbiAgICAgICAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgICAgICAgcHJvdG9jb2w6IFwicHJvdG9jb2xcIixcbiAgICAgICAgICAgIHRodW1icHJpbnQ6IFwidGh1bWJwcmludFwiXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIFByZWZldGNoKG8pIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gby51cmw7XG4gICAgICAgICAgICB0aGlzLnR0bCA9IG8udHRsO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG8uY2FjaGU7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmUgPSBvLnByZXBhcmU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG8udHJhbnNmb3JtO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBvLnRyYW5zcG9ydDtcbiAgICAgICAgICAgIHRoaXMudGh1bWJwcmludCA9IG8udGh1bWJwcmludDtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBQZXJzaXN0ZW50U3RvcmFnZShvLmNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKFByZWZldGNoLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgX3NldHRpbmdzOiBmdW5jdGlvbiBzZXR0aW5ncygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3JlOiBmdW5jdGlvbiBzdG9yZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChrZXlzLmRhdGEsIGRhdGEsIHRoaXMudHRsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGtleXMucHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sLCB0aGlzLnR0bCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChrZXlzLnRodW1icHJpbnQsIHRoaXMudGh1bWJwcmludCwgdGhpcy50dGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb21DYWNoZTogZnVuY3Rpb24gZnJvbUNhY2hlKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZWQgPSB7fSwgaXNFeHBpcmVkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcmVkLmRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0KGtleXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RvcmVkLnByb3RvY29sID0gdGhpcy5zdG9yYWdlLmdldChrZXlzLnByb3RvY29sKTtcbiAgICAgICAgICAgICAgICBzdG9yZWQudGh1bWJwcmludCA9IHRoaXMuc3RvcmFnZS5nZXQoa2V5cy50aHVtYnByaW50KTtcbiAgICAgICAgICAgICAgICBpc0V4cGlyZWQgPSBzdG9yZWQudGh1bWJwcmludCAhPT0gdGhpcy50aHVtYnByaW50IHx8IHN0b3JlZC5wcm90b2NvbCAhPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlZC5kYXRhICYmICFpc0V4cGlyZWQgPyBzdG9yZWQuZGF0YSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbU5ldHdvcms6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnByZXBhcmUodGhpcy5fc2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQoc2V0dGluZ3MpLmZhaWwob25FcnJvcikuZG9uZShvblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25SZXNwb25zZShyZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHRoYXQudHJhbnNmb3JtKHJlc3ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByZWZldGNoO1xuICAgIH0oKTtcbiAgICB2YXIgUmVtb3RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBSZW1vdGUobykge1xuICAgICAgICAgICAgdGhpcy51cmwgPSBvLnVybDtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZSA9IG8ucHJlcGFyZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gby50cmFuc2Zvcm07XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnQoe1xuICAgICAgICAgICAgICAgIGNhY2hlOiBvLmNhY2hlLFxuICAgICAgICAgICAgICAgIGxpbWl0ZXI6IG8ubGltaXRlcixcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IG8udHJhbnNwb3J0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKFJlbW90ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIF9zZXR0aW5nczogZnVuY3Rpb24gc2V0dGluZ3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChxdWVyeSwgY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHNldHRpbmdzO1xuICAgICAgICAgICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5IHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnByZXBhcmUocXVlcnksIHRoaXMuX3NldHRpbmdzKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5nZXQoc2V0dGluZ3MsIG9uUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2UoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA/IGNiKFtdKSA6IGNiKHRoYXQudHJhbnNmb3JtKHJlc3ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsTGFzdFJlcXVlc3Q6IGZ1bmN0aW9uIGNhbmNlbExhc3RSZXF1ZXN0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlbW90ZTtcbiAgICB9KCk7XG4gICAgdmFyIG9QYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZShvKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMsIHNvcnRlcjtcbiAgICAgICAgICAgIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgaWRlbnRpZnk6IF8uc3RyaW5naWZ5LFxuICAgICAgICAgICAgICAgIGRhdHVtVG9rZW5pemVyOiBudWxsLFxuICAgICAgICAgICAgICAgIHF1ZXJ5VG9rZW5pemVyOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1ZmZpY2llbnQ6IDUsXG4gICAgICAgICAgICAgICAgc29ydGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBbXSxcbiAgICAgICAgICAgICAgICBwcmVmZXRjaDogbnVsbCxcbiAgICAgICAgICAgICAgICByZW1vdGU6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvID0gXy5taXhpbihkZWZhdWx0cywgbyB8fCB7fSk7XG4gICAgICAgICAgICAhby5kYXR1bVRva2VuaXplciAmJiAkLmVycm9yKFwiZGF0dW1Ub2tlbml6ZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICAhby5xdWVyeVRva2VuaXplciAmJiAkLmVycm9yKFwicXVlcnlUb2tlbml6ZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICBzb3J0ZXIgPSBvLnNvcnRlcjtcbiAgICAgICAgICAgIG8uc29ydGVyID0gc29ydGVyID8gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnNvcnQoc29ydGVyKTtcbiAgICAgICAgICAgIH0gOiBfLmlkZW50aXR5O1xuICAgICAgICAgICAgby5sb2NhbCA9IF8uaXNGdW5jdGlvbihvLmxvY2FsKSA/IG8ubG9jYWwoKSA6IG8ubG9jYWw7XG4gICAgICAgICAgICBvLnByZWZldGNoID0gcGFyc2VQcmVmZXRjaChvLnByZWZldGNoKTtcbiAgICAgICAgICAgIG8ucmVtb3RlID0gcGFyc2VSZW1vdGUoby5yZW1vdGUpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUHJlZmV0Y2gobykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRzO1xuICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgICAgICAgICAgdHRsOiAyNCAqIDYwICogNjAgKiAxZTMsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgdGh1bWJwcmludDogXCJcIixcbiAgICAgICAgICAgICAgICBwcmVwYXJlOiBfLmlkZW50aXR5LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvID0gXy5pc1N0cmluZyhvKSA/IHtcbiAgICAgICAgICAgICAgICB1cmw6IG9cbiAgICAgICAgICAgIH0gOiBvO1xuICAgICAgICAgICAgbyA9IF8ubWl4aW4oZGVmYXVsdHMsIG8pO1xuICAgICAgICAgICAgIW8udXJsICYmICQuZXJyb3IoXCJwcmVmZXRjaCByZXF1aXJlcyB1cmwgdG8gYmUgc2V0XCIpO1xuICAgICAgICAgICAgby50cmFuc2Zvcm0gPSBvLmZpbHRlciB8fCBvLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIG8uY2FjaGVLZXkgPSBvLmNhY2hlS2V5IHx8IG8udXJsO1xuICAgICAgICAgICAgby50aHVtYnByaW50ID0gVkVSU0lPTiArIG8udGh1bWJwcmludDtcbiAgICAgICAgICAgIG8udHJhbnNwb3J0ID0gby50cmFuc3BvcnQgPyBjYWxsYmFja1RvRGVmZXJyZWQoby50cmFuc3BvcnQpIDogJC5hamF4O1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VSZW1vdGUobykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRzO1xuICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZXBhcmU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVwbGFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3aWxkY2FyZDogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW1pdGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIHJhdGVMaW1pdEJ5OiBcImRlYm91bmNlXCIsXG4gICAgICAgICAgICAgICAgcmF0ZUxpbWl0V2FpdDogMzAwLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvID0gXy5pc1N0cmluZyhvKSA/IHtcbiAgICAgICAgICAgICAgICB1cmw6IG9cbiAgICAgICAgICAgIH0gOiBvO1xuICAgICAgICAgICAgbyA9IF8ubWl4aW4oZGVmYXVsdHMsIG8pO1xuICAgICAgICAgICAgIW8udXJsICYmICQuZXJyb3IoXCJyZW1vdGUgcmVxdWlyZXMgdXJsIHRvIGJlIHNldFwiKTtcbiAgICAgICAgICAgIG8udHJhbnNmb3JtID0gby5maWx0ZXIgfHwgby50cmFuc2Zvcm07XG4gICAgICAgICAgICBvLnByZXBhcmUgPSB0b1JlbW90ZVByZXBhcmUobyk7XG4gICAgICAgICAgICBvLmxpbWl0ZXIgPSB0b0xpbWl0ZXIobyk7XG4gICAgICAgICAgICBvLnRyYW5zcG9ydCA9IG8udHJhbnNwb3J0ID8gY2FsbGJhY2tUb0RlZmVycmVkKG8udHJhbnNwb3J0KSA6ICQuYWpheDtcbiAgICAgICAgICAgIGRlbGV0ZSBvLnJlcGxhY2U7XG4gICAgICAgICAgICBkZWxldGUgby53aWxkY2FyZDtcbiAgICAgICAgICAgIGRlbGV0ZSBvLnJhdGVMaW1pdEJ5O1xuICAgICAgICAgICAgZGVsZXRlIG8ucmF0ZUxpbWl0V2FpdDtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvUmVtb3RlUHJlcGFyZShvKSB7XG4gICAgICAgICAgICB2YXIgcHJlcGFyZSwgcmVwbGFjZSwgd2lsZGNhcmQ7XG4gICAgICAgICAgICBwcmVwYXJlID0gby5wcmVwYXJlO1xuICAgICAgICAgICAgcmVwbGFjZSA9IG8ucmVwbGFjZTtcbiAgICAgICAgICAgIHdpbGRjYXJkID0gby53aWxkY2FyZDtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXBhcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgICAgIHByZXBhcmUgPSBwcmVwYXJlQnlSZXBsYWNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvLndpbGRjYXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlcGFyZSA9IHByZXBhcmVCeVdpbGRjYXJkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVwYXJlID0gaWRlbml0eVByZXBhcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVCeVJlcGxhY2UocXVlcnksIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudXJsID0gcmVwbGFjZShzZXR0aW5ncy51cmwsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlQnlXaWxkY2FyZChxdWVyeSwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy51cmwgPSBzZXR0aW5ncy51cmwucmVwbGFjZSh3aWxkY2FyZCwgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaWRlbml0eVByZXBhcmUocXVlcnksIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvTGltaXRlcihvKSB7XG4gICAgICAgICAgICB2YXIgbGltaXRlciwgbWV0aG9kLCB3YWl0O1xuICAgICAgICAgICAgbGltaXRlciA9IG8ubGltaXRlcjtcbiAgICAgICAgICAgIG1ldGhvZCA9IG8ucmF0ZUxpbWl0Qnk7XG4gICAgICAgICAgICB3YWl0ID0gby5yYXRlTGltaXRXYWl0O1xuICAgICAgICAgICAgaWYgKCFsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgbGltaXRlciA9IC9edGhyb3R0bGUkL2kudGVzdChtZXRob2QpID8gdGhyb3R0bGUod2FpdCkgOiBkZWJvdW5jZSh3YWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW1pdGVyO1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVib3VuY2Uod2FpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kZWJvdW5jZShmbiwgd2FpdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRocm90dGxlKHdhaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGUoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8udGhyb3R0bGUoZm4sIHdhaXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2tUb0RlZmVycmVkKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcHBlcihvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGZuKG8sIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBCbG9vZGhvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb2xkO1xuICAgICAgICBvbGQgPSB3aW5kb3cgJiYgd2luZG93LkJsb29kaG91bmQ7XG4gICAgICAgIGZ1bmN0aW9uIEJsb29kaG91bmQobykge1xuICAgICAgICAgICAgbyA9IG9QYXJzZXIobyk7XG4gICAgICAgICAgICB0aGlzLnNvcnRlciA9IG8uc29ydGVyO1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmeSA9IG8uaWRlbnRpZnk7XG4gICAgICAgICAgICB0aGlzLnN1ZmZpY2llbnQgPSBvLnN1ZmZpY2llbnQ7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gby5sb2NhbDtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlID0gby5yZW1vdGUgPyBuZXcgUmVtb3RlKG8ucmVtb3RlKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByZWZldGNoID0gby5wcmVmZXRjaCA/IG5ldyBQcmVmZXRjaChvLnByZWZldGNoKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFNlYXJjaEluZGV4KHtcbiAgICAgICAgICAgICAgICBpZGVudGlmeTogdGhpcy5pZGVudGlmeSxcbiAgICAgICAgICAgICAgICBkYXR1bVRva2VuaXplcjogby5kYXR1bVRva2VuaXplcixcbiAgICAgICAgICAgICAgICBxdWVyeVRva2VuaXplcjogby5xdWVyeVRva2VuaXplclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvLmluaXRpYWxpemUgIT09IGZhbHNlICYmIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIEJsb29kaG91bmQubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICAgICAgICB3aW5kb3cgJiYgKHdpbmRvdy5CbG9vZGhvdW5kID0gb2xkKTtcbiAgICAgICAgICAgIHJldHVybiBCbG9vZGhvdW5kO1xuICAgICAgICB9O1xuICAgICAgICBCbG9vZGhvdW5kLnRva2VuaXplcnMgPSB0b2tlbml6ZXJzO1xuICAgICAgICBfLm1peGluKEJsb29kaG91bmQucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBfX3R0QWRhcHRlcjogZnVuY3Rpb24gdHRBZGFwdGVyKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGUgPyB3aXRoQXN5bmMgOiB3aXRob3V0QXN5bmM7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aEFzeW5jKHF1ZXJ5LCBzeW5jLCBhc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZWFyY2gocXVlcnksIHN5bmMsIGFzeW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aG91dEFzeW5jKHF1ZXJ5LCBzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnNlYXJjaChxdWVyeSwgc3luYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2FkUHJlZmV0Y2g6IGZ1bmN0aW9uIGxvYWRQcmVmZXRjaCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGRlZmVycmVkLCBzZXJpYWxpemVkO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJpYWxpemVkID0gdGhpcy5wcmVmZXRjaC5mcm9tQ2FjaGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LmJvb3RzdHJhcChzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZmV0Y2guZnJvbU5ldHdvcmsoZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnByZWZldGNoLnN0b3JlKHRoYXQuaW5kZXguc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgZGVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICh0aGlzLmluaXRQcm9taXNlID0gdGhpcy5fbG9hZFByZWZldGNoKCkpLmRvbmUoYWRkTG9jYWxUb0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRMb2NhbFRvSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKHRoYXQubG9jYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmluaXRQcm9taXNlIHx8IGZvcmNlID8gdGhpcy5faW5pdGlhbGl6ZSgpIDogdGhpcy5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5hZGQoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaWRzKSB7XG4gICAgICAgICAgICAgICAgaWRzID0gXy5pc0FycmF5KGlkcykgPyBpZHMgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0KGlkcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2gocXVlcnksIHN5bmMsIGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBsb2NhbDtcbiAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMuc29ydGVyKHRoaXMuaW5kZXguc2VhcmNoKHF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgc3luYyh0aGlzLnJlbW90ZSA/IGxvY2FsLnNsaWNlKCkgOiBsb2NhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVtb3RlICYmIGxvY2FsLmxlbmd0aCA8IHRoaXMuc3VmZmljaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZS5nZXQocXVlcnksIHByb2Nlc3NSZW1vdGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdGUuY2FuY2VsTGFzdFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1JlbW90ZShyZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkR1cGxpY2F0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHJlbW90ZSwgZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgIV8uc29tZShsb2NhbCwgZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmlkZW50aWZ5KHIpID09PSB0aGF0LmlkZW50aWZ5KGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgJiYgbm9uRHVwbGljYXRlcy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgJiYgYXN5bmMobm9uRHVwbGljYXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbDogZnVuY3Rpb24gYWxsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4LmFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJQcmVmZXRjaENhY2hlOiBmdW5jdGlvbiBjbGVhclByZWZldGNoQ2FjaGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVmZXRjaCAmJiB0aGlzLnByZWZldGNoLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJSZW1vdGVDYWNoZTogZnVuY3Rpb24gY2xlYXJSZW1vdGVDYWNoZSgpIHtcbiAgICAgICAgICAgICAgICBUcmFuc3BvcnQucmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR0QWRhcHRlcjogZnVuY3Rpb24gdHRBZGFwdGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdHRBZGFwdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQmxvb2Rob3VuZDtcbiAgICB9KCk7XG4gICAgcmV0dXJuIEJsb29kaG91bmQ7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvdHlwZWFoZWFkLmpzL2Rpc3QvYmxvb2Rob3VuZC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYgNyAxMiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VuZGVmaW5lZCA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9ub29wXCIpKCk7IC8vIFN1cHBvcnQgRVMzIGVuZ2luZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XG4gcmV0dXJuICh2YWwgIT09IF91bmRlZmluZWQpICYmICh2YWwgIT09IG51bGwpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9pcy12YWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gT2JqZWN0LmFzc2lnblxuXHQ6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKSA/IFN5bWJvbCA6IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEFjY2Vzc2libGUgdGFiIGludGVyZmFjZVxuLyogQ291cnRlc3kgb2YgaHR0cDovL2hleWRvbndvcmtzLmNvbS9wcmFjdGljYWxfYXJpYV9leGFtcGxlcy9cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIFVSSSA9IHJlcXVpcmUoJ3VyaWpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXZlbnRzJyk7XG5cbnZhciBhbmFseXRpY3MgPSByZXF1aXJlKCcuLi9tb2R1bGVzLy9hbmFseXRpY3MnKTtcblxuLy8gVGhlIGNsYXNzIGZvciB0aGUgY29udGFpbmVyIGRpdlxuXG52YXIgJGNvbnRhaW5lciA9ICcudGFiLWludGVyZmFjZSc7XG5cbmZ1bmN0aW9uIHNob3coJHRhcmdldCwgcHVzaCkge1xuICAvLyBUb2dnbGUgdGFic1xuICAkKCdbcm9sZT1cInRhYlwiXScpLmF0dHIoe1xuICAgICdhcmlhLXNlbGVjdGVkJzogbnVsbFxuICB9KTtcbiAgJHRhcmdldC5hdHRyKHtcbiAgICAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyxcbiAgfSk7XG5cbiAgLy8gVG9nZ2xlIHBhbmVsc1xuICAkKCRjb250YWluZXIgKyAnIFtyb2xlPVwidGFicGFuZWxcIl0nKS5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gIHZhciAkcGFuZWwgPSAkKCcjJyArICR0YXJnZXQuYXR0cignaHJlZicpLnN1YnN0cmluZygxKSk7XG4gICRwYW5lbC5hdHRyKCdhcmlhLWhpZGRlbicsIG51bGwpO1xuXG4gIHZhciBuYW1lID0gJHRhcmdldC5jbG9zZXN0KCdbcm9sZT1cInRhYmxpc3RcIl0nKS5hdHRyKCdkYXRhLW5hbWUnKTtcbiAgdmFyIHZhbHVlID0gJHRhcmdldC5hdHRyKCdkYXRhLW5hbWUnKTtcblxuICBpZiAocHVzaCkge1xuICAgIHZhciBxdWVyeSA9IF8uZXh0ZW5kKFxuICAgICAgVVJJLnBhcnNlUXVlcnkod2luZG93LmxvY2F0aW9uLnNlYXJjaCksXG4gICAgICBfLm9iamVjdChbW25hbWUsIHZhbHVlXV0pXG4gICAgKTtcbiAgICB2YXIgc2VhcmNoID0gVVJJKCcnKS5xdWVyeShxdWVyeSkudG9TdHJpbmcoKTtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUocXVlcnksIHNlYXJjaCwgc2VhcmNoIHx8IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgYW5hbHl0aWNzLnBhZ2VWaWV3KCk7XG4gIH1cblxuICBldmVudHMuZW1pdCgndGFicy5zaG93LicgKyB2YWx1ZSwgeyR0YWI6ICR0YXJnZXQsICRwYW5lbDogJHBhbmVsfSk7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hUYWJzKCkge1xuICB2YXIgcXVlcnkgPSBVUkkucGFyc2VRdWVyeSh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgJCgndWxbcm9sZT1cInRhYmxpc3RcIl0nKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCB0YWJzKSB7XG4gICAgdmFyICR0YWJzID0gJCh0YWJzKTtcbiAgICB2YXIgbmFtZSA9ICR0YWJzLmF0dHIoJ2RhdGEtbmFtZScpO1xuICAgIHZhciAkdGFyZ2V0ID0gcXVlcnlbbmFtZV0gP1xuICAgICAgJHRhYnMuZmluZCgnW3JvbGU9XCJ0YWJcIl1bZGF0YS1uYW1lPVwiJyArIHF1ZXJ5W25hbWVdICsgJ1wiXScpIDpcbiAgICAgICR0YWJzLmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZXEoMCk7XG4gICAgaWYgKCR0YXJnZXQubGVuZ3RoKSB7XG4gICAgICBzaG93KCR0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCdbcm9sZT1cInRhYnBhbmVsXCJdJykuYXR0cignYXJpYS1oaWRkZW4nLCBudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblNob3coJGVsbSwgY2FsbGJhY2spIHtcbiAgdmFyICRwYW5lbCA9ICRlbG0uY2xvc2VzdCgnW3JvbGU9XCJ0YWJwYW5lbFwiXScpO1xuICBpZiAoJHBhbmVsLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgJHRyaWdnZXIgPSAkKCdbaHJlZj1cIiMnICsgJHBhbmVsLmF0dHIoJ2lkJykgKyAnXCJdJyk7XG4gICAgdmFyIGV2ZW50ID0gJ3RhYnMuc2hvdy4nICsgJHRyaWdnZXIuYXR0cignZGF0YS1uYW1lJyk7XG4gICAgZXZlbnRzLm9uY2UoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuICAvLyBIYW5kbGUgY2xpY2sgb24gdGFiIHRvIHNob3cgKyBmb2N1cyB0YWJwYW5lbFxuICAkKCdbcm9sZT1cInRhYlwiXScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2hvdygkKHRoaXMpLCB0cnVlKTtcbiAgfSk7XG5cbiAgJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHJlZnJlc2hUYWJzKTtcbiAgcmVmcmVzaFRhYnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9uU2hvdzogb25TaG93LFxuICBpbml0OiBpbml0LFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy92ZW5kb3IvdGFibGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA2IDEzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgb2JqKSB7XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0czEgLyosIOKApm9wdGlvbnMqLykge1xuXHR2YXIgcmVzdWx0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGlmICghaXNWYWx1ZShvcHRpb25zKSkgcmV0dXJuO1xuXHRcdHByb2Nlc3MoT2JqZWN0KG9wdGlvbnMpLCByZXN1bHQpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgLCBpZCA9IG9ialRvU3RyaW5nLmNhbGwoXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cztcblx0fSkoKVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChcIlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHxcblx0XHQodmFsdWUgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdFx0KHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZCkpIHx8XG5cdFx0ZmFsc2Vcblx0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyBPYmplY3Quc2V0UHJvdG90eXBlT2Zcblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gRGVwcmVjYXRlZFxuXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgbm9ybWFsaXplT3B0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zJylcbiAgLCBpc0NhbGxhYmxlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUnKVxuICAsIGNvbnRhaW5zICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zJylcblxuICAsIGQ7XG5cbmQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkc2NyLCB2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIHcsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICgoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHx8ICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpKSB7XG5cdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdHZhbHVlID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0XHR3ID0gY29udGFpbnMuY2FsbChkc2NyLCAndycpO1xuXHR9XG5cblx0ZGVzYyA9IHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUsIHdyaXRhYmxlOiB3IH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG5kLmdzID0gZnVuY3Rpb24gKGRzY3IsIGdldCwgc2V0LyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgb3B0aW9ucywgZGVzYztcblx0aWYgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gZ2V0O1xuXHRcdGdldCA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcblx0fVxuXHRpZiAoZ2V0ID09IG51bGwpIHtcblx0XHRnZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoZ2V0KSkge1xuXHRcdG9wdGlvbnMgPSBnZXQ7XG5cdFx0Z2V0ID0gc2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKHNldCA9PSBudWxsKSB7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKHNldCkpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0fVxuXG5cdGRlc2MgPSB7IGdldDogZ2V0LCBzZXQ6IHNldCwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlIH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9ub2RlX21vZHVsZXMvZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogQG1vZHVsZSBJY2ljbGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGZyZWV6ZTogbG9jayxcclxuXHR1bmZyZWV6ZTogdW5sb2NrLFxyXG5cdGlzRnJvemVuOiBpc0xvY2tlZFxyXG59O1xyXG5cclxuXHJcbi8qKiBTZXQgb2YgdGFyZ2V0cyAgKi9cclxudmFyIGxvY2tDYWNoZSA9IG5ldyBXZWFrTWFwO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgZmxhZyBvbiB0YXJnZXQgd2l0aCB0aGUgbmFtZSBwYXNzZWRcclxuICpcclxuICogQHJldHVybiB7Ym9vbH0gV2hldGhlciBsb2NrIHN1Y2NlZWRlZFxyXG4gKi9cclxuZnVuY3Rpb24gbG9jayh0YXJnZXQsIG5hbWUpe1xyXG5cdHZhciBsb2NrcyA9IGxvY2tDYWNoZS5nZXQodGFyZ2V0KTtcclxuXHRpZiAobG9ja3MgJiYgbG9ja3NbbmFtZV0pIHJldHVybiBmYWxzZTtcclxuXHJcblx0Ly9jcmVhdGUgbG9jayBzZXQgZm9yIGEgdGFyZ2V0LCBpZiBub25lXHJcblx0aWYgKCFsb2Nrcykge1xyXG5cdFx0bG9ja3MgPSB7fTtcclxuXHRcdGxvY2tDYWNoZS5zZXQodGFyZ2V0LCBsb2Nrcyk7XHJcblx0fVxyXG5cclxuXHQvL3NldCBhIG5ldyBsb2NrXHJcblx0bG9ja3NbbmFtZV0gPSB0cnVlO1xyXG5cclxuXHQvL3JldHVybiBzdWNjZXNzXHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVW5zZXQgZmxhZyBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIG5hbWUgcGFzc2VkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgaWYgdG8gcmV0dXJuIG5ldyB2YWx1ZSBmcm9tIHRoZSBsb2NrL3VubG9jayxcclxuICogdGhlbiB1bmxvY2sgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIGFuZCBsb2NrIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlLFxyXG4gKiB3aGljaCBpcyB1c2VsZXNzIGZvciB0aGUgdXNlciwgdGhvdWdoIG1heWJlIGludHVpdGl2ZS5cclxuICpcclxuICogQHBhcmFtIHsqfSB0YXJnZXQgQW55IG9iamVjdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIGZsYWcgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sfSBXaGV0aGVyIHVubG9jayBmYWlsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmxvY2sodGFyZ2V0LCBuYW1lKXtcclxuXHR2YXIgbG9ja3MgPSBsb2NrQ2FjaGUuZ2V0KHRhcmdldCk7XHJcblx0aWYgKCFsb2NrcyB8fCAhbG9ja3NbbmFtZV0pIHJldHVybiBmYWxzZTtcclxuXHJcblx0bG9ja3NbbmFtZV0gPSBudWxsO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gd2hldGhlciBmbGFnIGlzIHNldFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHRhcmdldCBBbnkgb2JqZWN0IHRvIGFzc29jaWF0ZSBsb2NrIHdpdGhcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBmbGFnIG5hbWVcclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBsb2NrZWQgb3Igbm90XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvY2tlZCh0YXJnZXQsIG5hbWUpe1xyXG5cdHZhciBsb2NrcyA9IGxvY2tDYWNoZS5nZXQodGFyZ2V0KTtcclxuXHRyZXR1cm4gKGxvY2tzICYmIGxvY2tzW25hbWVdKTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9pY2ljbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXHJcbiAqIEEgc3RvcmFnZSBvZiBwZXItdGFyZ2V0IGNhbGxiYWNrcy5cclxuICogV2Vha01hcCBpcyB0aGUgbW9zdCBzYWZlIHNvbHV0aW9uLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGVtbXkvbGlzdGVuZXJzXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0eSBuYW1lIHRvIHByb3ZpZGUgb24gdGFyZ2V0cy5cclxuICpcclxuICogQ2Fu4oCZdCB1c2UgZ2xvYmFsIFdlYWtNYXAgLVxyXG4gKiBpdCBpcyBpbXBvc3NpYmxlIHRvIHByb3ZpZGUgc2luZ2xldG9uIGdsb2JhbCBjYWNoZSBvZiBjYWxsYmFja3MgZm9yIHRhcmdldHNcclxuICogbm90IHBvbGx1dGluZyBnbG9iYWwgc2NvcGUuIFNvIGl0IGlzIGJldHRlciB0byBwb2xsdXRlIHRhcmdldCBzY29wZSB0aGFuIHRoZSBnbG9iYWwuXHJcbiAqXHJcbiAqIE90aGVyd2lzZSwgZWFjaCBlbW15IGluc3RhbmNlIHdpbGwgY3JlYXRlIGl04oCZcyBvd24gY2FjaGUsIHdoaWNoIGxlYWRzIHRvIG1lc3MuXHJcbiAqXHJcbiAqIEFsc28gY2Fu4oCZdCB1c2UgYC5fZXZlbnRzYCBwcm9wZXJ0eSBvbiB0YXJnZXRzLCBhcyBpdCBpcyBkb25lIGluIGBldmVudHNgIG1vZHVsZSxcclxuICogYmVjYXVzZSBpdCBpcyBpbmNvbXBhdGlibGUuIEVtbXkgdGFyZ2V0cyB1bml2ZXJzYWwgZXZlbnRzIHdyYXBwZXIsIG5vdCB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKi9cclxuLy9GSVhNRTogbmV3IG5wbSBmb3JjZXMgZmxhdCBtb2R1bGVzIHN0cnVjdHVyZSwgc28gd2Vha21hcHMgYXJlIGJldHRlciBwcm92aWRpbmcgdGhhdCB0aGVyZeKAmXMgdGhlIG9uZSBlbW15IGFjcm9zcyB0aGUgcHJvamVjdC5cclxudmFyIGNiUHJvcE5hbWUgPSAnX2NhbGxiYWNrcyc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCBsaXN0ZW5lcnMgZm9yIHRoZSB0YXJnZXQvZXZ0IChvcHRpb25hbGx5KS5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBhIHRhcmdldCBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9PyBldnQgYW4gZXZ0IG5hbWUsIGlmIHVuZGVmaW5lZCAtIHJldHVybiBvYmplY3Qgd2l0aCBldmVudHNcclxuICpcclxuICogQHJldHVybiB7KG9iamVjdHxhcnJheSl9IExpc3Qvc2V0IG9mIGxpc3RlbmVyc1xyXG4gKi9cclxuZnVuY3Rpb24gbGlzdGVuZXJzKHRhcmdldCwgZXZ0LCB0YWdzKXtcclxuXHR2YXIgY2JzID0gdGFyZ2V0W2NiUHJvcE5hbWVdO1xyXG5cdHZhciByZXN1bHQ7XHJcblxyXG5cdGlmICghZXZ0KSB7XHJcblx0XHRyZXN1bHQgPSBjYnMgfHwge307XHJcblxyXG5cdFx0Ly9maWx0ZXIgY2JzIGJ5IHRhZ3NcclxuXHRcdGlmICh0YWdzKSB7XHJcblx0XHRcdHZhciBmaWx0ZXJlZFJlc3VsdCA9IHt9O1xyXG5cdFx0XHRmb3IgKHZhciBldnQgaW4gcmVzdWx0KSB7XHJcblx0XHRcdFx0ZmlsdGVyZWRSZXN1bHRbZXZ0XSA9IHJlc3VsdFtldnRdLmZpbHRlcihmdW5jdGlvbiAoY2IpIHtcclxuXHRcdFx0XHRcdHJldHVybiBoYXNUYWdzKGNiLCB0YWdzKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXN1bHQgPSBmaWx0ZXJlZFJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0aWYgKCFjYnMgfHwgIWNic1tldnRdKSB7XHJcblx0XHRyZXR1cm4gW107XHJcblx0fVxyXG5cclxuXHRyZXN1bHQgPSBjYnNbZXZ0XTtcclxuXHJcblx0Ly9pZiB0aGVyZSBhcmUgZXZ0IG5hbWVzcGFjZXMgc3BlY2lmaWVkIC0gZmlsdGVyIGNhbGxiYWNrc1xyXG5cdGlmICh0YWdzICYmIHRhZ3MubGVuZ3RoKSB7XHJcblx0XHRyZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChjYikge1xyXG5cdFx0XHRyZXR1cm4gaGFzVGFncyhjYiwgdGFncyk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlIGxpc3RlbmVyLCBpZiBhbnlcclxuICovXHJcbmxpc3RlbmVycy5yZW1vdmUgPSBmdW5jdGlvbih0YXJnZXQsIGV2dCwgY2IsIHRhZ3Mpe1xyXG5cdC8vZ2V0IGNhbGxiYWNrcyBmb3IgdGhlIGV2dFxyXG5cdHZhciBldnRDYWxsYmFja3MgPSB0YXJnZXRbY2JQcm9wTmFtZV07XHJcblx0aWYgKCFldnRDYWxsYmFja3MgfHwgIWV2dENhbGxiYWNrc1tldnRdKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdHZhciBjYWxsYmFja3MgPSBldnRDYWxsYmFja3NbZXZ0XTtcclxuXHJcblx0Ly9pZiB0YWdzIGFyZSBwYXNzZWQgLSBtYWtlIHN1cmUgY2FsbGJhY2sgaGFzIHNvbWUgdGFncyBiZWZvcmUgcmVtb3ZpbmdcclxuXHRpZiAodGFncyAmJiB0YWdzLmxlbmd0aCAmJiAhaGFzVGFncyhjYiwgdGFncykpIHJldHVybiBmYWxzZTtcclxuXHJcblx0Ly9yZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHQvL29uY2UgbWV0aG9kIGhhcyBvcmlnaW5hbCBjYWxsYmFjayBpbiAuY2JcclxuXHRcdGlmIChjYWxsYmFja3NbaV0gPT09IGNiIHx8IGNhbGxiYWNrc1tpXS5mbiA9PT0gY2IpIHtcclxuXHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBuZXcgbGlzdGVuZXJcclxuICovXHJcbmxpc3RlbmVycy5hZGQgPSBmdW5jdGlvbih0YXJnZXQsIGV2dCwgY2IsIHRhZ3Mpe1xyXG5cdGlmICghY2IpIHJldHVybjtcclxuXHJcblx0dmFyIHRhcmdldENhbGxiYWNrcyA9IHRhcmdldFtjYlByb3BOYW1lXTtcclxuXHJcblx0Ly9lbnN1cmUgc2V0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIHRhcmdldCBleGlzdHNcclxuXHRpZiAoIXRhcmdldENhbGxiYWNrcykge1xyXG5cdFx0dGFyZ2V0Q2FsbGJhY2tzID0ge307XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjYlByb3BOYW1lLCB7XHJcblx0XHRcdHZhbHVlOiB0YXJnZXRDYWxsYmFja3NcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly9zYXZlIGEgbmV3IGNhbGxiYWNrXHJcblx0KHRhcmdldENhbGxiYWNrc1tldnRdID0gdGFyZ2V0Q2FsbGJhY2tzW2V2dF0gfHwgW10pLnB1c2goY2IpO1xyXG5cclxuXHQvL3NhdmUgbnMgZm9yIGEgY2FsbGJhY2ssIGlmIGFueVxyXG5cdGlmICh0YWdzICYmIHRhZ3MubGVuZ3RoKSB7XHJcblx0XHRjYi5fbnMgPSB0YWdzO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKiogRGV0ZWN0IHdoZXRoZXIgYW4gY2IgaGFzIGF0IGxlYXN0IG9uZSB0YWcgZnJvbSB0aGUgbGlzdCAqL1xyXG5mdW5jdGlvbiBoYXNUYWdzKGNiLCB0YWdzKXtcclxuXHRpZiAoY2IuX25zKSB7XHJcblx0XHQvL2lmIGNiIGlzIHRhZ2dlZCB3aXRoIGEgbnMgYW5kIGluY2x1ZGVzIG9uZSBvZiB0aGUgbnMgcGFzc2VkIC0ga2VlcCBpdFxyXG5cdFx0Zm9yICh2YXIgaSA9IHRhZ3MubGVuZ3RoOyBpLS07KXtcclxuXHRcdFx0aWYgKGNiLl9ucy5pbmRleE9mKHRhZ3NbaV0pID49IDApIHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbGlzdGVuZXJzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lbW15L2xpc3RlbmVycy5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBwbGFpbk9iamVjdCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKiBDdXN0b21DcmVhdGUqLykge1xuXHR2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIGN1c3RvbUNyZWF0ZSA9IGFyZ3VtZW50c1swXSB8fCBjcmVhdGU7XG5cdGlmICh0eXBlb2Ygc2V0UHJvdG90eXBlT2YgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc2V0UHJvdG90eXBlT2YoY3VzdG9tQ3JlYXRlKG51bGwpLCBwbGFpbk9iamVjdCkpID09PSBwbGFpbk9iamVjdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZXNsaW50IG5vLXByb3RvOiBcIm9mZlwiICovXG5cbi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoXCIuLi9pcy1vYmplY3RcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBvYmpJc1Byb3RvdHlwT2YgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2ZcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBudWxsRGVzYyAgICAgICAgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHR2YWx1ZTogdW5kZWZpbmVkXG59XG4gICwgdmFsaWRhdGU7XG5cbnZhbGlkYXRlID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdHZhbHVlKG9iaik7XG5cdGlmIChwcm90b3R5cGUgPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIG9iajtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3RvdHlwZSBtdXN0IGJlIG51bGwgb3IgYW4gb2JqZWN0XCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKHN0YXR1cykge1xuXHR2YXIgZm4sIHNldDtcblx0aWYgKCFzdGF0dXMpIHJldHVybiBudWxsO1xuXHRpZiAoc3RhdHVzLmxldmVsID09PSAyKSB7XG5cdFx0aWYgKHN0YXR1cy5zZXQpIHtcblx0XHRcdHNldCA9IHN0YXR1cy5zZXQ7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHRzZXQuY2FsbCh2YWxpZGF0ZShvYmosIHByb3RvdHlwZSksIHByb3RvdHlwZSk7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSkuX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBzZWxmIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gb2JqSXNQcm90b3R5cE9mLmNhbGwoc2VsZi5udWxsUG9seWZpbGwsIG9iaik7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVsZXRlIHNlbGYubnVsbFBvbHlmaWxsLl9fcHJvdG9fXztcblx0XHRcdGlmIChwcm90b3R5cGUgPT09IG51bGwpIHByb3RvdHlwZSA9IHNlbGYubnVsbFBvbHlmaWxsO1xuXHRcdFx0b2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWZpbmVQcm9wZXJ0eShzZWxmLm51bGxQb2x5ZmlsbCwgXCJfX3Byb3RvX19cIiwgbnVsbERlc2MpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibGV2ZWxcIiwge1xuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiBzdGF0dXMubGV2ZWxcblx0fSk7XG59KFxuXHQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0bXBPYmoxID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdCAgLCB0bXBPYmoyID0ge31cblx0XHQgICwgc2V0XG5cdFx0ICAsIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIFwiX19wcm90b19fXCIpO1xuXG5cdFx0aWYgKGRlc2MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNldCA9IGRlc2Muc2V0OyAvLyBPcGVyYSBjcmFzaGVzIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0c2V0LmNhbGwodG1wT2JqMSwgdG1wT2JqMik7XG5cdFx0XHR9IGNhdGNoIChpZ25vcmUpIHt9XG5cdFx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBzZXQ6IHNldCwgbGV2ZWw6IDIgfTtcblx0XHR9XG5cblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDIgfTtcblxuXHRcdHRtcE9iajEgPSB7fTtcblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDEgfTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKVxuKSk7XG5cbnJlcXVpcmUoXCIuLi9jcmVhdGVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIG1hcCA9IHsgZnVuY3Rpb246IHRydWUsIG9iamVjdDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gKGlzVmFsdWUodmFsdWUpICYmIG1hcFt0eXBlb2YgdmFsdWVdKSB8fCBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvZnVuY3Rpb24vbm9vcC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKCdlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cycpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9pcy1zdHJpbmcnKVxuICAsIEFycmF5SXRlcmF0b3IgID0gcmVxdWlyZSgnLi9hcnJheScpXG4gICwgU3RyaW5nSXRlcmF0b3IgPSByZXF1aXJlKCcuL3N0cmluZycpXG4gICwgaXRlcmFibGUgICAgICAgPSByZXF1aXJlKCcuL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS5pdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmICh0eXBlb2YgaXRlcmFibGUob2JqKVtpdGVyYXRvclN5bWJvbF0gPT09ICdmdW5jdGlvbicpIHJldHVybiBvYmpbaXRlcmF0b3JTeW1ib2xdKCk7XG5cdGlmIChpc0FyZ3VtZW50cyhvYmopKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcblx0aWYgKGlzU3RyaW5nKG9iaikpIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcblx0cmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsdWUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBhdXRvQmluZCA9IHJlcXVpcmUoJ2QvYXV0by1iaW5kJylcbiAgLCBTeW1ib2wgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBJdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvciA9IGZ1bmN0aW9uIChsaXN0LCBjb250ZXh0KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBJdGVyYXRvcikpIHJldHVybiBuZXcgSXRlcmF0b3IobGlzdCwgY29udGV4dCk7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fbGlzdF9fOiBkKCd3JywgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKCd3JywgY29udGV4dCksXG5cdFx0X19uZXh0SW5kZXhfXzogZCgndycsIDApXG5cdH0pO1xuXHRpZiAoIWNvbnRleHQpIHJldHVybjtcblx0Y2FsbGFibGUoY29udGV4dC5vbik7XG5cdGNvbnRleHQub24oJ19hZGQnLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oJ19kZWxldGUnLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdGNvbnRleHQub24oJ19jbGVhcicsIHRoaXMuX29uQ2xlYXIpO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhJdGVyYXRvci5wcm90b3R5cGUsIGFzc2lnbih7XG5cdGNvbnN0cnVjdG9yOiBkKEl0ZXJhdG9yKSxcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpO1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuO1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5zaGlmdCgpO1xuXHRcdFx0aWYgKGkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGlzdF9fLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHR9KSxcblx0bmV4dDogZChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jcmVhdGVSZXN1bHQodGhpcy5fbmV4dCgpKTsgfSksXG5cdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9yZXNvbHZlKGkpIH07XG5cdH0pLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTsgfSksXG5cdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX19saXN0X18gPSBudWxsO1xuXHRcdGRlbGV0ZSB0aGlzLl9fcmVkb19fO1xuXHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfYWRkJywgdGhpcy5fb25BZGQpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfZGVsZXRlJywgdGhpcy5fb25EZWxldGUpO1xuXHRcdHRoaXMuX19jb250ZXh0X18ub2ZmKCdfY2xlYXInLCB0aGlzLl9vbkNsZWFyKTtcblx0XHR0aGlzLl9fY29udGV4dF9fID0gbnVsbDtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEl0ZXJhdG9yXSc7IH0pXG59LCBhdXRvQmluZCh7XG5cdF9vbkFkZDogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0aWYgKCF0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19yZWRvX18nLCBkKCdjJywgW2luZGV4XSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdGlmIChyZWRvID49IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gKytyZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdH0pLFxuXHRfb25EZWxldGU6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dmFyIGk7XG5cdFx0aWYgKGluZGV4ID49IHRoaXMuX19uZXh0SW5kZXhfXykgcmV0dXJuO1xuXHRcdC0tdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdGkgPSB0aGlzLl9fcmVkb19fLmluZGV4T2YoaW5kZXgpO1xuXHRcdGlmIChpICE9PSAtMSkgdGhpcy5fX3JlZG9fXy5zcGxpY2UoaSwgMSk7XG5cdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRpZiAocmVkbyA+IGluZGV4KSB0aGlzLl9fcmVkb19fW2ldID0gLS1yZWRvO1xuXHRcdH0sIHRoaXMpO1xuXHR9KSxcblx0X29uQ2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9fcmVkb19fKSBjbGVhci5jYWxsKHRoaXMuX19yZWRvX18pO1xuXHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdH0pXG59KSkpO1xuXG5kZWZpbmVQcm9wZXJ0eShJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJycsICdJdGVyYXRvcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbCcpLmV4dGVuZDtcblxudmFyIGRlZmF1bHRPcHRzID0ge1xuICBjb2xsYXBzZU90aGVyczogZmFsc2UsXG4gIGN1c3RvbUhpZGluZzogZmFsc2UsXG4gIGNvbnRlbnRQcmVmaXg6ICdhY2NvcmRpb24nLFxuICBvcGVuRmlyc3Q6IGZhbHNlXG59O1xuXG52YXIgZGVmYXVsdFNlbGVjdG9ycyA9IHtcbiAgdHJpZ2dlcjogJ2J1dHRvbidcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhY2NvcmRpb24gY29tcG9uZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtIC0gVGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgZW50aXJlIGFjY29yZGlvblxuICogQHBhcmFtIHtvYmplY3R9IHNlbGVjdG9ycyAtIFNlbGVjdG9ycyBmb3IgbG9jYXRpbmcgRE9NIGVsZW1lbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGJlaGF2aW9yXG4gKi9cblxudmFyIEFjY29yZGlvbiA9IGZ1bmN0aW9uKGVsbSwgc2VsZWN0b3JzLCBvcHRzKSB7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLnNlbGVjdG9ycyA9IGV4dGVuZCh7fSwgZGVmYXVsdFNlbGVjdG9ycywgc2VsZWN0b3JzKTtcbiAgdGhpcy5vcHRzID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3B0cywgb3B0cyk7XG5cbiAgdGhpcy50cmlnZ2VycyA9IHRoaXMuZmluZFRyaWdnZXJzKCk7XG5cbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxtLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRWxtLmJpbmQodGhpcykpO1xuXG4gIGlmICh0aGlzLm9wdHMub3BlbkZpcnN0KSB7XG4gICAgdGhpcy5leHBhbmQodGhpcy50cmlnZ2Vyc1swXSk7XG4gIH1cbn07XG5cbkFjY29yZGlvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2tFbG0gPSBmdW5jdGlvbihlKSB7XG4gIC8vIElmIHRoZSB0YXJnZXQgaXMgdGhlIGJ1dHRvbiwgdG9nZ2xlIHRoZSBidXR0b25cbiAgLy8gRWxzZSBzZWUgaWYgdGhlIHRhcmdldCBpcyBhIGNoaWxkIG9mIGEgYnV0dG9uXG4gIGlmICh0aGlzLnRyaWdnZXJzLmluZGV4T2YoZS50YXJnZXQpID4gLTEpIHtcbiAgICB0aGlzLnRvZ2dsZShlLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKXtcbiAgICAgIGlmIChlLnRhcmdldC5wYXJlbnRFbGVtZW50ID09PSB0cmlnZ2VyKSB7XG4gICAgICAgIHNlbGYudG9nZ2xlKHRyaWdnZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5BY2NvcmRpb24ucHJvdG90eXBlLmZpbmRUcmlnZ2VycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmlnZ2VycyA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbG0ucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9ycy50cmlnZ2VyKSk7XG4gIHRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlciwgaW5kZXgpIHtcbiAgICBzZWxmLnNldEFyaWEodHJpZ2dlciwgaW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIHRyaWdnZXJzO1xufTtcblxuQWNjb3JkaW9uLnByb3RvdHlwZS5zZXRBcmlhID0gZnVuY3Rpb24odHJpZ2dlciwgaW5kZXgpIHtcbiAgdmFyIGNvbnRlbnQgPSB0cmlnZ2VyLm5leHRFbGVtZW50U2libGluZztcbiAgdmFyIGNvbnRlbnRJRDtcblxuICBpZiAoY29udGVudC5oYXNBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICBjb250ZW50SUQgPSBjb250ZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZW50SUQgPSB0aGlzLm9wdHMuY29udGVudFByZWZpeCArICctJyArICdjb250ZW50LScgKyBpbmRleDtcbiAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBjb250ZW50SUQpO1xuICB9XG5cbiAgdHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCBjb250ZW50SUQpO1xuICB0cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB0aGlzLnNldFN0eWxlcyhjb250ZW50KTtcbn07XG5cbkFjY29yZGlvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oZWxtKSB7XG4gIHZhciBmID0gZWxtLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZScgPyB0aGlzLmNvbGxhcHNlIDogdGhpcy5leHBhbmQ7XG4gIGYuY2FsbCh0aGlzLCBlbG0pO1xufTtcblxuQWNjb3JkaW9uLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbihidXR0b24pIHtcbiAgaWYgKHRoaXMub3B0cy5jb2xsYXBzZU90aGVycykge1xuICAgIHRoaXMuY29sbGFwc2VBbGwoKTtcbiAgfVxuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSk7XG4gIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgdGhpcy5zZXRTdHlsZXMoY29udGVudCk7XG59O1xuXG5BY2NvcmRpb24ucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24oYnV0dG9uKSB7XG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpKTtcbiAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB0aGlzLnNldFN0eWxlcyhjb250ZW50KTtcbn07XG5cbkFjY29yZGlvbi5wcm90b3R5cGUuY29sbGFwc2VBbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgIHNlbGYuY29sbGFwc2UodHJpZ2dlcik7XG4gIH0pO1xufTtcblxuQWNjb3JkaW9uLnByb3RvdHlwZS5leHBhbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgIHNlbGYuZXhwYW5kKHRyaWdnZXIpO1xuICB9KTtcbn07XG5cbkFjY29yZGlvbi5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24oY29udGVudCkge1xuICB2YXIgcHJvcCA9IGNvbnRlbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpID09PSAndHJ1ZScgPyAnbm9uZScgOiAnYmxvY2snO1xuXG4gIGlmICghdGhpcy5vcHRzLmN1c3RvbUhpZGluZykge1xuICAgIGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IHByb3A7XG4gIH1cbn07XG5cbkFjY29yZGlvbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsbSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGlmIChlbG0pIHtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goe1xuICAgICAgZWxtOiBlbG0sXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgfVxufTtcblxuQWNjb3JkaW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lci5lbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBBY2NvcmRpb246IEFjY29yZGlvbiB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2FyaWEtYWNjb3JkaW9uL3NyYy9hY2NvcmRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL2luZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3RpbW94bGV5L3RvLWFycmF5XG4gKlxuICogQ29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCBpbnRvIGFuIGBBcnJheWAuXG4gKiBJZiBgY29sbGVjdGlvbmAgaXMgYWxyZWFkeSBhbiBgQXJyYXlgLCB0aGVuIHdpbGwgcmV0dXJuIGEgY2xvbmUgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCBNaXhlZH0gY29sbGVjdGlvbiBBbiBgQXJyYXlgIG9yIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGNvbnZlcnQgZS5nLiBgYXJndW1lbnRzYCBvciBgTm9kZUxpc3RgXG4gKiBAcmV0dXJuIHtBcnJheX0gTmFpdmUgY29udmVyc2lvbiBvZiBgY29sbGVjdGlvbmAgdG8gYSBuZXcgYEFycmF5YC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuICBpZiAoY29sbGVjdGlvbiA9PT0gbnVsbCkgcmV0dXJuIFtudWxsXTtcbiAgaWYgKGNvbGxlY3Rpb24gPT09IHdpbmRvdykgcmV0dXJuIFt3aW5kb3ddO1xuICBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gW2NvbGxlY3Rpb25dO1xuICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkgcmV0dXJuIGNvbGxlY3Rpb247XG4gIGlmICh0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHJldHVybiBbY29sbGVjdGlvbl07XG4gIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBjb2xsZWN0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHJldHVybiBbY29sbGVjdGlvbl07XG5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGkpIHx8IGkgaW4gY29sbGVjdGlvbikge1xuICAgICAgYXJyLnB1c2goY29sbGVjdGlvbltpXSk7XG4gICAgfVxuICB9XG4gIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIFtdO1xuICByZXR1cm4gYXJyO1xufTtcblxuZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL3RvLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGluaXRWYWx1ZXMsIGVsZW1lbnQsIG5vdENyZWF0ZSkge1xuICAgIHZhciBpdGVtID0gdGhpcztcblxuICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuXG4gICAgdGhpcy5mb3VuZCA9IGZhbHNlOyAvLyBTaG93IGlmIGxpc3Quc2VhcmNoZWQgPT0gdHJ1ZSBhbmQgdGhpcy5mb3VuZCA9PSB0cnVlXG4gICAgdGhpcy5maWx0ZXJlZCA9IGZhbHNlOy8vIFNob3cgaWYgbGlzdC5maWx0ZXJlZCA9PSB0cnVlIGFuZCB0aGlzLmZpbHRlcmVkID09IHRydWVcblxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24oaW5pdFZhbHVlcywgZWxlbWVudCwgbm90Q3JlYXRlKSB7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub3RDcmVhdGUpIHtcbiAgICAgICAgICBpdGVtLnZhbHVlcyhpbml0VmFsdWVzLCBub3RDcmVhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0udmFsdWVzKGluaXRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLmVsbSA9IGVsZW1lbnQ7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBsaXN0LnRlbXBsYXRlci5nZXQoaXRlbSwgaW5pdFZhbHVlcyk7XG4gICAgICAgIGl0ZW0udmFsdWVzKHZhbHVlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudmFsdWVzID0gZnVuY3Rpb24obmV3VmFsdWVzLCBub3RDcmVhdGUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gbmV3VmFsdWVzKSB7XG4gICAgICAgICAgaXRlbS5fdmFsdWVzW25hbWVdID0gbmV3VmFsdWVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDcmVhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICBsaXN0LnRlbXBsYXRlci5zZXQoaXRlbSwgaXRlbS52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtLl92YWx1ZXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGlzdC50ZW1wbGF0ZXIuc2hvdyhpdGVtKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBsaXN0LnRlbXBsYXRlci5oaWRlKGl0ZW0pO1xuICAgIH07XG5cbiAgICB0aGlzLm1hdGNoaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAobGlzdC5maWx0ZXJlZCAmJiBsaXN0LnNlYXJjaGVkICYmIGl0ZW0uZm91bmQgJiYgaXRlbS5maWx0ZXJlZCkgfHxcbiAgICAgICAgKGxpc3QuZmlsdGVyZWQgJiYgIWxpc3Quc2VhcmNoZWQgJiYgaXRlbS5maWx0ZXJlZCkgfHxcbiAgICAgICAgKCFsaXN0LmZpbHRlcmVkICYmIGxpc3Quc2VhcmNoZWQgJiYgaXRlbS5mb3VuZCkgfHxcbiAgICAgICAgKCFsaXN0LmZpbHRlcmVkICYmICFsaXN0LnNlYXJjaGVkKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdGhpcy52aXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGl0ZW0uZWxtICYmIChpdGVtLmVsbS5wYXJlbnROb2RlID09IGxpc3QubGlzdCkpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICBpbml0KGluaXRWYWx1ZXMsIGVsZW1lbnQsIG5vdENyZWF0ZSk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy9pdGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcbi8qKlxuICogQW4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSBhbHRlcm5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIHNvbWV0aGluZyB3aXRoIGEgbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbGljZUVuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdzLCBzbGljZSwgc2xpY2VFbmQpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKDAgPT09IGxlbikgcmV0dXJuIHJldDtcblxuICB2YXIgc3RhcnQgPSBzbGljZSA8IDBcbiAgICA/IE1hdGgubWF4KDAsIHNsaWNlICsgbGVuKVxuICAgIDogc2xpY2UgfHwgMDtcblxuICBpZiAoc2xpY2VFbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGxlbiA9IHNsaWNlRW5kIDwgMFxuICAgICAgPyBzbGljZUVuZCArIGxlblxuICAgICAgOiBzbGljZUVuZFxuICB9XG5cbiAgd2hpbGUgKGxlbi0tID4gc3RhcnQpIHtcbiAgICByZXRbbGVuIC0gc3RhcnRdID0gYXJnc1tsZW5dO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3NsaWNlZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCdlczUtZXh0L2dsb2JhbCcpLCAnV2Vha01hcCcsXG5cdFx0eyB2YWx1ZTogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0d3JpdGFibGU6IHRydWUgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM2LXdlYWstbWFwL2ltcGxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHdlYWtNYXAsIHg7XG5cdGlmICh0eXBlb2YgV2Vha01hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdC8vIFdlYktpdCBkb2Vzbid0IHN1cHBvcnQgYXJndW1lbnRzIGFuZCBjcmFzaGVzXG5cdFx0d2Vha01hcCA9IG5ldyBXZWFrTWFwKFtbeCA9IHt9LCAnb25lJ10sIFt7fSwgJ3R3byddLCBbe30sICd0aHJlZSddXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKFN0cmluZyh3ZWFrTWFwKSAhPT0gJ1tvYmplY3QgV2Vha01hcF0nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygd2Vha01hcC5zZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHdlYWtNYXAuc2V0KHt9LCAxKSAhPT0gd2Vha01hcCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHdlYWtNYXAuZGVsZXRlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2Ygd2Vha01hcC5oYXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHdlYWtNYXAuZ2V0KHgpICE9PSAnb25lJykgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCBzdHJpY3Q6IFwib2ZmXCIgKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgb2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1vYmplY3QnKVxuICAsIHZhbHVlICAgICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIHJhbmRvbVVuaXEgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvcmFuZG9tLXVuaXEnKVxuICAsIGQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgZ2V0SXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvZ2V0JylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9mb3Itb2YnKVxuICAsIHRvU3RyaW5nVGFnU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLnRvU3RyaW5nVGFnXG4gICwgaXNOYXRpdmUgICAgICAgICAgPSByZXF1aXJlKCcuL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZCcpXG5cbiAgLCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICwgV2Vha01hcFBvbHk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcFBvbHkgPSBmdW5jdGlvbiAoLyppdGVyYWJsZSovKSB7XG5cdHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXSwgc2VsZjtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFdlYWtNYXBQb2x5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG5cdGlmIChpc05hdGl2ZSAmJiBzZXRQcm90b3R5cGVPZiAmJiAoV2Vha01hcCAhPT0gV2Vha01hcFBvbHkpKSB7XG5cdFx0c2VsZiA9IHNldFByb3RvdHlwZU9mKG5ldyBXZWFrTWFwKCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHRzZWxmID0gdGhpcztcblx0fVxuXHRpZiAoaXRlcmFibGUgIT0gbnVsbCkge1xuXHRcdGlmICghaXNBcnJheShpdGVyYWJsZSkpIGl0ZXJhYmxlID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuXHR9XG5cdGRlZmluZVByb3BlcnR5KHNlbGYsICdfX3dlYWtNYXBEYXRhX18nLCBkKCdjJywgJyR3ZWFrTWFwJCcgKyByYW5kb21VbmlxKCkpKTtcblx0aWYgKCFpdGVyYWJsZSkgcmV0dXJuIHNlbGY7XG5cdGZvck9mKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0dmFsdWUodmFsKTtcblx0XHRzZWxmLnNldCh2YWxbMF0sIHZhbFsxXSk7XG5cdH0pO1xuXHRyZXR1cm4gc2VsZjtcbn07XG5cbmlmIChpc05hdGl2ZSkge1xuXHRpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFdlYWtNYXBQb2x5LCBXZWFrTWFwKTtcblx0V2Vha01hcFBvbHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXZWFrTWFwLnByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBkKFdlYWtNYXBQb2x5KVxuXHR9KTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2Vha01hcFBvbHkucHJvdG90eXBlLCB7XG5cdGRlbGV0ZTogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0KGtleSksIHRoaXMuX193ZWFrTWFwRGF0YV9fKSkge1xuXHRcdFx0ZGVsZXRlIGtleVt0aGlzLl9fd2Vha01hcERhdGFfX107XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KSxcblx0Z2V0OiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qoa2V5KSwgdGhpcy5fX3dlYWtNYXBEYXRhX18pKSB7XG5cdFx0XHRyZXR1cm4ga2V5W3RoaXMuX193ZWFrTWFwRGF0YV9fXTtcblx0XHR9XG5cdH0pLFxuXHRoYXM6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdChrZXkpLCB0aGlzLl9fd2Vha01hcERhdGFfXyk7XG5cdH0pLFxuXHRzZXQ6IGQoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3Qoa2V5KSwgdGhpcy5fX3dlYWtNYXBEYXRhX18sIGQoJ2MnLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgV2Vha01hcF0nOyB9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShXZWFrTWFwUG9seS5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBkKCdjJywgJ1dlYWtNYXAnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM2LXdlYWstbWFwL3BvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODA0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgc2hpbTtcblxuaWYgKCFyZXF1aXJlKFwiLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkXCIpKCkpIHtcblx0c2hpbSA9IHJlcXVpcmUoXCIuL3NldC1wcm90b3R5cGUtb2Yvc2hpbVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVsbE9iamVjdCwgcG9seVByb3BzLCBkZXNjO1xuXHRpZiAoIXNoaW0pIHJldHVybiBjcmVhdGU7XG5cdGlmIChzaGltLmxldmVsICE9PSAxKSByZXR1cm4gY3JlYXRlO1xuXG5cdG51bGxPYmplY3QgPSB7fTtcblx0cG9seVByb3BzID0ge307XG5cdGRlc2MgPSB7XG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdH07XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuXHRcdFx0cG9seVByb3BzW25hbWVdID0ge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cG9seVByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHBvbHlQcm9wcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNoaW0sIFwibnVsbFBvbHlmaWxsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogbnVsbE9iamVjdFxuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKHByb3RvdHlwZSA9PT0gbnVsbCA/IG51bGxPYmplY3QgOiBwcm90b3R5cGUsIHByb3BzKTtcblx0fTtcbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZShcIi4vaXMtb2JqZWN0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzT2JqZWN0KHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBhbiBPYmplY3RcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvdmFsaWQtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdlbmVyYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAsIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN0cjtcblx0ZG8ge1xuIHN0ciA9IHJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbn0gd2hpbGUgKGdlbmVyYXRlZFtzdHJdKTtcblx0cmV0dXJuIHN0cjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvcmFuZG9tLXVuaXEuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0b2JqID0geyBmb286IFwicmF6XCIgfTtcblx0YXNzaWduKG9iaiwgeyBiYXI6IFwiZHdhXCIgfSwgeyB0cnp5OiBcInRyenlcIiB9KTtcblx0cmV0dXJuIChvYmouZm9vICsgb2JqLmJhciArIG9iai50cnp5KSA9PT0gXCJyYXpkd2F0cnp5XCI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoXCIuLi9rZXlzXCIpXG4gICwgdmFsdWUgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBtYXggICA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMgLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGxlbmd0aCA9IG1heChhcmd1bWVudHMubGVuZ3RoLCAyKSwgYXNzaWduO1xuXHRkZXN0ID0gT2JqZWN0KHZhbHVlKGRlc3QpKTtcblx0YXNzaWduID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHRyeSB7XG5cdFx0XHRkZXN0W2tleV0gPSBzcmNba2V5XTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGU7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IE9iamVjdC5rZXlzXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoXCJwcmltaXRpdmVcIik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcbiByZXR1cm4gZmFsc2U7XG59XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi9pcy12YWx1ZVwiKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHJldHVybiBrZXlzKGlzVmFsdWUob2JqZWN0KSA/IE9iamVjdChvYmplY3QpIDogb2JqZWN0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0ciA9IFwicmF6ZHdhdHJ6eVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzdHIuY29udGFpbnMgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKHN0ci5jb250YWlucyhcImR3YVwiKSA9PT0gdHJ1ZSkgJiYgKHN0ci5jb250YWlucyhcImZvb1wiKSA9PT0gZmFsc2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjb250YWlucyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuLycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3IoYXJyLCBraW5kKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBhcnIpO1xuXHRpZiAoIWtpbmQpIGtpbmQgPSAndmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXkrdmFsdWUnKSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsICdrZXknKSkga2luZCA9ICdrZXknO1xuXHRlbHNlIGtpbmQgPSAndmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19raW5kX18nLCBkKCcnLCBraW5kKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihBcnJheUl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoQXJyYXlJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5K3ZhbHVlJykgcmV0dXJuIFtpLCB0aGlzLl9fbGlzdF9fW2ldXTtcblx0XHRyZXR1cm4gaTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXSc7IH0pXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEluc3BpcmVkIGJ5IEdvb2dsZSBDbG9zdXJlOlxuLy8gaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9cbi8vIGNsb3N1cmVfZ29vZ19hcnJheV9hcnJheS5qcy5odG1sI2dvb2cuYXJyYXkuY2xlYXJcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2YWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YWx1ZSh0aGlzKS5sZW5ndGggPSAwO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3B5ICAgICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvY29weScpXG4gICwgbm9ybWFsaXplT3B0aW9ucyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zJylcbiAgLCBlbnN1cmVDYWxsYWJsZSAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIG1hcCAgICAgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9tYXAnKVxuICAsIGNhbGxhYmxlICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcblxuICAsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZWZpbmU7XG5cbmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjLCBvcHRpb25zKSB7XG5cdHZhciB2YWx1ZSA9IHZhbGlkVmFsdWUoZGVzYykgJiYgY2FsbGFibGUoZGVzYy52YWx1ZSksIGRncztcblx0ZGdzID0gY29weShkZXNjKTtcblx0ZGVsZXRlIGRncy53cml0YWJsZTtcblx0ZGVsZXRlIGRncy52YWx1ZTtcblx0ZGdzLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIW9wdGlvbnMub3ZlcndyaXRlRGVmaW5pdGlvbiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSByZXR1cm4gdmFsdWU7XG5cdFx0ZGVzYy52YWx1ZSA9IGJpbmQuY2FsbCh2YWx1ZSwgb3B0aW9ucy5yZXNvbHZlQ29udGV4dCA/IG9wdGlvbnMucmVzb2x2ZUNvbnRleHQodGhpcykgOiB0aGlzKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkZXNjKTtcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0fTtcblx0cmV0dXJuIGRncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3BzLyosIG9wdGlvbnMqLykge1xuXHR2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJndW1lbnRzWzFdKTtcblx0aWYgKG9wdGlvbnMucmVzb2x2ZUNvbnRleHQgIT0gbnVsbCkgZW5zdXJlQ2FsbGFibGUob3B0aW9ucy5yZXNvbHZlQ29udGV4dCk7XG5cdHJldHVybiBtYXAocHJvcHMsIGZ1bmN0aW9uIChkZXNjLCBuYW1lKSB7IHJldHVybiBkZWZpbmUobmFtZSwgZGVzYywgb3B0aW9ucyk7IH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3Ivbm9kZV9tb2R1bGVzL2QvYXV0by1iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFGcm9tICA9IHJlcXVpcmUoXCIuLi9hcnJheS9mcm9tXCIpXG4gICwgYXNzaWduID0gcmVxdWlyZShcIi4vYXNzaWduXCIpXG4gICwgdmFsdWUgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iai8qLCBwcm9wZXJ0eU5hbWVzLCBvcHRpb25zKi8pIHtcblx0dmFyIGNvcHkgPSBPYmplY3QodmFsdWUob2JqKSksIHByb3BlcnR5TmFtZXMgPSBhcmd1bWVudHNbMV0sIG9wdGlvbnMgPSBPYmplY3QoYXJndW1lbnRzWzJdKTtcblx0aWYgKGNvcHkgIT09IG9iaiAmJiAhcHJvcGVydHlOYW1lcykgcmV0dXJuIGNvcHk7XG5cdHZhciByZXN1bHQgPSB7fTtcblx0aWYgKHByb3BlcnR5TmFtZXMpIHtcblx0XHRhRnJvbShwcm9wZXJ0eU5hbWVzLCBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5lbnN1cmUgfHwgcHJvcGVydHlOYW1lIGluIG9iaikgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBvYmpbcHJvcGVydHlOYW1lXTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRhc3NpZ24ocmVzdWx0LCBvYmopO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NvcHkuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyBBcnJheS5mcm9tXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGZyb20gPSBBcnJheS5mcm9tLCBhcnIsIHJlc3VsdDtcblx0aWYgKHR5cGVvZiBmcm9tICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0YXJyID0gW1wicmF6XCIsIFwiZHdhXCJdO1xuXHRyZXN1bHQgPSBmcm9tKGFycik7XG5cdHJldHVybiBCb29sZWFuKHJlc3VsdCAmJiAocmVzdWx0ICE9PSBhcnIpICYmIChyZXN1bHRbMV0gPT09IFwiZHdhXCIpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL2lzLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIikuaXRlcmF0b3JcbiAgLCBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc0Z1bmN0aW9uICAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1mdW5jdGlvblwiKVxuICAsIHRvUG9zSW50ICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGlzVmFsdWUgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC9pcy12YWx1ZVwiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBpc0FycmF5ICAgICAgICA9IEFycmF5LmlzQXJyYXlcbiAgLCBjYWxsICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVzYyAgICAgICAgICAgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH1cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5TGlrZSAvKiwgbWFwRm4sIHRoaXNBcmcqLykge1xuXHR2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV1cblx0ICAsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl1cblx0ICAsIENvbnRleHRcblx0ICAsIGlcblx0ICAsIGpcblx0ICAsIGFyclxuXHQgICwgbGVuZ3RoXG5cdCAgLCBjb2RlXG5cdCAgLCBpdGVyYXRvclxuXHQgICwgcmVzdWx0XG5cdCAgLCBnZXRJdGVyYXRvclxuXHQgICwgdmFsdWU7XG5cblx0YXJyYXlMaWtlID0gT2JqZWN0KHZhbGlkVmFsdWUoYXJyYXlMaWtlKSk7XG5cblx0aWYgKGlzVmFsdWUobWFwRm4pKSBjYWxsYWJsZShtYXBGbik7XG5cdGlmICghdGhpcyB8fCB0aGlzID09PSBBcnJheSB8fCAhaXNGdW5jdGlvbih0aGlzKSkge1xuXHRcdC8vIFJlc3VsdDogUGxhaW4gYXJyYXlcblx0XHRpZiAoIW1hcEZuKSB7XG5cdFx0XHRpZiAoaXNBcmd1bWVudHMoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFyZ3VtZW50c1xuXHRcdFx0XHRsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoICE9PSAxKSByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgYXJyYXlMaWtlKTtcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KDEpO1xuXHRcdFx0XHRhcnJbMF0gPSBhcnJheUxpa2VbMF07XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0XHRcdC8vIFNvdXJjZTogQXJyYXlcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIGFycltpXSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gW107XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUmVzdWx0OiBOb24gcGxhaW4gYXJyYXlcblx0XHRDb250ZXh0ID0gdGhpcztcblx0fVxuXG5cdGlmICghaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0aWYgKChnZXRJdGVyYXRvciA9IGFycmF5TGlrZVtpdGVyYXRvclN5bWJvbF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFNvdXJjZTogSXRlcmF0b3Jcblx0XHRcdGl0ZXJhdG9yID0gY2FsbGFibGUoZ2V0SXRlcmF0b3IpLmNhbGwoYXJyYXlMaWtlKTtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaSkgOiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHRsZW5ndGggPSBpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJyYXlMaWtlKSkge1xuXHRcdFx0Ly8gU291cmNlOiBTdHJpbmdcblx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQoKTtcblx0XHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFsdWUgPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdGlmIChpICsgMSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcblx0XHRcdFx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHZhbHVlICs9IGFycmF5TGlrZVsrK2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHZhbHVlLCBqKSA6IHZhbHVlO1xuXHRcdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGosIGRlc2MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycltqXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCsrajtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGo7XG5cdFx0fVxuXHR9XG5cdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFNvdXJjZTogYXJyYXkgb3IgYXJyYXktbGlrZVxuXHRcdGxlbmd0aCA9IHRvUG9zSW50KGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dChsZW5ndGgpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgYXJyYXlMaWtlW2ldLCBpKSA6IGFycmF5TGlrZVtpXTtcblx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycltpXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoQ29udGV4dCkge1xuXHRcdGRlc2MudmFsdWUgPSBudWxsO1xuXHRcdGFyci5sZW5ndGggPSBsZW5ndGg7XG5cdH1cblx0cmV0dXJuIGFycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkVHlwZXMgPSB7IG9iamVjdDogdHJ1ZSwgc3ltYm9sOiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRzeW1ib2wgPSBTeW1ib2woJ3Rlc3Qgc3ltYm9sJyk7XG5cdHRyeSB7IFN0cmluZyhzeW1ib2wpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIFJldHVybiAndHJ1ZScgYWxzbyBmb3IgcG9seWZpbGxzXG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLml0ZXJhdG9yXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZV0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWddKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEVTMjAxNSBTeW1ib2wgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCAob3IgcGFydGlhbGx5KSBzdXBwb3J0IGl0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgdmFsaWRhdGVTeW1ib2wgPSByZXF1aXJlKCcuL3ZhbGlkYXRlLXN5bWJvbCcpXG5cbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgb2JqUHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZVxuICAsIE5hdGl2ZVN5bWJvbCwgU3ltYm9sUG9seWZpbGwsIEhpZGRlblN5bWJvbCwgZ2xvYmFsU3ltYm9scyA9IGNyZWF0ZShudWxsKVxuICAsIGlzTmF0aXZlU2FmZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0TmF0aXZlU3ltYm9sID0gU3ltYm9sO1xuXHR0cnkge1xuXHRcdFN0cmluZyhOYXRpdmVTeW1ib2woKSk7XG5cdFx0aXNOYXRpdmVTYWZlID0gdHJ1ZTtcblx0fSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG52YXIgZ2VuZXJhdGVOYW1lID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIGNyZWF0ZWQgPSBjcmVhdGUobnVsbCk7XG5cdHJldHVybiBmdW5jdGlvbiAoZGVzYykge1xuXHRcdHZhciBwb3N0Zml4ID0gMCwgbmFtZSwgaWUxMUJ1Z1dvcmthcm91bmQ7XG5cdFx0d2hpbGUgKGNyZWF0ZWRbZGVzYyArIChwb3N0Zml4IHx8ICcnKV0pICsrcG9zdGZpeDtcblx0XHRkZXNjICs9IChwb3N0Zml4IHx8ICcnKTtcblx0XHRjcmVhdGVkW2Rlc2NdID0gdHJ1ZTtcblx0XHRuYW1lID0gJ0BAJyArIGRlc2M7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqUHJvdG90eXBlLCBuYW1lLCBkLmdzKG51bGwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gRm9yIElFMTEgaXNzdWUgc2VlOlxuXHRcdFx0Ly8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2tkZXRhaWwvdmlldy8xOTI4NTA4L1xuXHRcdFx0Ly8gICAgaWUxMS1icm9rZW4tZ2V0dGVycy1vbi1kb20tb2JqZWN0c1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTJcblx0XHRcdGlmIChpZTExQnVnV29ya2Fyb3VuZCkgcmV0dXJuO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSB0cnVlO1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZCh2YWx1ZSkpO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSBmYWxzZTtcblx0XHR9KSk7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH07XG59KCkpO1xuXG4vLyBJbnRlcm5hbCBjb25zdHJ1Y3RvciAobm90IG9uZSBleHBvc2VkKSBmb3IgY3JlYXRpbmcgU3ltYm9sIGluc3RhbmNlcy5cbi8vIFRoaXMgb25lIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYHNvbWVTeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2xgIGFsd2F5cyByZXR1cm4gZmFsc2VcbkhpZGRlblN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIEhpZGRlblN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdHJldHVybiBTeW1ib2xQb2x5ZmlsbChkZXNjcmlwdGlvbik7XG59O1xuXG4vLyBFeHBvc2VkIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyAocmV0dXJucyBpbnN0YW5jZXMgb2YgSGlkZGVuU3ltYm9sKVxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xQb2x5ZmlsbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG5cdGlmIChpc05hdGl2ZVNhZmUpIHJldHVybiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuXHRzeW1ib2wgPSBjcmVhdGUoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSk7XG5cdGRlc2NyaXB0aW9uID0gKGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhkZXNjcmlwdGlvbikpO1xuXHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcyhzeW1ib2wsIHtcblx0XHRfX2Rlc2NyaXB0aW9uX186IGQoJycsIGRlc2NyaXB0aW9uKSxcblx0XHRfX25hbWVfXzogZCgnJywgZ2VuZXJhdGVOYW1lKGRlc2NyaXB0aW9uKSlcblx0fSk7XG59O1xuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbCwge1xuXHRmb3I6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChnbG9iYWxTeW1ib2xzW2tleV0pIHJldHVybiBnbG9iYWxTeW1ib2xzW2tleV07XG5cdFx0cmV0dXJuIChnbG9iYWxTeW1ib2xzW2tleV0gPSBTeW1ib2xQb2x5ZmlsbChTdHJpbmcoa2V5KSkpO1xuXHR9KSxcblx0a2V5Rm9yOiBkKGZ1bmN0aW9uIChzKSB7XG5cdFx0dmFyIGtleTtcblx0XHR2YWxpZGF0ZVN5bWJvbChzKTtcblx0XHRmb3IgKGtleSBpbiBnbG9iYWxTeW1ib2xzKSBpZiAoZ2xvYmFsU3ltYm9sc1trZXldID09PSBzKSByZXR1cm4ga2V5O1xuXHR9KSxcblxuXHQvLyBUbyBlbnN1cmUgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciBuYXRpdmUgZnVuY3Rpb25zIChlLmcuIEFycmF5LmZyb20pXG5cdC8vIGZhbGxiYWNrIHRvIGV2ZW50dWFsIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBnaXZlbiBzeW1ib2xcblx0aGFzSW5zdGFuY2U6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmhhc0luc3RhbmNlKSB8fCBTeW1ib2xQb2x5ZmlsbCgnaGFzSW5zdGFuY2UnKSksXG5cdGlzQ29uY2F0U3ByZWFkYWJsZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlKSB8fFxuXHRcdFN5bWJvbFBvbHlmaWxsKCdpc0NvbmNhdFNwcmVhZGFibGUnKSksXG5cdGl0ZXJhdG9yOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pdGVyYXRvcikgfHwgU3ltYm9sUG9seWZpbGwoJ2l0ZXJhdG9yJykpLFxuXHRtYXRjaDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wubWF0Y2gpIHx8IFN5bWJvbFBvbHlmaWxsKCdtYXRjaCcpKSxcblx0cmVwbGFjZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucmVwbGFjZSkgfHwgU3ltYm9sUG9seWZpbGwoJ3JlcGxhY2UnKSksXG5cdHNlYXJjaDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc2VhcmNoKSB8fCBTeW1ib2xQb2x5ZmlsbCgnc2VhcmNoJykpLFxuXHRzcGVjaWVzOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGVjaWVzKSB8fCBTeW1ib2xQb2x5ZmlsbCgnc3BlY2llcycpKSxcblx0c3BsaXQ6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwbGl0KSB8fCBTeW1ib2xQb2x5ZmlsbCgnc3BsaXQnKSksXG5cdHRvUHJpbWl0aXZlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1ByaW1pdGl2ZSkgfHwgU3ltYm9sUG9seWZpbGwoJ3RvUHJpbWl0aXZlJykpLFxuXHR0b1N0cmluZ1RhZzogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9TdHJpbmdUYWcpIHx8IFN5bWJvbFBvbHlmaWxsKCd0b1N0cmluZ1RhZycpKSxcblx0dW5zY29wYWJsZXM6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnVuc2NvcGFibGVzKSB8fCBTeW1ib2xQb2x5ZmlsbCgndW5zY29wYWJsZXMnKSlcbn0pO1xuXG4vLyBJbnRlcm5hbCB0d2Vha3MgZm9yIHJlYWwgc3ltYm9sIHByb2R1Y2VyXG5kZWZpbmVQcm9wZXJ0aWVzKEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3ltYm9sUG9seWZpbGwpLFxuXHR0b1N0cmluZzogZCgnJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX25hbWVfXzsgfSlcbn0pO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBleHBvc2VkIG9uIFN5bWJvbC5wcm90b3R5cGVcbi8vIFRoZXkgd29uJ3QgYmUgYWNjZXNzaWJsZSBvbiBwcm9kdWNlZCBzeW1ib2wgaW5zdGFuY2VzIGFzIHRoZXkgZGVyaXZlIGZyb20gSGlkZGVuU3ltYm9sLnByb3RvdHlwZVxuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIHtcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1N5bWJvbCAoJyArIHZhbGlkYXRlU3ltYm9sKHRoaXMpLl9fZGVzY3JpcHRpb25fXyArICcpJzsgfSksXG5cdHZhbHVlT2Y6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVTeW1ib2wodGhpcyk7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsIGQoJycsIGZ1bmN0aW9uICgpIHtcblx0dmFyIHN5bWJvbCA9IHZhbGlkYXRlU3ltYm9sKHRoaXMpO1xuXHRpZiAodHlwZW9mIHN5bWJvbCA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2w7XG5cdHJldHVybiBzeW1ib2wudG9TdHJpbmcoKTtcbn0pKTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIGQoJ2MnLCAnU3ltYm9sJykpO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRvbiBvZiB0b1ByaW1pdGl2ZSBhbmQgdG9TdHJpbmdUYWcgZm9yIHJldHVybmVkIHN5bWJvbCBpbnN0YW5jZXNcbmRlZmluZVByb3BlcnR5KEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLFxuXHRkKCdjJywgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnXSkpO1xuXG4vLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0byBkZWZpbmUgYHRvUHJpbWl0aXZlYCBhcyBsYXN0IG9uZSwgYXMgc29tZSBpbXBsZW1lbnRhdGlvbnNcbi8vIGltcGxlbWVudCBgdG9QcmltaXRpdmVgIG5hdGl2ZWx5IHdpdGhvdXQgaW1wbGVtZW50aW5nIGB0b1N0cmluZ1RhZ2AgKG9yIG90aGVyIHNwZWNpZmllZCBzeW1ib2xzKVxuLy8gQW5kIHRoYXQgbWF5IGludm9rZSBlcnJvciBpbiBkZWZpbml0aW9uIGZsb3c6XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNjQxNDYxNDlcbmRlZmluZVByb3BlcnR5KEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLFxuXHRkKCdjJywgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlXSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtc3ltYm9sL25vZGVfbW9kdWxlcy9kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXMtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNTeW1ib2wodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgc3ltYm9sXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0aWYgKCF4KSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgeCA9PT0gJ3N5bWJvbCcpIHJldHVybiB0cnVlO1xuXHRpZiAoIXguY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0aWYgKHguY29uc3RydWN0b3IubmFtZSAhPT0gJ1N5bWJvbCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuICh4W3guY29uc3RydWN0b3IudG9TdHJpbmdUYWddID09PSAnU3ltYm9sJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgaWQgPSBvYmpUb1N0cmluZy5jYWxsKHJlcXVpcmUoXCIuL25vb3BcIikpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGlkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL2lzLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoXCIuL3RvLWludGVnZXJcIilcblxuICAsIG1heCA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuIHJldHVybiBtYXgoMCwgdG9JbnRlZ2VyKHZhbHVlKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL3RvLXBvcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHNpZ24gPSByZXF1aXJlKFwiLi4vbWF0aC9zaWduXCIpXG5cbiAgLCBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoKHZhbHVlID09PSAwKSB8fCAhaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiBzaWduKHZhbHVlKSAqIGZsb29yKGFicyh2YWx1ZSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci90by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gTWF0aC5zaWduXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2lnbiA9IE1hdGguc2lnbjtcblx0aWYgKHR5cGVvZiBzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChzaWduKDEwKSA9PT0gMSkgJiYgKHNpZ24oLTIwKSA9PT0gLTEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczUtZXh0L21hdGgvc2lnbi9pcy1pbXBsZW1lbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPT09IDApKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvbWF0aC9zaWduL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIGZvckVhY2ggID0gcmVxdWlyZShcIi4vZm9yLWVhY2hcIilcbiAgLCBjYWxsICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNiIC8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIHJlc3VsdCA9IHt9LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuXHRjYWxsYWJsZShjYik7XG5cdGZvckVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgdGFyZ2V0T2JqLCBpbmRleCkge1xuXHRcdHJlc3VsdFtrZXldID0gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwga2V5LCB0YXJnZXRPYmosIGluZGV4KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vX2l0ZXJhdGVcIikoXCJmb3JFYWNoXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Zvci1lYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBJbnRlcm5hbCBtZXRob2QsIHVzZWQgYnkgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbi8vIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgZm91bmQgaW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IHRha2VzIGNvbXBhcmVGbiB0byBpdGVyYXRlIG9iamVjdCBpbiBzcGVjaWZpYyBvcmRlclxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNhbGxhYmxlICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLXZhbHVlXCIpXG4gICwgYmluZCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAsIGNhbGwgICAgICAgICAgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBrZXlzICAgICAgICAgICAgICAgICAgICA9IE9iamVjdC5rZXlzXG4gICwgb2JqUHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGRlZlZhbCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKG9iaiwgY2IgLyosIHRoaXNBcmcsIGNvbXBhcmVGbiovKSB7XG5cdFx0dmFyIGxpc3QsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIGNvbXBhcmVGbiA9IGFyZ3VtZW50c1szXTtcblx0XHRvYmogPSBPYmplY3QodmFsdWUob2JqKSk7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXG5cdFx0bGlzdCA9IGtleXMob2JqKTtcblx0XHRpZiAoY29tcGFyZUZuKSB7XG5cdFx0XHRsaXN0LnNvcnQodHlwZW9mIGNvbXBhcmVGbiA9PT0gXCJmdW5jdGlvblwiID8gYmluZC5jYWxsKGNvbXBhcmVGbiwgb2JqKSA6IHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIG1ldGhvZCA9IGxpc3RbbWV0aG9kXTtcblx0XHRyZXR1cm4gY2FsbC5jYWxsKG1ldGhvZCwgbGlzdCwgZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcblx0XHRcdGlmICghb2JqUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSkpIHJldHVybiBkZWZWYWw7XG5cdFx0XHRyZXR1cm4gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmosIGluZGV4KTtcblx0XHR9KTtcblx0fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvX2l0ZXJhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFRoYW5rcyBAbWF0aGlhc2J5bmVuc1xuLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlI2l0ZXJhdGluZy1vdmVyLXN5bWJvbHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi8nKVxuXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBTdHJpbmdJdGVyYXRvcjtcblxuU3RyaW5nSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ0l0ZXJhdG9yKSkgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihzdHIpO1xuXHRzdHIgPSBTdHJpbmcoc3RyKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBzdHIpO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19sZW5ndGhfXycsIGQoJycsIHN0ci5sZW5ndGgpKTtcblxufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoU3RyaW5nSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3RyaW5nSXRlcmF0b3IpLFxuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm47XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHR2YXIgY2hhciA9IHRoaXMuX19saXN0X19baV0sIGNvZGU7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA9PT0gdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gY2hhcjtcblx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdGlmICgoY29kZSA+PSAweEQ4MDApICYmIChjb2RlIDw9IDB4REJGRikpIHJldHVybiBjaGFyICsgdGhpcy5fX2xpc3RfX1t0aGlzLl9fbmV4dEluZGV4X18rK107XG5cdFx0cmV0dXJuIGNoYXI7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzsgfSlcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKCcuL2lzLWl0ZXJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoJ2VzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzJylcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nL2lzLXN0cmluZycpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykuaXRlcmF0b3JcblxuICAsIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNTdHJpbmcodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzQXJndW1lbnRzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiAodHlwZW9mIHZhbHVlW2l0ZXJhdG9yU3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50cycpXG4gICwgY2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy9pcy1zdHJpbmcnKVxuICAsIGdldCAgICAgICAgID0gcmVxdWlyZSgnLi9nZXQnKVxuXG4gICwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNiLyosIHRoaXNBcmcqLykge1xuXHR2YXIgbW9kZSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgcmVzdWx0LCBkb0JyZWFrLCBicm9rZW4sIGksIGwsIGNoYXIsIGNvZGU7XG5cdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIG1vZGUgPSAnYXJyYXknO1xuXHRlbHNlIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIG1vZGUgPSAnc3RyaW5nJztcblx0ZWxzZSBpdGVyYWJsZSA9IGdldChpdGVyYWJsZSk7XG5cblx0Y2FsbGFibGUoY2IpO1xuXHRkb0JyZWFrID0gZnVuY3Rpb24gKCkgeyBicm9rZW4gPSB0cnVlOyB9O1xuXHRpZiAobW9kZSA9PT0gJ2FycmF5Jykge1xuXHRcdHNvbWUuY2FsbChpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobW9kZSA9PT0gJ3N0cmluZycpIHtcblx0XHRsID0gaXRlcmFibGUubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0XHRcdGNoYXIgPSBpdGVyYWJsZVtpXTtcblx0XHRcdGlmICgoaSArIDEpIDwgbCkge1xuXHRcdFx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRpZiAoKGNvZGUgPj0gMHhEODAwKSAmJiAoY29kZSA8PSAweERCRkYpKSBjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHR9XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIGNoYXIsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cblx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBkb0JyZWFrKTtcblx0XHRpZiAoYnJva2VuKSByZXR1cm47XG5cdFx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9mb3Itb2YuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEV4cG9ydHMgdHJ1ZSBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBuYXRpdmUgYFdlYWtNYXBgIGltcGxlbWVudGF0aW9uLCB3aGF0ZXZlciB0aGF0IGlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBXZWFrTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBXZWFrTWFwKCkpID09PSAnW29iamVjdCBXZWFrTWFwXScpO1xufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lczYtd2Vhay1tYXAvaXMtbmF0aXZlLWltcGxlbWVudGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZXh0ZW5kID0gZnVuY3Rpb24ob3V0KSB7XG4gIG91dCA9IG91dCB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWFyZ3VtZW50c1tpXSkgY29udGludWU7XG4gICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG91dFtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0ZW5kOiBleHRlbmRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9hcmlhLWFjY29yZGlvbi9zcmMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBMaXN0ID0gcmVxdWlyZSgnbGlzdC5qcycpO1xudmFyIEFjY29yZGlvbiA9IHJlcXVpcmUoJ2FyaWEtYWNjb3JkaW9uJykuQWNjb3JkaW9uO1xuXG52YXIgS0VZQ09ERV9FTlRFUiA9IDEzO1xudmFyIEtFWUNPREVfRVNDID0gMjc7XG5cbi8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2VsZW1lbnQtbWF0Y2hlcy1zZWxlY3RvclxuZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICB2YXIgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuICB2YXIgZiA9IHAubWF0Y2hlcyB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gW10uaW5kZXhPZi5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocyksIHRoaXMpICE9PSAtMTtcbiAgfTtcbiAgcmV0dXJuIGYuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHZhbHVlcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIFtdLmZvckVhY2guY2FsbCh2YWx1ZXMsIGNhbGxiYWNrKTtcbn1cblxudmFyIGl0ZW1UZW1wbGF0ZSA9IF8udGVtcGxhdGUoXG4gICc8bGkgY2xhc3M9XCJ7eyBnbG9zc2FyeUl0ZW1DbGFzcyB9fVwiPicgK1xuICAgICc8YnV0dG9uIGNsYXNzPVwiZGF0YS1nbG9zc2FyeS10ZXJtIHt7IHRlcm1DbGFzcyB9fVwiPnt7IHRlcm0gfX0nICtcbiAgICAnPC9idXR0b24+JyArXG4gICAgJzxkaXYgY2xhc3M9XCJ7eyBkZWZpbml0aW9uQ2xhc3MgfX1cIj57eyBkZWZpbml0aW9uIH19PC9kaXY+JyArXG4gICc8L2xpPicsXG4gIHtpbnRlcnBvbGF0ZTogL1xce1xceyguKz8pXFx9XFx9L2d9XG4pO1xuXG52YXIgZGVmYXVsdFNlbGVjdG9ycyA9IHtcbiAgZ2xvc3NhcnlJRDogJyNnbG9zc2FyeScsXG4gIHRvZ2dsZTogJy5qcy1nbG9zc2FyeS10b2dnbGUnLFxuICBjbG9zZTogJy5qcy1nbG9zc2FyeS1jbG9zZScsXG4gIGxpc3RDbGFzczogJy5qcy1nbG9zc2FyeS1saXN0JyxcbiAgc2VhcmNoQ2xhc3M6ICcuanMtZ2xvc3Nhcnktc2VhcmNoJ1xufTtcblxudmFyIGRlZmF1bHRDbGFzc2VzID0ge1xuICBkZWZpbml0aW9uQ2xhc3M6ICdnbG9zc2FyeV9fZGVmaW5pdGlvbicsXG4gIGdsb3NzYXJ5SXRlbUNsYXNzOiAnZ2xvc3NhcnlfX2l0ZW0nLFxuICBoaWdobGlnaHRlZFRlcm06ICd0ZXJtLS1oaWdobGlnaHQnLFxuICB0ZXJtQ2xhc3M6ICdnbG9zc2FyeV9fdGVybSdcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVRhYmluZGV4KGVsbSkge1xuICB2YXIgZWxtcyA9IGdldFRhYkluZGV4KGVsbSk7XG4gIGZvckVhY2goZWxtcywgZnVuY3Rpb24oZWxtKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVUYWJpbmRleChlbG0pIHtcbiAgdmFyIGVsbXMgPSBnZXRUYWJJbmRleChlbG0pO1xuICBmb3JFYWNoKGVsbXMsIGZ1bmN0aW9uKGVsbSkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgJzAnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFRhYkluZGV4KGVsbSkge1xuICByZXR1cm4gZWxtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EsIGJ1dHRvbiwgaW5wdXQsIFt0YWJpbmRleF0nKTtcbn1cblxuLyoqXG4gKiBHbG9zc2FyeSB3aWRnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gdGVybXMgLSBUZXJtIG9iamVjdHMgd2l0aCBcImdsb3NzYXJ5LXRlcm1cIiBhbmQgXCJnbG9zc2FyeS1kZWZpbml0aW9uXCIga2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGdsb3NzYXJ5IGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc2VzIC0gQ1NTIGNsYXNzZXMgdG8gYmUgYXBwbGllZCBmb3Igc3R5bGluZ1xuICovXG5mdW5jdGlvbiBHbG9zc2FyeSh0ZXJtcywgc2VsZWN0b3JzLCBjbGFzc2VzKSB7XG4gIHRoaXMudGVybXMgPSB0ZXJtcztcbiAgdGhpcy5zZWxlY3RvcnMgPSBfLmV4dGVuZCh7fSwgZGVmYXVsdFNlbGVjdG9ycywgc2VsZWN0b3JzKTtcbiAgdGhpcy5jbGFzc2VzID0gXy5leHRlbmQoe30sIGRlZmF1bHRDbGFzc2VzLCBjbGFzc2VzKTtcblxuICB0aGlzLmJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JzLmdsb3NzYXJ5SUQpO1xuICB0aGlzLnRvZ2dsZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcnMudG9nZ2xlKTtcbiAgdGhpcy5jbG9zZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcnMuY2xvc2UpO1xuICB0aGlzLnNlYXJjaCA9IHRoaXMuYm9keS5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JzLnNlYXJjaENsYXNzKTtcbiAgdGhpcy5saXN0RWxtID0gdGhpcy5ib2R5LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcnMubGlzdENsYXNzKTtcbiAgdGhpcy5zZWxlY3RlZFRlcm0gPSB0aGlzLnRvZ2dsZUJ0bjtcblxuICAvLyBJbml0aWFsaXplIHN0YXRlXG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cbiAgLy8gVXBkYXRlIERPTVxuICB0aGlzLnBvcHVsYXRlKCk7XG4gIHRoaXMuaW5pdExpc3QoKTtcbiAgdGhpcy5saW5rVGVybXMoKTtcblxuICAvLyBSZW1vdmUgdGFiaW5kaWNlc1xuICByZW1vdmVUYWJpbmRleCh0aGlzLmJvZHkpO1xuXG4gIC8vIEluaXRpYWxpemUgYWNjb3JkaW9uc1xuICB0aGlzLmFjY29yZGlvbiA9IG5ldyBBY2NvcmRpb24odGhpcy5saXN0RWxtLCBudWxsLCB7Y29udGVudFByZWZpeDogJ2dsb3NzYXJ5J30pO1xuXG4gIC8vIEJpbmQgbGlzdGVuZXJzXG4gIHRoaXMubGlzdGVuZXJzID0gW107XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnRvZ2dsZUJ0biwgJ2NsaWNrJywgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNsb3NlQnRuLCAnY2xpY2snLCB0aGlzLmhpZGUuYmluZCh0aGlzKSk7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnNlYXJjaCwgJ2lucHV0JywgdGhpcy5oYW5kbGVJbnB1dC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LmJvZHksICdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5dXAuYmluZCh0aGlzKSk7XG59XG5cbkdsb3NzYXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRlcm1zLmZvckVhY2goZnVuY3Rpb24odGVybSkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgdGVybTogdGVybS50ZXJtLFxuICAgICAgZGVmaW5pdGlvbjogdGVybS5kZWZpbml0aW9uLFxuICAgICAgZGVmaW5pdGlvbkNsYXNzOiB0aGlzLmNsYXNzZXMuZGVmaW5pdGlvbkNsYXNzLFxuICAgICAgZ2xvc3NhcnlJdGVtQ2xhc3M6IHRoaXMuY2xhc3Nlcy5nbG9zc2FyeUl0ZW1DbGFzcyxcbiAgICAgIHRlcm1DbGFzczogdGhpcy5jbGFzc2VzLnRlcm1DbGFzc1xuICAgIH07XG4gICAgdGhpcy5saXN0RWxtLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaXRlbVRlbXBsYXRlKG9wdHMpKTtcbiAgfSwgdGhpcyk7XG59O1xuXG4vKiogSW5pdGlhbGl6ZSBsaXN0LmpzIGxpc3Qgb2YgdGVybXMgKi9cbkdsb3NzYXJ5LnByb3RvdHlwZS5pbml0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ2xvc3NhcnlJZCA9IHRoaXMuc2VsZWN0b3JzLmdsb3NzYXJ5SUQuc2xpY2UoMSk7XG4gIHZhciBsaXN0Q2xhc3MgPSB0aGlzLnNlbGVjdG9ycy5saXN0Q2xhc3Muc2xpY2UoMSk7XG4gIHZhciBzZWFyY2hDbGFzcyA9IHRoaXMuc2VsZWN0b3JzLnNlYXJjaENsYXNzLnNsaWNlKDEpO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICB2YWx1ZU5hbWVzOiBbJ2RhdGEtZ2xvc3NhcnktdGVybSddLFxuICAgIGxpc3RDbGFzczogbGlzdENsYXNzLFxuICAgIHNlYXJjaENsYXNzOiBzZWFyY2hDbGFzcyxcbiAgfTtcbiAgdGhpcy5saXN0ID0gbmV3IExpc3QoZ2xvc3NhcnlJZCwgb3B0aW9ucyk7XG4gIHRoaXMubGlzdC5zb3J0KCdkYXRhLWdsb3NzYXJ5LXRlcm0nLCB7b3JkZXI6ICdhc2MnfSk7XG59O1xuXG4vKiogQWRkIGxpbmtzIHRvIHRlcm1zIGluIGJvZHkgKi9cbkdsb3NzYXJ5LnByb3RvdHlwZS5saW5rVGVybXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGVybV0nKTtcbiAgZm9yRWFjaCh0ZXJtcywgZnVuY3Rpb24odGVybSkge1xuICAgIHRlcm0uc2V0QXR0cmlidXRlKCd0aXRsZScsICdDbGljayB0byBkZWZpbmUnKTtcbiAgICB0ZXJtLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcbiAgICB0ZXJtLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXJtJywgKHRlcm0uZ2V0QXR0cmlidXRlKCdkYXRhLXRlcm0nKSB8fCAnJykudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVUZXJtVG91Y2guYmluZCh0aGlzKSk7XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZVRlcm1Ub3VjaC5iaW5kKHRoaXMpKTtcbn07XG5cbkdsb3NzYXJ5LnByb3RvdHlwZS5oYW5kbGVUZXJtVG91Y2ggPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLndoaWNoID09PSBLRVlDT0RFX0VOVEVSIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChzZWxlY3Rvck1hdGNoZXMoZS50YXJnZXQsICdbZGF0YS10ZXJtXScpKSB7XG4gICAgICB0aGlzLnNob3coZSk7XG4gICAgICB0aGlzLnNlbGVjdGVkVGVybSA9IGUudGFyZ2V0O1xuICAgICAgdGhpcy5maW5kVGVybShlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGVybScpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGVkVGVybSA9IHRoaXMudG9nZ2xlQnRuO1xuICAgIH1cbiAgfVxufTtcblxuLyoqIEhpZ2hsaWdodCBhIHRlcm0gKi9cbkdsb3NzYXJ5LnByb3RvdHlwZS5maW5kVGVybSA9IGZ1bmN0aW9uKHRlcm0pIHtcbiAgdGhpcy5zZWFyY2gudmFsdWUgPSB0ZXJtO1xuICB2YXIgaGlnaGxpZ2h0Q2xhc3MgPSB0aGlzLmNsYXNzZXMuaGlnaGxpZ2h0ZWRUZXJtO1xuXG4gIC8vIEhpZ2hsaWdodCB0aGUgdGVybSBhbmQgcmVtb3ZlIG90aGVyIGhpZ2hsaWdodHNcbiAgZm9yRWFjaCh0aGlzLmJvZHkucXVlcnlTZWxlY3RvckFsbCgnLicgKyBoaWdobGlnaHRDbGFzcyksIGZ1bmN0aW9uKHRlcm0pIHtcbiAgICB0ZXJtLmNsYXNzTGlzdC5yZW1vdmUoaGlnaGxpZ2h0Q2xhc3MpO1xuICB9KTtcbiAgZm9yRWFjaCh0aGlzLmJvZHkucXVlcnlTZWxlY3RvckFsbCgnc3BhbltkYXRhLXRlcm09XCInICsgdGVybSArICdcIl0nKSwgZnVuY3Rpb24odGVybSkge1xuICAgIHRlcm0uY2xhc3NMaXN0LmFkZChoaWdobGlnaHRDbGFzcyk7XG4gIH0pO1xuICB0aGlzLmxpc3QuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5fdmFsdWVzWydkYXRhLWdsb3NzYXJ5LXRlcm0nXS50b0xvd2VyQ2FzZSgpID09PSB0ZXJtO1xuICB9KTtcblxuICB0aGlzLmxpc3Quc2VhcmNoKCk7XG4gIHZhciBidXR0b24gPSB0aGlzLmxpc3QudmlzaWJsZUl0ZW1zWzBdLmVsbS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgdGhpcy5hY2NvcmRpb24uZXhwYW5kKGJ1dHRvbik7XG59O1xuXG5HbG9zc2FyeS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLmlzT3BlbiA/IHRoaXMuaGlkZSA6IHRoaXMuc2hvdztcbiAgbWV0aG9kLmFwcGx5KHRoaXMpO1xufTtcblxuR2xvc3NhcnkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ib2R5LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgdGhpcy50b2dnbGVCdG4uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgdGhpcy5zZWFyY2guZm9jdXMoKTtcbiAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICByZXN0b3JlVGFiaW5kZXgodGhpcy5ib2R5KTtcbn07XG5cbkdsb3NzYXJ5LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYm9keS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgdGhpcy50b2dnbGVCdG4uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gIHRoaXMuc2VsZWN0ZWRUZXJtLmZvY3VzKCk7XG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gIHJlbW92ZVRhYmluZGV4KHRoaXMuYm9keSk7XG59O1xuXG4vKiogUmVtb3ZlIGV4aXN0aW5nIGZpbHRlcnMgb24gaW5wdXQgKi9cbkdsb3NzYXJ5LnByb3RvdHlwZS5oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5saXN0LmZpbHRlcmVkKSB7XG4gICAgdGhpcy5saXN0LmZpbHRlcigpO1xuICB9XG59O1xuXG4vKiogQ2xvc2UgZ2xvc3Nhcnkgb24gZXNjYXBlIGtleXByZXNzICovXG5HbG9zc2FyeS5wcm90b3R5cGUuaGFuZGxlS2V5dXAgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLmtleUNvZGUgPT0gS0VZQ09ERV9FU0MpIHtcbiAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxufTtcblxuR2xvc3NhcnkucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihlbG0sIGV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAoZWxtKSB7XG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgIGVsbTogZWxtLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfSk7XG4gIH1cbn07XG5cbkdsb3NzYXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYWNjb3JkaW9uLmRlc3Ryb3koKTtcbiAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyLmVsbS5yZW1vdmVFdmVudExpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbG9zc2FyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9zcmMvZ2xvc3NhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIihmdW5jdGlvbiggd2luZG93LCB1bmRlZmluZWQgKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICBnZXRCeUNsYXNzID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMvZ2V0LWJ5LWNsYXNzJyksXG4gIGV4dGVuZCA9IHJlcXVpcmUoJy4vc3JjL3V0aWxzL2V4dGVuZCcpLFxuICBpbmRleE9mID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMvaW5kZXgtb2YnKSxcbiAgZXZlbnRzID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMvZXZlbnRzJyksXG4gIHRvU3RyaW5nID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMvdG8tc3RyaW5nJyksXG4gIG5hdHVyYWxTb3J0ID0gcmVxdWlyZSgnLi9zcmMvdXRpbHMvbmF0dXJhbC1zb3J0JyksXG4gIGNsYXNzZXMgPSByZXF1aXJlKCcuL3NyYy91dGlscy9jbGFzc2VzJyksXG4gIGdldEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vc3JjL3V0aWxzL2dldC1hdHRyaWJ1dGUnKSxcbiAgdG9BcnJheSA9IHJlcXVpcmUoJy4vc3JjL3V0aWxzL3RvLWFycmF5Jyk7XG5cbnZhciBMaXN0ID0gZnVuY3Rpb24oaWQsIG9wdGlvbnMsIHZhbHVlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBpbml0LFxuICAgIEl0ZW0gPSByZXF1aXJlKCcuL3NyYy9pdGVtJykoc2VsZiksXG4gICAgYWRkQXN5bmMgPSByZXF1aXJlKCcuL3NyYy9hZGQtYXN5bmMnKShzZWxmKTtcblxuICBpbml0ID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubGlzdENsYXNzICAgICAgPSBcImxpc3RcIjtcbiAgICAgIHNlbGYuc2VhcmNoQ2xhc3MgICAgPSBcInNlYXJjaFwiO1xuICAgICAgc2VsZi5zb3J0Q2xhc3MgICAgICA9IFwic29ydFwiO1xuICAgICAgc2VsZi5wYWdlICAgICAgICAgICA9IDEwMDAwO1xuICAgICAgc2VsZi5pICAgICAgICAgICAgICA9IDE7XG4gICAgICBzZWxmLml0ZW1zICAgICAgICAgID0gW107XG4gICAgICBzZWxmLnZpc2libGVJdGVtcyAgID0gW107XG4gICAgICBzZWxmLm1hdGNoaW5nSXRlbXMgID0gW107XG4gICAgICBzZWxmLnNlYXJjaGVkICAgICAgID0gZmFsc2U7XG4gICAgICBzZWxmLmZpbHRlcmVkICAgICAgID0gZmFsc2U7XG4gICAgICBzZWxmLnNlYXJjaENvbHVtbnMgID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5oYW5kbGVycyAgICAgICA9IHsgJ3VwZGF0ZWQnOiBbXSB9O1xuICAgICAgc2VsZi5wbHVnaW5zICAgICAgICA9IHt9O1xuICAgICAgc2VsZi52YWx1ZU5hbWVzICAgICA9IFtdO1xuICAgICAgc2VsZi51dGlscyAgICAgICAgICA9IHtcbiAgICAgICAgZ2V0QnlDbGFzczogZ2V0QnlDbGFzcyxcbiAgICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIG5hdHVyYWxTb3J0OiBuYXR1cmFsU29ydCxcbiAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgZ2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG4gICAgICAgIHRvQXJyYXk6IHRvQXJyYXlcbiAgICAgIH07XG5cbiAgICAgIHNlbGYudXRpbHMuZXh0ZW5kKHNlbGYsIG9wdGlvbnMpO1xuXG4gICAgICBzZWxmLmxpc3RDb250YWluZXIgPSAodHlwZW9mKGlkKSA9PT0gJ3N0cmluZycpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gICAgICBpZiAoIXNlbGYubGlzdENvbnRhaW5lcikgeyByZXR1cm47IH1cbiAgICAgIHNlbGYubGlzdCAgICAgICA9IGdldEJ5Q2xhc3Moc2VsZi5saXN0Q29udGFpbmVyLCBzZWxmLmxpc3RDbGFzcywgdHJ1ZSk7XG5cbiAgICAgIHNlbGYucGFyc2UgICAgICA9IHJlcXVpcmUoJy4vc3JjL3BhcnNlJykoc2VsZik7XG4gICAgICBzZWxmLnRlbXBsYXRlciAgPSByZXF1aXJlKCcuL3NyYy90ZW1wbGF0ZXInKShzZWxmKTtcbiAgICAgIHNlbGYuc2VhcmNoICAgICA9IHJlcXVpcmUoJy4vc3JjL3NlYXJjaCcpKHNlbGYpO1xuICAgICAgc2VsZi5maWx0ZXIgICAgID0gcmVxdWlyZSgnLi9zcmMvZmlsdGVyJykoc2VsZik7XG4gICAgICBzZWxmLnNvcnQgICAgICAgPSByZXF1aXJlKCcuL3NyYy9zb3J0Jykoc2VsZik7XG5cbiAgICAgIHRoaXMuaGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuaXRlbXMoKTtcbiAgICAgIHNlbGYudXBkYXRlKCk7XG4gICAgICB0aGlzLnBsdWdpbnMoKTtcbiAgICB9LFxuICAgIGhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGhhbmRsZXIgaW4gc2VsZi5oYW5kbGVycykge1xuICAgICAgICBpZiAoc2VsZltoYW5kbGVyXSkge1xuICAgICAgICAgIHNlbGYub24oaGFuZGxlciwgc2VsZltoYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucGFyc2Uoc2VsZi5saXN0KTtcbiAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLmFkZCh2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGx1Z2luczogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGx1Z2luID0gc2VsZi5wbHVnaW5zW2ldO1xuICAgICAgICBzZWxmW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgcGx1Z2luLmluaXQoc2VsZiwgTGlzdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICogUmUtcGFyc2UgdGhlIExpc3QsIHVzZSBpZiBodG1sIGhhdmUgY2hhbmdlZFxuICAqL1xuICB0aGlzLnJlSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLml0ZW1zICAgICAgICAgID0gW107XG4gICAgc2VsZi52aXNpYmxlSXRlbXMgICA9IFtdO1xuICAgIHNlbGYubWF0Y2hpbmdJdGVtcyAgPSBbXTtcbiAgICBzZWxmLnNlYXJjaGVkICAgICAgID0gZmFsc2U7XG4gICAgc2VsZi5maWx0ZXJlZCAgICAgICA9IGZhbHNlO1xuICAgIHNlbGYucGFyc2Uoc2VsZi5saXN0KTtcbiAgfTtcblxuICB0aGlzLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqc29uID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc2VsZi5pdGVtcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBqc29uLnB1c2goc2VsZi5pdGVtc1tpXS52YWx1ZXMoKSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG5cbiAgLypcbiAgKiBBZGQgb2JqZWN0IHRvIGxpc3RcbiAgKi9cbiAgdGhpcy5hZGQgPSBmdW5jdGlvbih2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhZGRBc3luYyh2YWx1ZXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFkZGVkID0gW10sXG4gICAgICBub3RDcmVhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsdWVzWzBdID09PSB1bmRlZmluZWQpe1xuICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG51bGw7XG4gICAgICBub3RDcmVhdGUgPSAoc2VsZi5pdGVtcy5sZW5ndGggPiBzZWxmLnBhZ2UpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgaXRlbSA9IG5ldyBJdGVtKHZhbHVlc1tpXSwgdW5kZWZpbmVkLCBub3RDcmVhdGUpO1xuICAgICAgc2VsZi5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgYWRkZWQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgc2VsZi51cGRhdGUoKTtcbiAgICByZXR1cm4gYWRkZWQ7XG4gIH07XG5cblx0dGhpcy5zaG93ID0gZnVuY3Rpb24oaSwgcGFnZSkge1xuXHRcdHRoaXMuaSA9IGk7XG5cdFx0dGhpcy5wYWdlID0gcGFnZTtcblx0XHRzZWxmLnVwZGF0ZSgpO1xuICAgIHJldHVybiBzZWxmO1xuXHR9O1xuXG4gIC8qIFJlbW92ZXMgb2JqZWN0IGZyb20gbGlzdC5cbiAgKiBMb29wcyB0aHJvdWdoIHRoZSBsaXN0IGFuZCByZW1vdmVzIG9iamVjdHMgd2hlcmVcbiAgKiBwcm9wZXJ0eSBcInZhbHVlbmFtZVwiID09PSB2YWx1ZVxuICAqL1xuICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlTmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm91bmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYuaXRlbXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgaWYgKHNlbGYuaXRlbXNbaV0udmFsdWVzKClbdmFsdWVOYW1lXSA9PSB2YWx1ZSkge1xuICAgICAgICBzZWxmLnRlbXBsYXRlci5yZW1vdmUoc2VsZi5pdGVtc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIHNlbGYuaXRlbXMuc3BsaWNlKGksMSk7XG4gICAgICAgIGlsLS07XG4gICAgICAgIGktLTtcbiAgICAgICAgZm91bmQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi51cGRhdGUoKTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH07XG5cbiAgLyogR2V0cyB0aGUgb2JqZWN0cyBpbiB0aGUgbGlzdCB3aGljaFxuICAqIHByb3BlcnR5IFwidmFsdWVOYW1lXCIgPT09IHZhbHVlXG4gICovXG4gIHRoaXMuZ2V0ID0gZnVuY3Rpb24odmFsdWVOYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtYXRjaGVkSXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzZWxmLml0ZW1zLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc2VsZi5pdGVtc1tpXTtcbiAgICAgIGlmIChpdGVtLnZhbHVlcygpW3ZhbHVlTmFtZV0gPT0gdmFsdWUpIHtcbiAgICAgICAgbWF0Y2hlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVkSXRlbXM7XG4gIH07XG5cbiAgLypcbiAgKiBHZXQgc2l6ZSBvZiB0aGUgbGlzdFxuICAqL1xuICB0aGlzLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5pdGVtcy5sZW5ndGg7XG4gIH07XG5cbiAgLypcbiAgKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSBsaXN0XG4gICovXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnRlbXBsYXRlci5jbGVhcigpO1xuICAgIHNlbGYuaXRlbXMgPSBbXTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgc2VsZi5oYW5kbGVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgdGhpcy5vZmYgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZSA9IHNlbGYuaGFuZGxlcnNbZXZlbnRdO1xuICAgIHZhciBpbmRleCA9IGluZGV4T2YoZSwgY2FsbGJhY2spO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBlLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGkgPSBzZWxmLmhhbmRsZXJzW2V2ZW50XS5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKSB7XG4gICAgICBzZWxmLmhhbmRsZXJzW2V2ZW50XVtpXShzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgdGhpcy5yZXNldCA9IHtcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzID0gc2VsZi5pdGVtcyxcbiAgICAgICAgaWwgPSBpcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaWwtLSkge1xuICAgICAgICBpc1tpbF0uZmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgc2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpcyA9IHNlbGYuaXRlbXMsXG4gICAgICAgIGlsID0gaXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGlsLS0pIHtcbiAgICAgICAgaXNbaWxdLmZvdW5kID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXMgPSBzZWxmLml0ZW1zLFxuXHRcdFx0aWwgPSBpcy5sZW5ndGg7XG5cbiAgICBzZWxmLnZpc2libGVJdGVtcyA9IFtdO1xuICAgIHNlbGYubWF0Y2hpbmdJdGVtcyA9IFtdO1xuICAgIHNlbGYudGVtcGxhdGVyLmNsZWFyKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBpZiAoaXNbaV0ubWF0Y2hpbmcoKSAmJiAoKHNlbGYubWF0Y2hpbmdJdGVtcy5sZW5ndGgrMSkgPj0gc2VsZi5pICYmIHNlbGYudmlzaWJsZUl0ZW1zLmxlbmd0aCA8IHNlbGYucGFnZSkpIHtcbiAgICAgICAgaXNbaV0uc2hvdygpO1xuICAgICAgICBzZWxmLnZpc2libGVJdGVtcy5wdXNoKGlzW2ldKTtcbiAgICAgICAgc2VsZi5tYXRjaGluZ0l0ZW1zLnB1c2goaXNbaV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1tpXS5tYXRjaGluZygpKSB7XG4gICAgICAgIHNlbGYubWF0Y2hpbmdJdGVtcy5wdXNoKGlzW2ldKTtcbiAgICAgICAgaXNbaV0uaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNbaV0uaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZWQnKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICBpbml0LnN0YXJ0KCk7XG59O1xuXG5cbi8vIEFNRCBzdXBwb3J0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBMaXN0OyB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTGlzdDtcbndpbmRvdy5MaXN0ID0gTGlzdDtcblxufSkod2luZG93KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIGNyb3NzLWJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgZ2V0RWxlbWVudHNCeUNsYXNzLlxuICogSGVhdmlseSBiYXNlZCBvbiBEdXN0aW4gRGlheidzIGZ1bmN0aW9uOiBodHRwOi8vZHVzdGluZGlhei5jb20vZ2V0ZWxlbWVudHNieWNsYXNzLlxuICpcbiAqIEZpbmQgYWxsIGVsZW1lbnRzIHdpdGggY2xhc3MgYGNsYXNzTmFtZWAgaW5zaWRlIGBjb250YWluZXJgLlxuICogVXNlIGBzaW5nbGUgPSB0cnVlYCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSBpbiBvbGRlciBicm93c2Vyc1xuICogd2hlbiBvbmx5IG9uZSBlbGVtZW50IGlzIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRhaW5lciwgY2xhc3NOYW1lLCBzaW5nbGUpIHtcbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udGFpbmVyLCBjbGFzc05hbWUsIHNpbmdsZSkge1xuICAgICAgY2xhc3NOYW1lID0gJy4nICsgY2xhc3NOYW1lO1xuICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRhaW5lciwgY2xhc3NOYW1lLCBzaW5nbGUpIHtcbiAgICAgIHZhciBjbGFzc0VsZW1lbnRzID0gW10sXG4gICAgICAgIHRhZyA9ICcqJztcbiAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICB2YXIgZWxzID0gY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG4gICAgICB2YXIgZWxzTGVuID0gZWxzLmxlbmd0aDtcbiAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiK2NsYXNzTmFtZStcIihcXFxcc3wkKVwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGVsc0xlbjsgaSsrKSB7XG4gICAgICAgIGlmICggcGF0dGVybi50ZXN0KGVsc1tpXS5jbGFzc05hbWUpICkge1xuICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbHNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzRWxlbWVudHNbal0gPSBlbHNbaV07XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3NFbGVtZW50cztcbiAgICB9O1xuICB9XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy91dGlscy9nZXQtYnktY2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXh0ZW5kXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQgKG9iamVjdCkge1xuICAgIC8vIFRha2VzIGFuIHVubGltaXRlZCBudW1iZXIgb2YgZXh0ZW5kZXJzLlxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIC8vIEZvciBlYWNoIGV4dGVuZGVyLCBjb3B5IHRoZWlyIHByb3BlcnRpZXMgb24gb3VyIG9iamVjdC5cbiAgICBmb3IgKHZhciBpID0gMCwgc291cmNlOyBzb3VyY2UgPSBhcmdzW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL2V4dGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJpbmQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdhdHRhY2hFdmVudCcsXG4gICAgdW5iaW5kID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnLFxuICAgIHByZWZpeCA9IGJpbmQgIT09ICdhZGRFdmVudExpc3RlbmVyJyA/ICdvbicgOiAnJyxcbiAgICB0b0FycmF5ID0gcmVxdWlyZSgnLi90by1hcnJheScpO1xuXG4vKipcbiAqIEJpbmQgYGVsYCBldmVudCBgdHlwZWAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsLCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gb3IgQXJyYXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsID0gdG9BcnJheShlbCk7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrICkge1xuICAgIGVsW2ldW2JpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwsIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiBvciBBcnJheVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51bmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbCA9IHRvQXJyYXkoZWwpO1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKyApIHtcbiAgICBlbFtpXVt1bmJpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IChzID09PSB1bmRlZmluZWQpID8gXCJcIiA6IHM7XG4gIHMgPSAocyA9PT0gbnVsbCkgPyBcIlwiIDogcztcbiAgcyA9IHMudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy91dGlscy90by1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDIzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qXG4gKiBOYXR1cmFsIFNvcnQgYWxnb3JpdGhtIGZvciBKYXZhc2NyaXB0IC0gVmVyc2lvbiAwLjguMSAtIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiBBdXRob3I6IEppbSBQYWxtZXIgKGJhc2VkIG9uIGNodW5raW5nIGlkZWEgZnJvbSBEYXZlIEtvZWxsZSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiLCBvcHRzKSB7XG4gICAgdmFyIHJlID0gLyheKFsrXFwtXT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8oPz1cXER8XFxzfCQpKXxeMHhbXFxkYS1mQS1GXSskfFxcZCspL2csXG4gICAgICAgIHNyZSA9IC9eXFxzK3xcXHMrJC9nLCAgIC8vIHRyaW0gcHJlLXBvc3Qgd2hpdGVzcGFjZVxuICAgICAgICBzbnJlID0gL1xccysvZywgICAgICAgIC8vIG5vcm1hbGl6ZSBhbGwgd2hpdGVzcGFjZSB0byBzaW5nbGUgJyAnIGNoYXJhY3RlclxuICAgICAgICBkcmUgPSAvKF4oW1xcdyBdKyw/W1xcdyBdKyk/W1xcdyBdKyw/W1xcdyBdK1xcZCs6XFxkKyg6XFxkKyk/W1xcdyBdP3xeXFxkezEsNH1bXFwvXFwtXVxcZHsxLDR9W1xcL1xcLV1cXGR7MSw0fXxeXFx3KywgXFx3KyBcXGQrLCBcXGR7NH0pLyxcbiAgICAgICAgaHJlID0gL14weFswLTlhLWZdKyQvaSxcbiAgICAgICAgb3JlID0gL14wLyxcbiAgICAgICAgb3B0aW9ucyA9IG9wdHMgfHwge30sXG4gICAgICAgIGkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMuaW5zZW5zaXRpdmUgJiYgKCcnICsgcykudG9Mb3dlckNhc2UoKSB8fCAnJyArIHMpLnJlcGxhY2Uoc3JlLCAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIHRvIHN0cmluZ3Mgc3RyaXAgd2hpdGVzcGFjZVxuICAgICAgICB4ID0gaShhKSxcbiAgICAgICAgeSA9IGkoYiksXG4gICAgICAgIC8vIGNodW5rL3Rva2VuaXplXG4gICAgICAgIHhOID0geC5yZXBsYWNlKHJlLCAnXFwwJDFcXDAnKS5yZXBsYWNlKC9cXDAkLywnJykucmVwbGFjZSgvXlxcMC8sJycpLnNwbGl0KCdcXDAnKSxcbiAgICAgICAgeU4gPSB5LnJlcGxhY2UocmUsICdcXDAkMVxcMCcpLnJlcGxhY2UoL1xcMCQvLCcnKS5yZXBsYWNlKC9eXFwwLywnJykuc3BsaXQoJ1xcMCcpLFxuICAgICAgICAvLyBudW1lcmljLCBoZXggb3IgZGF0ZSBkZXRlY3Rpb25cbiAgICAgICAgeEQgPSBwYXJzZUludCh4Lm1hdGNoKGhyZSksIDE2KSB8fCAoeE4ubGVuZ3RoICE9PSAxICYmIERhdGUucGFyc2UoeCkpLFxuICAgICAgICB5RCA9IHBhcnNlSW50KHkubWF0Y2goaHJlKSwgMTYpIHx8IHhEICYmIHkubWF0Y2goZHJlKSAmJiBEYXRlLnBhcnNlKHkpIHx8IG51bGwsXG4gICAgICAgIG5vcm1DaHVuayA9IGZ1bmN0aW9uKHMsIGwpIHtcbiAgICAgICAgICAgLy8gbm9ybWFsaXplIHNwYWNlczsgZmluZCBmbG9hdHMgbm90IHN0YXJ0aW5nIHdpdGggJzAnLCBzdHJpbmcgb3IgMCBpZiBub3QgZGVmaW5lZCAoQ2xpbnQgUHJpZXN0KVxuICAgICAgICAgICByZXR1cm4gKCFzLm1hdGNoKG9yZSkgfHwgbCA9PSAxKSAmJiBwYXJzZUZsb2F0KHMpIHx8IHMucmVwbGFjZShzbnJlLCAnICcpLnJlcGxhY2Uoc3JlLCAnJykgfHwgMDtcbiAgICAgICAgfSxcbiAgICAgICAgb0Z4TmNMLCBvRnlOY0w7XG4gICAvLyBmaXJzdCB0cnkgYW5kIHNvcnQgSGV4IGNvZGVzIG9yIERhdGVzXG4gICBpZiAoeUQpIHtcbiAgICAgICBpZiAoeEQgPCB5RCkgeyByZXR1cm4gLTE7IH1cbiAgICAgICBlbHNlIGlmICh4RCA+IHlEKSB7IHJldHVybiAxOyB9XG4gICB9XG4gICAvLyBuYXR1cmFsIHNvcnRpbmcgdGhyb3VnaCBzcGxpdCBudW1lcmljIHN0cmluZ3MgYW5kIGRlZmF1bHQgc3RyaW5nc1xuICAgZm9yKHZhciBjTG9jID0gMCwgeE5sID0geE4ubGVuZ3RoLCB5TmwgPSB5Ti5sZW5ndGgsIG51bVMgPSBNYXRoLm1heCh4TmwsIHlObCk7IGNMb2MgPCBudW1TOyBjTG9jKyspIHtcbiAgICAgICBvRnhOY0wgPSBub3JtQ2h1bmsoeE5bY0xvY10gfHwgJycsIHhObCk7XG4gICAgICAgb0Z5TmNMID0gbm9ybUNodW5rKHlOW2NMb2NdIHx8ICcnLCB5TmwpO1xuICAgICAgIC8vIGhhbmRsZSBudW1lcmljIHZzIHN0cmluZyBjb21wYXJpc29uIC0gbnVtYmVyIDwgc3RyaW5nIC0gKEt5bGUgQWRhbXMpXG4gICAgICAgaWYgKGlzTmFOKG9GeE5jTCkgIT09IGlzTmFOKG9GeU5jTCkpIHtcbiAgICAgICAgICAgcmV0dXJuIGlzTmFOKG9GeE5jTCkgPyAxIDogLTE7XG4gICAgICAgfVxuICAgICAgIC8vIGlmIHVuaWNvZGUgdXNlIGxvY2FsZSBjb21wYXJpc29uXG4gICAgICAgaWYgKC9bXlxceDAwLVxceDgwXS8udGVzdChvRnhOY0wgKyBvRnlOY0wpICYmIG9GeE5jTC5sb2NhbGVDb21wYXJlKSB7XG4gICAgICAgICAgIHZhciBjb21wID0gb0Z4TmNMLmxvY2FsZUNvbXBhcmUob0Z5TmNMKTtcbiAgICAgICAgICAgcmV0dXJuIGNvbXAgLyBNYXRoLmFicyhjb21wKTtcbiAgICAgICB9XG4gICAgICAgaWYgKG9GeE5jTCA8IG9GeU5jTCkgeyByZXR1cm4gLTE7IH1cbiAgICAgICBlbHNlIGlmIChvRnhOY0wgPiBvRnlOY0wpIHsgcmV0dXJuIDE7IH1cbiAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL25hdHVyYWwtc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vaW5kZXgtb2YnKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIHJlZ2V4cC5cbiAqL1xuXG52YXIgcmUgPSAvXFxzKy87XG5cbi8qKlxuICogdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsKXtcbiAgcmV0dXJuIG5ldyBDbGFzc0xpc3QoZWwpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IENsYXNzTGlzdCBmb3IgYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XG59XG5cbi8qKlxuICogQWRkIGNsYXNzIGBuYW1lYCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSl7XG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LmFkZChuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKCF+aSkgYXJyLnB1c2gobmFtZSk7XG4gIHRoaXMuZWwuY2xhc3NOYW1lID0gYXJyLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxuICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcbiAqIGFueSB3aGljaCBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKXtcbiAgaWYgKCdbb2JqZWN0IFJlZ0V4cF0nID09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcbiAgfVxuXG4gIC8vIGNsYXNzTGlzdFxuICBpZiAodGhpcy5saXN0KSB7XG4gICAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIHZhciBpID0gaW5kZXgoYXJyLCBuYW1lKTtcbiAgaWYgKH5pKSBhcnIuc3BsaWNlKGksIDEpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSl7XG4gIHZhciBhcnIgPSB0aGlzLmFycmF5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xuICAgICAgdGhpcy5yZW1vdmUoYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBjbGFzcyBgbmFtZWAsIGNhbiBmb3JjZSBzdGF0ZSB2aWEgYGZvcmNlYC5cbiAqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxuICogdGhlIG1pc3Rha2Ugd2lsbCBiZSBkZXRlY3RlZCBhbmQgY29ycmVjdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24obmFtZSwgZm9yY2Upe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgdGhpcy5yZW1vdmUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpe1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gIHZhciBzdHIgPSBjbGFzc05hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB2YXIgYXJyID0gc3RyLnNwbGl0KHJlKTtcbiAgaWYgKCcnID09PSBhcnJbMF0pIGFyci5zaGlmdCgpO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmhhcyA9XG5DbGFzc0xpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiB0aGlzLmxpc3QgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSkgOiAhISB+aW5kZXgodGhpcy5hcnJheSgpLCBuYW1lKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3V0aWxzL2NsYXNzZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBjcm9zcy1icm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGdldEF0dHJpYnV0ZS5cbiAqIFNvdXJjZSBmb3VuZCBoZXJlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzU1MzQzLzM2MTMzNyB3cml0dGVuIGJ5IFZpdmluIFBhbGlhdGhcbiAqXG4gKiBSZXR1cm4gdGhlIHZhbHVlIGZvciBgYXR0cmAgYXQgYGVsZW1lbnRgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwsIGF0dHIpIHtcbiAgdmFyIHJlc3VsdCA9IChlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKGF0dHIpKSB8fCBudWxsO1xuICBpZiggIXJlc3VsdCApIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgIHZhciBsZW5ndGggPSBhdHRycy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cltpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmKGF0dHJbaV0ubm9kZU5hbWUgPT09IGF0dHIpIHtcbiAgICAgICAgICByZXN1bHQgPSBhdHRyW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHZhciBhZGRBc3luYyA9IGZ1bmN0aW9uKHZhbHVlcywgY2FsbGJhY2ssIGl0ZW1zKSB7XG4gICAgdmFyIHZhbHVlc1RvQWRkID0gdmFsdWVzLnNwbGljZSgwLCA1MCk7XG4gICAgaXRlbXMgPSBpdGVtcyB8fCBbXTtcbiAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChsaXN0LmFkZCh2YWx1ZXNUb0FkZCkpO1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgYWRkQXN5bmModmFsdWVzLCBjYWxsYmFjaywgaXRlbXMpO1xuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QudXBkYXRlKCk7XG4gICAgICBjYWxsYmFjayhpdGVtcyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYWRkQXN5bmM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2dsb3NzYXJ5LXBhbmVsL25vZGVfbW9kdWxlcy9saXN0LmpzL3NyYy9hZGQtYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCkge1xuXG4gIHZhciBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJykobGlzdCk7XG5cbiAgdmFyIGdldENoaWxkcmVuID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkTm9kZXMsXG4gICAgICBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgdGV4dG5vZGVzIGhhdmUgYSBkYXRhIGF0dHJpYnV0ZVxuICAgICAgaWYgKG5vZGVzW2ldLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpdGVtcy5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uKGl0ZW1FbGVtZW50cywgdmFsdWVOYW1lcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGl0ZW1FbGVtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBsaXN0Lml0ZW1zLnB1c2gobmV3IEl0ZW0odmFsdWVOYW1lcywgaXRlbUVsZW1lbnRzW2ldKSk7XG4gICAgfVxuICB9O1xuICB2YXIgcGFyc2VBc3luYyA9IGZ1bmN0aW9uKGl0ZW1FbGVtZW50cywgdmFsdWVOYW1lcykge1xuICAgIHZhciBpdGVtc1RvSW5kZXggPSBpdGVtRWxlbWVudHMuc3BsaWNlKDAsIDUwKTsgLy8gVE9ETzogSWYgPCAxMDAgaXRlbXMsIHdoYXQgaGFwcGVucyBpbiBJRSBldGM/XG4gICAgcGFyc2UoaXRlbXNUb0luZGV4LCB2YWx1ZU5hbWVzKTtcbiAgICBpZiAoaXRlbUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhcnNlQXN5bmMoaXRlbUVsZW1lbnRzLCB2YWx1ZU5hbWVzKTtcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnVwZGF0ZSgpO1xuICAgICAgbGlzdC50cmlnZ2VyKCdwYXJzZUNvbXBsZXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIGxpc3QuaGFuZGxlcnMucGFyc2VDb21wbGV0ZSA9IGxpc3QuaGFuZGxlcnMucGFyc2VDb21wbGV0ZSB8fCBbXTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zVG9JbmRleCA9IGdldENoaWxkcmVuKGxpc3QubGlzdCksXG4gICAgICB2YWx1ZU5hbWVzID0gbGlzdC52YWx1ZU5hbWVzO1xuXG4gICAgaWYgKGxpc3QuaW5kZXhBc3luYykge1xuICAgICAgcGFyc2VBc3luYyhpdGVtc1RvSW5kZXgsIHZhbHVlTmFtZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZShpdGVtc1RvSW5kZXgsIHZhbHVlTmFtZXMpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL3BhcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgVGVtcGxhdGVyID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgaXRlbVNvdXJjZSxcbiAgICB0ZW1wbGF0ZXIgPSB0aGlzO1xuXG4gIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgaXRlbVNvdXJjZSA9IHRlbXBsYXRlci5nZXRJdGVtU291cmNlKGxpc3QuaXRlbSk7XG4gICAgaWYgKGl0ZW1Tb3VyY2UpIHtcbiAgICAgIGl0ZW1Tb3VyY2UgPSB0ZW1wbGF0ZXIuY2xlYXJTb3VyY2VJdGVtKGl0ZW1Tb3VyY2UsIGxpc3QudmFsdWVOYW1lcyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY2xlYXJTb3VyY2VJdGVtID0gZnVuY3Rpb24oZWwsIHZhbHVlTmFtZXMpIHtcbiAgICBmb3IodmFyIGkgPSAwLCBpbCA9IHZhbHVlTmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIGVsbTtcbiAgICAgIGlmICh2YWx1ZU5hbWVzW2ldLmRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gdmFsdWVOYW1lc1tpXS5kYXRhLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyt2YWx1ZU5hbWVzW2ldLmRhdGFbal0sICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZU5hbWVzW2ldLmF0dHIgJiYgdmFsdWVOYW1lc1tpXS5uYW1lKSB7XG4gICAgICAgIGVsbSA9IGxpc3QudXRpbHMuZ2V0QnlDbGFzcyhlbCwgdmFsdWVOYW1lc1tpXS5uYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUodmFsdWVOYW1lc1tpXS5hdHRyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtID0gbGlzdC51dGlscy5nZXRCeUNsYXNzKGVsLCB2YWx1ZU5hbWVzW2ldLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgIGVsbS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICB0aGlzLmdldEl0ZW1Tb3VyY2UgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIG5vZGVzID0gbGlzdC5saXN0LmNoaWxkTm9kZXMsXG4gICAgICAgIGl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgLy8gT25seSB0ZXh0bm9kZXMgaGF2ZSBhIGRhdGEgYXR0cmlidXRlXG4gICAgICAgIGlmIChub2Rlc1tpXS5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvPHRyW1xccz5dL2cuZXhlYyhpdGVtKSkge1xuICAgICAgdmFyIHRib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgIHRib2R5LmlubmVySFRNTCA9IGl0ZW07XG4gICAgICByZXR1cm4gdGJvZHkuZmlyc3RDaGlsZDtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW5kZXhPZihcIjxcIikgIT09IC0xKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gaXRlbTtcbiAgICAgIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNvdXJjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxpc3QuaXRlbSk7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdGhpcy5nZXQgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZU5hbWVzKSB7XG4gICAgdGVtcGxhdGVyLmNyZWF0ZShpdGVtKTtcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgZm9yKHZhciBpID0gMCwgaWwgPSB2YWx1ZU5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHZhciBlbG07XG4gICAgICBpZiAodmFsdWVOYW1lc1tpXS5kYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHZhbHVlTmFtZXNbaV0uZGF0YS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlTmFtZXNbaV0uZGF0YVtqXV0gPSBsaXN0LnV0aWxzLmdldEF0dHJpYnV0ZShpdGVtLmVsbSwgJ2RhdGEtJyt2YWx1ZU5hbWVzW2ldLmRhdGFbal0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlTmFtZXNbaV0uYXR0ciAmJiB2YWx1ZU5hbWVzW2ldLm5hbWUpIHtcbiAgICAgICAgZWxtID0gbGlzdC51dGlscy5nZXRCeUNsYXNzKGl0ZW0uZWxtLCB2YWx1ZU5hbWVzW2ldLm5hbWUsIHRydWUpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVOYW1lc1tpXS5uYW1lXSA9IGVsbSA/IGxpc3QudXRpbHMuZ2V0QXR0cmlidXRlKGVsbSwgdmFsdWVOYW1lc1tpXS5hdHRyKSA6IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbG0gPSBsaXN0LnV0aWxzLmdldEJ5Q2xhc3MoaXRlbS5lbG0sIHZhbHVlTmFtZXNbaV0sIHRydWUpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVOYW1lc1tpXV0gPSBlbG0gPyBlbG0uaW5uZXJIVE1MIDogXCJcIjtcbiAgICAgIH1cbiAgICAgIGVsbSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICB0aGlzLnNldCA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlcykge1xuICAgIHZhciBnZXRWYWx1ZU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBsaXN0LnZhbHVlTmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBpZiAobGlzdC52YWx1ZU5hbWVzW2ldLmRhdGEpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGxpc3QudmFsdWVOYW1lc1tpXS5kYXRhO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGRhdGEubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbal0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbmFtZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaXN0LnZhbHVlTmFtZXNbaV0uYXR0ciAmJiBsaXN0LnZhbHVlTmFtZXNbaV0ubmFtZSAmJiBsaXN0LnZhbHVlTmFtZXNbaV0ubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3QudmFsdWVOYW1lc1tpXTtcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0LnZhbHVlTmFtZXNbaV0gPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNldFZhbHVlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBlbG07XG4gICAgICB2YXIgdmFsdWVOYW1lID0gZ2V0VmFsdWVOYW1lKG5hbWUpO1xuICAgICAgaWYgKCF2YWx1ZU5hbWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZU5hbWUuZGF0YSkge1xuICAgICAgICBpdGVtLmVsbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyt2YWx1ZU5hbWUuZGF0YSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZU5hbWUuYXR0ciAmJiB2YWx1ZU5hbWUubmFtZSkge1xuICAgICAgICBlbG0gPSBsaXN0LnV0aWxzLmdldEJ5Q2xhc3MoaXRlbS5lbG0sIHZhbHVlTmFtZS5uYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUodmFsdWVOYW1lLmF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtID0gbGlzdC51dGlscy5nZXRCeUNsYXNzKGl0ZW0uZWxtLCB2YWx1ZU5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgZWxtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbG0gPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBpZiAoIXRlbXBsYXRlci5jcmVhdGUoaXRlbSkpIHtcbiAgICAgIGZvcih2YXIgdiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2KSkge1xuICAgICAgICAgIHNldFZhbHVlKHYsIHZhbHVlc1t2XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKGl0ZW0uZWxtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZW1Tb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgbmVlZCB0byBoYXZlIGF0IGxpc3Qgb25lIGl0ZW0gb24gaW5pdCBvdGhlcndpc2UgeW91J2xsIGhhdmUgdG8gYWRkIGEgdGVtcGxhdGUuXCIpO1xuICAgIH1cbiAgICAvKiBJZiBpdGVtIHNvdXJjZSBkb2VzIG5vdCBleGlzdHMsIHVzZSB0aGUgZmlyc3QgaXRlbSBpbiBsaXN0IGFzXG4gICAgc291cmNlIGZvciBuZXcgaXRlbXMgKi9cbiAgICB2YXIgbmV3SXRlbSA9IGl0ZW1Tb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgIG5ld0l0ZW0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgIGl0ZW0uZWxtID0gbmV3SXRlbTtcbiAgICB0ZW1wbGF0ZXIuc2V0KGl0ZW0sIGl0ZW0udmFsdWVzKCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5lbG0ucGFyZW50Tm9kZSA9PT0gbGlzdC5saXN0KSB7XG4gICAgICBsaXN0Lmxpc3QucmVtb3ZlQ2hpbGQoaXRlbS5lbG0pO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHRlbXBsYXRlci5jcmVhdGUoaXRlbSk7XG4gICAgbGlzdC5saXN0LmFwcGVuZENoaWxkKGl0ZW0uZWxtKTtcbiAgfTtcbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIGlmIChpdGVtLmVsbSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0uZWxtLnBhcmVudE5vZGUgPT09IGxpc3QubGlzdCkge1xuICAgICAgbGlzdC5saXN0LnJlbW92ZUNoaWxkKGl0ZW0uZWxtKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAvKiAuaW5uZXJIVE1MID0gJyc7IGZ1Y2tzIHVwIElFICovXG4gICAgaWYgKGxpc3QubGlzdC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHdoaWxlIChsaXN0Lmxpc3QuY2hpbGROb2Rlcy5sZW5ndGggPj0gMSlcbiAgICAgIHtcbiAgICAgICAgbGlzdC5saXN0LnJlbW92ZUNoaWxkKGxpc3QubGlzdC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGVyKGxpc3QpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvdGVtcGxhdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgdmFyIGl0ZW0sXG4gICAgdGV4dCxcbiAgICBjb2x1bW5zLFxuICAgIHNlYXJjaFN0cmluZyxcbiAgICBjdXN0b21TZWFyY2g7XG5cbiAgdmFyIHByZXBhcmUgPSB7XG4gICAgcmVzZXRMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3QuaSA9IDE7XG4gICAgICBsaXN0LnRlbXBsYXRlci5jbGVhcigpO1xuICAgICAgY3VzdG9tU2VhcmNoID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24oYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgYXJnc1sxXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbHVtbnMgPSBhcmdzWzFdO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIHR5cGVvZihhcmdzWzFdKSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29sdW1ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY3VzdG9tU2VhcmNoID0gYXJnc1sxXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT0gMykge1xuICAgICAgICBjb2x1bW5zID0gYXJnc1sxXTtcbiAgICAgICAgY3VzdG9tU2VhcmNoID0gYXJnc1syXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsaXN0Lml0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2x1bW5zID0gKGxpc3Quc2VhcmNoQ29sdW1ucyA9PT0gdW5kZWZpbmVkKSA/IHByZXBhcmUudG9BcnJheShsaXN0Lml0ZW1zWzBdLnZhbHVlcygpKSA6IGxpc3Quc2VhcmNoQ29sdW1ucztcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFNlYXJjaFN0cmluZzogZnVuY3Rpb24ocykge1xuICAgICAgcyA9IGxpc3QudXRpbHMudG9TdHJpbmcocykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXS9nLCBcIlxcXFwkJlwiKTsgLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzXG4gICAgICBzZWFyY2hTdHJpbmcgPSBzO1xuICAgIH0sXG4gICAgdG9BcnJheTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YXIgdG1wQ29sdW1uID0gW107XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHZhbHVlcykge1xuICAgICAgICB0bXBDb2x1bW4ucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0bXBDb2x1bW47XG4gICAgfVxuICB9O1xuICB2YXIgc2VhcmNoID0ge1xuICAgIGxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgayA9IDAsIGtsID0gbGlzdC5pdGVtcy5sZW5ndGg7IGsgPCBrbDsgaysrKSB7XG4gICAgICAgIHNlYXJjaC5pdGVtKGxpc3QuaXRlbXNba10pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaXRlbS5mb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gY29sdW1ucy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIGlmIChzZWFyY2gudmFsdWVzKGl0ZW0udmFsdWVzKCksIGNvbHVtbnNbal0pKSB7XG4gICAgICAgICAgaXRlbS5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcywgY29sdW1uKSB7XG4gICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGNvbHVtbikpIHtcbiAgICAgICAgdGV4dCA9IGxpc3QudXRpbHMudG9TdHJpbmcodmFsdWVzW2NvbHVtbl0pLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICgoc2VhcmNoU3RyaW5nICE9PSBcIlwiKSAmJiAodGV4dC5zZWFyY2goc2VhcmNoU3RyaW5nKSA+IC0xKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICBsaXN0LnJlc2V0LnNlYXJjaCgpO1xuICAgICAgbGlzdC5zZWFyY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2VhcmNoTWV0aG9kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGlzdC50cmlnZ2VyKCdzZWFyY2hTdGFydCcpO1xuXG4gICAgcHJlcGFyZS5yZXNldExpc3QoKTtcbiAgICBwcmVwYXJlLnNldFNlYXJjaFN0cmluZyhzdHIpO1xuICAgIHByZXBhcmUuc2V0T3B0aW9ucyhhcmd1bWVudHMpOyAvLyBzdHIsIGNvbHN8c2VhcmNoRnVuY3Rpb24sIHNlYXJjaEZ1bmN0aW9uXG4gICAgcHJlcGFyZS5zZXRDb2x1bW5zKCk7XG5cbiAgICBpZiAoc2VhcmNoU3RyaW5nID09PSBcIlwiICkge1xuICAgICAgc2VhcmNoLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc2VhcmNoZWQgPSB0cnVlO1xuICAgICAgaWYgKGN1c3RvbVNlYXJjaCkge1xuICAgICAgICBjdXN0b21TZWFyY2goc2VhcmNoU3RyaW5nLCBjb2x1bW5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaC5saXN0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdC51cGRhdGUoKTtcbiAgICBsaXN0LnRyaWdnZXIoJ3NlYXJjaENvbXBsZXRlJyk7XG4gICAgcmV0dXJuIGxpc3QudmlzaWJsZUl0ZW1zO1xuICB9O1xuXG4gIGxpc3QuaGFuZGxlcnMuc2VhcmNoU3RhcnQgPSBsaXN0LmhhbmRsZXJzLnNlYXJjaFN0YXJ0IHx8IFtdO1xuICBsaXN0LmhhbmRsZXJzLnNlYXJjaENvbXBsZXRlID0gbGlzdC5oYW5kbGVycy5zZWFyY2hDb21wbGV0ZSB8fCBbXTtcblxuICBsaXN0LnV0aWxzLmV2ZW50cy5iaW5kKGxpc3QudXRpbHMuZ2V0QnlDbGFzcyhsaXN0Lmxpc3RDb250YWluZXIsIGxpc3Quc2VhcmNoQ2xhc3MpLCAna2V5dXAnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCwgLy8gSUUgaGF2ZSBzcmNFbGVtZW50XG4gICAgICBhbHJlYWR5Q2xlYXJlZCA9ICh0YXJnZXQudmFsdWUgPT09IFwiXCIgJiYgIWxpc3Quc2VhcmNoZWQpO1xuICAgIGlmICghYWxyZWFkeUNsZWFyZWQpIHsgLy8gSWYgb25pbnB1dCBhbHJlYWR5IGhhdmUgcmVzZXR0ZWQgdGhlIGxpc3QsIGRvIG5vdGhpbmdcbiAgICAgIHNlYXJjaE1ldGhvZCh0YXJnZXQudmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVXNlZCB0byBkZXRlY3QgY2xpY2sgb24gSFRNTDUgY2xlYXIgYnV0dG9uXG4gIGxpc3QudXRpbHMuZXZlbnRzLmJpbmQobGlzdC51dGlscy5nZXRCeUNsYXNzKGxpc3QubGlzdENvbnRhaW5lciwgbGlzdC5zZWFyY2hDbGFzcyksICdpbnB1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGlmICh0YXJnZXQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHNlYXJjaE1ldGhvZCgnJyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VhcmNoTWV0aG9kO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvc2VhcmNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QpIHtcblxuICAvLyBBZGQgaGFuZGxlcnNcbiAgbGlzdC5oYW5kbGVycy5maWx0ZXJTdGFydCA9IGxpc3QuaGFuZGxlcnMuZmlsdGVyU3RhcnQgfHwgW107XG4gIGxpc3QuaGFuZGxlcnMuZmlsdGVyQ29tcGxldGUgPSBsaXN0LmhhbmRsZXJzLmZpbHRlckNvbXBsZXRlIHx8IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihmaWx0ZXJGdW5jdGlvbikge1xuICAgIGxpc3QudHJpZ2dlcignZmlsdGVyU3RhcnQnKTtcbiAgICBsaXN0LmkgPSAxOyAvLyBSZXNldCBwYWdpbmdcbiAgICBsaXN0LnJlc2V0LmZpbHRlcigpO1xuICAgIGlmIChmaWx0ZXJGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaXN0LmZpbHRlcmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QuZmlsdGVyZWQgPSB0cnVlO1xuICAgICAgdmFyIGlzID0gbGlzdC5pdGVtcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpc1tpXTtcbiAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbS5maWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5maWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3QudXBkYXRlKCk7XG4gICAgbGlzdC50cmlnZ2VyKCdmaWx0ZXJDb21wbGV0ZScpO1xuICAgIHJldHVybiBsaXN0LnZpc2libGVJdGVtcztcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZ2xvc3NhcnktcGFuZWwvbm9kZV9tb2R1bGVzL2xpc3QuanMvc3JjL2ZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0KSB7XG4gIGxpc3Quc29ydEZ1bmN0aW9uID0gbGlzdC5zb3J0RnVuY3Rpb24gfHwgZnVuY3Rpb24oaXRlbUEsIGl0ZW1CLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5kZXNjID0gb3B0aW9ucy5vcmRlciA9PSBcImRlc2NcIiA/IHRydWUgOiBmYWxzZTsgLy8gTmF0dXJhbCBzb3J0IHVzZXMgdGhpcyBmb3JtYXRcbiAgICByZXR1cm4gbGlzdC51dGlscy5uYXR1cmFsU29ydChpdGVtQS52YWx1ZXMoKVtvcHRpb25zLnZhbHVlTmFtZV0sIGl0ZW1CLnZhbHVlcygpW29wdGlvbnMudmFsdWVOYW1lXSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGJ1dHRvbnMgPSB7XG4gICAgZWxzOiB1bmRlZmluZWQsXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYnV0dG9ucy5lbHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBsaXN0LnV0aWxzLmNsYXNzZXMoYnV0dG9ucy5lbHNbaV0pLnJlbW92ZSgnYXNjJyk7XG4gICAgICAgIGxpc3QudXRpbHMuY2xhc3NlcyhidXR0b25zLmVsc1tpXSkucmVtb3ZlKCdkZXNjJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRPcmRlcjogZnVuY3Rpb24oYnRuKSB7XG4gICAgICB2YXIgcHJlZGVmaW5lZE9yZGVyID0gbGlzdC51dGlscy5nZXRBdHRyaWJ1dGUoYnRuLCAnZGF0YS1vcmRlcicpO1xuICAgICAgaWYgKHByZWRlZmluZWRPcmRlciA9PSBcImFzY1wiIHx8IHByZWRlZmluZWRPcmRlciA9PSBcImRlc2NcIikge1xuICAgICAgICByZXR1cm4gcHJlZGVmaW5lZE9yZGVyO1xuICAgICAgfSBlbHNlIGlmIChsaXN0LnV0aWxzLmNsYXNzZXMoYnRuKS5oYXMoJ2Rlc2MnKSkge1xuICAgICAgICByZXR1cm4gXCJhc2NcIjtcbiAgICAgIH0gZWxzZSBpZiAobGlzdC51dGlscy5jbGFzc2VzKGJ0bikuaGFzKCdhc2MnKSkge1xuICAgICAgICByZXR1cm4gXCJkZXNjXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJhc2NcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEluU2Vuc2l0aXZlOiBmdW5jdGlvbihidG4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbnNlbnNpdGl2ZSA9IGxpc3QudXRpbHMuZ2V0QXR0cmlidXRlKGJ0biwgJ2RhdGEtaW5zZW5zaXRpdmUnKTtcbiAgICAgIGlmIChpbnNlbnNpdGl2ZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0T3JkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGJ1dHRvbnMuZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgdmFyIGJ0biA9IGJ1dHRvbnMuZWxzW2ldO1xuICAgICAgICBpZiAobGlzdC51dGlscy5nZXRBdHRyaWJ1dGUoYnRuLCAnZGF0YS1zb3J0JykgIT09IG9wdGlvbnMudmFsdWVOYW1lKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWRlZmluZWRPcmRlciA9IGxpc3QudXRpbHMuZ2V0QXR0cmlidXRlKGJ0biwgJ2RhdGEtb3JkZXInKTtcbiAgICAgICAgaWYgKHByZWRlZmluZWRPcmRlciA9PSBcImFzY1wiIHx8IHByZWRlZmluZWRPcmRlciA9PSBcImRlc2NcIikge1xuICAgICAgICAgIGlmIChwcmVkZWZpbmVkT3JkZXIgPT0gb3B0aW9ucy5vcmRlcikge1xuICAgICAgICAgICAgbGlzdC51dGlscy5jbGFzc2VzKGJ0bikuYWRkKG9wdGlvbnMub3JkZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0LnV0aWxzLmNsYXNzZXMoYnRuKS5hZGQob3B0aW9ucy5vcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBzb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgbGlzdC50cmlnZ2VyKCdzb3J0U3RhcnQnKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXS5jdXJyZW50VGFyZ2V0IHx8IGFyZ3VtZW50c1swXS5zcmNFbGVtZW50IHx8IHVuZGVmaW5lZDtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIG9wdGlvbnMudmFsdWVOYW1lID0gbGlzdC51dGlscy5nZXRBdHRyaWJ1dGUodGFyZ2V0LCAnZGF0YS1zb3J0Jyk7XG4gICAgICBidXR0b25zLmdldEluU2Vuc2l0aXZlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLm9yZGVyID0gYnV0dG9ucy5nZXRPcmRlcih0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdIHx8IG9wdGlvbnM7XG4gICAgICBvcHRpb25zLnZhbHVlTmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8IFwiYXNjXCI7XG4gICAgICBvcHRpb25zLmluc2Vuc2l0aXZlID0gKHR5cGVvZiBvcHRpb25zLmluc2Vuc2l0aXZlID09IFwidW5kZWZpbmVkXCIpID8gdHJ1ZSA6IG9wdGlvbnMuaW5zZW5zaXRpdmU7XG4gICAgfVxuICAgIGJ1dHRvbnMuY2xlYXIoKTtcbiAgICBidXR0b25zLnNldE9yZGVyKG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy5zb3J0RnVuY3Rpb24gPSBvcHRpb25zLnNvcnRGdW5jdGlvbiB8fCBsaXN0LnNvcnRGdW5jdGlvbjtcbiAgICBsaXN0Lml0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIG11bHQgPSAob3B0aW9ucy5vcmRlciA9PT0gJ2Rlc2MnKSA/IC0xIDogMTtcbiAgICAgIHJldHVybiAob3B0aW9ucy5zb3J0RnVuY3Rpb24oYSwgYiwgb3B0aW9ucykgKiBtdWx0KTtcbiAgICB9KTtcbiAgICBsaXN0LnVwZGF0ZSgpO1xuICAgIGxpc3QudHJpZ2dlcignc29ydENvbXBsZXRlJyk7XG4gIH07XG5cbiAgLy8gQWRkIGhhbmRsZXJzXG4gIGxpc3QuaGFuZGxlcnMuc29ydFN0YXJ0ID0gbGlzdC5oYW5kbGVycy5zb3J0U3RhcnQgfHwgW107XG4gIGxpc3QuaGFuZGxlcnMuc29ydENvbXBsZXRlID0gbGlzdC5oYW5kbGVycy5zb3J0Q29tcGxldGUgfHwgW107XG5cbiAgYnV0dG9ucy5lbHMgPSBsaXN0LnV0aWxzLmdldEJ5Q2xhc3MobGlzdC5saXN0Q29udGFpbmVyLCBsaXN0LnNvcnRDbGFzcyk7XG4gIGxpc3QudXRpbHMuZXZlbnRzLmJpbmQoYnV0dG9ucy5lbHMsICdjbGljaycsIHNvcnQpO1xuICBsaXN0Lm9uKCdzZWFyY2hTdGFydCcsIGJ1dHRvbnMuY2xlYXIpO1xuICBsaXN0Lm9uKCdmaWx0ZXJTdGFydCcsIGJ1dHRvbnMuY2xlYXIpO1xuXG4gIHJldHVybiBzb3J0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9nbG9zc2FyeS1wYW5lbC9ub2RlX21vZHVsZXMvbGlzdC5qcy9zcmMvc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBbe1widGVybVwiOlwiQWN0XCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgRmVkZXJhbCBFbGVjdGlvbiBDYW1wYWlnbiBBY3Qgb2YgMTk3MSwgYXMgYW1lbmRlZCAoPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL3N0YXR1dGVzL1xcXCI+NTIgVS5TLkMuIMKnwqczMDEwMS0zMDE0NjwvYT4pLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMTgvQ1VSUkVOVCMxMDAtMThcXFwiPjEwMC4xODwvYT4uIFByaW9yIHRvIFNlcHRlbWJlciAxLCAyMDE0LCB0aGUgQWN0IGFwcGVhcmVkIGluIFRpdGxlIDIgb2YgdGhlIFUuUy4gQ29kZS4gU29tZXRpbWVzIGFiYnJldmlhdGVkIEZFQ0EuXCJ9LHtcInRlcm1cIjpcIkFkbWluaXN0cmF0aXZlIGV4cGVuc2VcIixcImRlZmluaXRpb25cIjpcIkZvciBwYXJ0eSBjb21taXR0ZWVzLCByZW50LCB1dGlsaXRpZXMsIG9mZmljZSBlcXVpcG1lbnQsIG9mZmljZSBzdXBwbGllcywgcm91dGluZSBidWlsZGluZyBtYWludGVuYW5jZSBhbmQgb3RoZXIgb3BlcmF0aW5nIGNvc3RzIG5vdCBhdHRyaWJ1dGFibGUgdG8gYSBzcGVjaWZpYyBjYW5kaWRhdGUuXCJ9LHtcInRlcm1cIjpcIkFkdmFuY2VcIixcImRlZmluaXRpb25cIjpcIlRoZSBwYXltZW50IGJ5IGFuIGluZGl2aWR1YWwgZnJvbSBoaXMgb3IgaGVyIHBlcnNvbmFsIGZ1bmRzLCBpbmNsdWRpbmcgYSBwZXJzb25hbCBjcmVkaXQgY2FyZCwgZm9yIHRoZSBjb3N0cyBpbmN1cnJlZCBpbiBwcm92aWRpbmcgZ29vZHMgb3Igc2VydmljZXMgdG8sIG9yIG9idGFpbmluZyBnb29kcyBvciBzZXJ2aWNlcyB0aGF0IGFyZSB1c2VkIGJ5IG9yIG9uIGJlaGFsZiBvZiwgYSBjYW5kaWRhdGUgb3IgYSBwb2xpdGljYWwgY29tbWl0dGVlLiAgU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE2LTUvQ1VSUkVOVCMxMTYtNVxcXCI+MTEgQ0ZSIDExNi41PC9hPi5cIn0se1widGVybVwiOlwiQWR2aXNvcnkgb3BpbmlvbiAoQU8pXCIsXCJkZWZpbml0aW9uXCI6XCJBIGZvcm1hbCByZXNwb25zZSBmcm9tIHRoZSBDb21taXNzaW9uIHJlZ2FyZGluZyB0aGUgbGVnYWxpdHkgb2YgYSBzcGVjaWZpYyBhY3Rpdml0eSBwcm9wb3NlZCBpbiBhbiBhZHZpc29yeSBvcGluaW9uIHJlcXVlc3QgKEFPUikuIDExIENGUiBQYXJ0IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEyXFxcIj4xMTI8L2E+LlwifSx7XCJ0ZXJtXCI6XCJBZmZpbGlhdGVkIGNvbW1pdHRlZXNcIixcImRlZmluaXRpb25cIjpcIkNvbW1pdHRlZXMgYW5kIG9yZ2FuaXphdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCBvbmUgY29tbWl0dGVlIGZvciBwdXJwb3NlcyBvZiB0aGUgY29udHJpYnV0aW9uIGxpbWl0cy4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMy9DVVJSRU5UIzExMC0zXFxcIj4xMSBDRlIgMTEwLjMoYSkoMSk8L2E+LiBBZmZpbGlhdGVkIGNvbW1pdHRlZXMgaW5jbHVkZSAoMSkgQWxsIGNvbW1pdHRlZXMgZXN0YWJsaXNoZWQgb3IgYXV0aG9yaXplZCBieSBhIGNhbmRpZGF0ZSBhcyBwYXJ0IG9mIGhpcyBvciBoZXIgY2FtcGFpZ24gZm9yIGZlZGVyYWwgb3Igbm9uZmVkZXJhbCBvZmZpY2U7IGFuZCAoMikgQWxsIGNvbW1pdHRlZXMgZXN0YWJsaXNoZWQsIGZpbmFuY2VkLCBtYWludGFpbmVkIG9yIGNvbnRyb2xsZWQgYnkgdGhlIHNhbWUgcGVyc29uLCBncm91cCBvciBvcmdhbml6YXRpb24uIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC01L0NVUlJFTlQjMTAwLTUtZ1xcXCI+MTAwLjUoZykoMSkgYW5kICgyKTwvYT47IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTMvQ1VSUkVOVCMxMTAtM1xcXCI+MTEgQ0ZSIDExMC4zKGEpKDEpPC9hPi5cIn0se1widGVybVwiOlwiQWdlbnQgKG9mIGEgY2FuZGlkYXRlKVwiLFwiZGVmaW5pdGlvblwiOlwiQW4gYWdlbnQgb2YgYSBmZWRlcmFsIGNhbmRpZGF0ZSBvciBvZmZpY2Vob2xkZXIgaXMgYW55IHBlcnNvbiB3aG8gaGFzIGFjdHVhbCBhdXRob3JpdHksIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQsIHRvIGVuZ2FnZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBhY3Rpdml0aWVzIG9uIGJlaGFsZiBvZiB0aGUgY2FuZGlkYXRlIG9yIG9mZmljZWhvbGRlcjogPHVsIGNsYXNzPSdsaXN0LWJ1bGxldGVkJz4gPGxpPlRvIHNvbGljaXQsIHJlY2VpdmUsIGRpcmVjdCwgdHJhbnNmZXIgb3Igc3BlbmQgZnVuZHMgaW4gY29ubmVjdGlvbiB3aXRoIGFueSBlbGVjdGlvbi48L2xpPjxsaT5UbyByZXF1ZXN0IG9yIHN1Z2dlc3QgdGhhdCBhIGNvbW11bmljYXRpb24gYmUgY3JlYXRlZCwgcHJvZHVjZWQgb3IgZGlzdHJpYnV0ZWQ7IDwvbGk+PGxpPlRvIG1ha2Ugb3IgYXV0aG9yaXplIGEgY29tbXVuaWNhdGlvbiB0aGF0IG1lZXRzIG9uZSBvciBtb3JlIG9mIHRoZSDigJxjb250ZW50IHN0YW5kYXJkc+KAnSBmb3IgY29vcmRpbmF0aW9uOzwvbGk+PGxpPlRvIHJlcXVlc3Qgb3Igc3VnZ2VzdCB0aGF0IGFueSBvdGhlciBwZXJzb24gY3JlYXRlLCBwcm9kdWNlLCBvciBkaXN0cmlidXRlIGFueSBjb21tdW5pY2F0aW9uOzwvbGk+PGxpPlRvIGJlIG1hdGVyaWFsbHkgaW52b2x2ZWQgaW4gZGVjaXNpb25zIHJlZ2FyZGluZyB0aGUgY29udGVudCwgaW50ZW5kZWQgYXVkaWVuY2UsIG1lYW5zLCBtZWRpYSBvdXRsZXQsIHRpbWluZywgZnJlcXVlbmN5LCBzaXplLCBwcm9taW5lbmNlIG9yIGR1cmF0aW9uIG9mIGEgY29tbXVuaWNhdGlvbjs8L2xpPjxsaT5UbyBwcm92aWRlIG1hdGVyaWFsIG9yIGluZm9ybWF0aW9uIHRvIGFzc2lzdCBhbm90aGVyIHBlcnNvbiBpbiB0aGUgY3JlYXRpb24sIHByb2R1Y3Rpb24gb3IgZGlzdHJpYnV0aW9uIG9mIGFueSBjb21tdW5pY2F0aW9uOyBvcjwvbGk+XFxuPGxpPlRvIG1ha2Ugb3IgZGlyZWN0IGEgY29tbXVuaWNhdGlvbiB0aGF0IGlzIGNyZWF0ZWQsIHByb2R1Y2VkIG9yIGRpc3RyaWJ1dGVkIHdpdGggdGhlIHVzZSBvZiBtYXRlcmlhbCBvciBpbmZvcm1hdGlvbiBkZXJpdmVkIGZyb20gYSBzdWJzdGFudGlhbCBkaXNjdXNzaW9uIGFib3V0IHRoZSBjb21tdW5pY2F0aW9uIHdpdGggYSBkaWZmZXJlbnQgY2FuZGlkYXRlOzwvbGk+PC91bD4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTA5LTMvQ1VSUkVOVCMxMDktMy1iXFxcIj4xMDkuMyhiKTwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMzAwLTIvQ1VSUkVOVCMzMDAtMi1iLTNcXFwiPjMwMC4yKGIpKDMpPC9hPi5cIn0se1widGVybVwiOlwiQWdlbnQgKG9mIGEgcGFydHkpXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBhZ2VudCBpcyBhbnkgcGVyc29uIHdobyBoYXMgYWN0dWFsIGF1dGhvcml0eSwgZWl0aGVyIGV4cHJlc3NlZCBvciBpbXBsaWVkLCB0byBlbmdhZ2UgaW4gY2VydGFpbiBhY3Rpdml0aWVzIG9uIGJlaGFsZiBvZiB0aGUgY29tbWl0dGVlLiBJbiB0aGUgY2FzZSBvZiBzdGF0ZSwgZGlzdHJpY3QgYW5kIGxvY2FsIHBhcnR5IGNvbW1pdHRlZXMsIHRoZXNlIGFjdGl2aXRpZXMgYXJlOjx1bCAgY2xhc3M9XFxcImxpc3QtYnVsbGV0ZWRcXFwiPjxsaT5FeHBlbmRpbmcgb3IgZGlzYnVyc2luZyBhbnkgZnVuZHMgZm9yIGZlZGVyYWwgZWxlY3Rpb24gYWN0aXZpdHk7IDwvbGk+PGxpPlRyYW5zZmVycmluZyBvciBhY2NlcHRpbmcgdHJhbnNmZXJzIG9mIGZ1bmRzIGZvciBmZWRlcmFsIGVsZWN0aW9uIGFjdGl2aXR5OzwvbGk+IDxsaT5FbmdhZ2luZyBpbiBqb2ludCBmdW5kcmFpc2luZyBhY3Rpdml0eSBpZiBhbnkgcGFydCBvZiB0aGUgZnVuZHMgYXJlIHRvIGJlIHVzZWQgZm9yIGZlZGVyYWwgZWxlY3Rpb24gYWN0aXZpdHk7IG9yIDwvbGk+PGxpPlNvbGljaXRpbmcgYW55IGZ1bmRzIGZvciwgb3IgbWFraW5nIG9yIGRpcmVjdGluZyBhbnkgZG9uYXRpb25zIHRvLCBhbnkgdGF4LWV4ZW1wdCA1MDEoYykgb3JnYW5pemF0aW9uIG9yIDUyNyBvcmdhbml6YXRpb24gdGhhdCBpcyBub3QgYWxzbyBhIHBvbGl0aWNhbCBjb21taXR0ZWUsIGEgcGFydHkgY29tbWl0dGVlIG9yIGFuIGF1dGhvcml6ZWQgY2FtcGFpZ24gY29tbWl0dGVlLiA8L2xpPjExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzMwMC0yL0NVUlJFTlQjMzAwLTItYi0yXFxcIj4zMDAuMihiKSgyKTwvYT4uPC91bD5JbiB0aGUgY2FzZSBvZiB0aGUgbmF0aW9uYWwgcGFydHkgY29tbWl0dGVlcywgdGhlc2UgYWN0aXZpdGllcyBhcmU6XFxuPHVsIGNsYXNzPVxcXCJsaXN0LWJ1bGxldGVkXFxcIj48bGk+U29saWNpdGluZywgZGlyZWN0aW5nIG9yIHJlY2VpdmluZyBhIGNvbnRyaWJ1dGlvbiwgZG9uYXRpb24gb3IgdHJhbnNmZXIgb2YgZnVuZHM7IG9yPC9saT48bGk+U29saWNpdGluZyBhbnkgZnVuZHMgZm9yLCBvciBtYWtpbmcgb3IgZGlyZWN0aW5nIGRvbmF0aW9ucyB0bywgYW55IHRheC1leGVtcHQgNTAxKGMpIG9yZ2FuaXphdGlvbiBvciA1Mjcgb3JnYW5pemF0aW9uIHRoYXQgaXMgbm90IGFsc28gYSBwb2xpdGljYWwgY29tbWl0dGVlLCBhIHBhcnR5IGNvbW1pdHRlZSBvciBhbiBhdXRob3JpemVkIGNhbXBhaWduIGNvbW1pdHRlZS48L2xpPiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMi9DVVJSRU5UIzMwMC0yLWItMVxcXCI+MzAwLjIoYikoMSk8L2E+LjwvdWw+IEluIHRoZSBjYXNlIG9mIGNvbW11bmljYXRpb25zLCBmb3IgYWxsIHBhcnR5IGNvbW1pdHRlZXMsIHRoZSBhY3Rpdml0aWVzIGluY2x1ZGU6IDx1bCBjbGFzcz06XFxcImxpc3QtYnVsbGV0ZWRcXFwiPjxsaT5SZXF1ZXN0aW5nIG9yIHN1Z2dlc3RpbmcgdGhhdCBhIGNvbW11bmljYXRpb24gYmUgY3JlYXRlZCwgcHJvZHVjZWQgb3IgZGlzdHJpYnV0ZWQ7PC9saT48bGk+Q3JlYXRpbmcsIHByb2R1Y2luZyBvciBkaXN0cmlidXRpbmcgYW55IGNvbW11bmljYXRpb24gYXQgdGhlIHJlcXVlc3Qgb2YgYSBjYW5kaWRhdGU7IG9yPC9saT48bGk+QmVpbmcgbWF0ZXJpYWxseSBpbnZvbHZlZCBpbiB0aGUgY29udGVudCBvciBkaXN0cmlidXRpb24gb2YgYSBjb21tdW5pY2F0aW9uLjwvbGk+MTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTA5LTMvQ1VSUkVOVCMxMDktM1xcXCI+MTA5LjMoYSk8L2E+LjwvdWw+XCJ9LHtcInRlcm1cIjpcIkFsbG9jYXRpb24gYWNjb3VudFwiLFwiZGVmaW5pdGlvblwiOlwiQSBzZXBhcmF0ZSBmZWRlcmFsIGFjY291bnQgaW50byB3aGljaCBmdW5kcyBmcm9tIGVpdGhlciBhIGNvbW1pdHRlZeKAmXMgZmVkZXJhbCBhbmQgbm9uZmVkZXJhbCBhY2NvdW50cywgb3IgKGZvciBwYXJ0eSBjb21taXR0ZWVzKSBmcm9tIGl0cyBmZWRlcmFsIGFuZCBMZXZpbiBhY2NvdW50cywgYXJlIGRlcG9zaXRlZCBzb2xlbHkgdG8gcGF5IGV4cGVuc2VzIHRoYXQgbXVzdCBiZSBhbGxvY2F0ZWQuIChBIHBhcnR5IGNvbW1pdHRlZSBtdXN0IGhhdmUgc2VwYXJhdGUgYWxsb2NhdGlvbiBhY2NvdW50cyBmb3IgaXRzIGZlZGVyYWwvbm9uZmVkZXJhbCBhbGxvY2F0aW9uIGFuZCBmb3IgaXRzIGZlZGVyYWwvTGV2aW4gYWxsb2NhdGlvbikuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwNi03L0NVUlJFTlQjMTA2LTdcXFwiPjEwNi43KGYpPC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMzMvQ1VSUkVOVCMzMDAtMzMtZFxcXCI+MzAwLjMzKGQpPC9hPi5cIn0se1widGVybVwiOlwiQXV0aG9yaXplZCBjb21taXR0ZWVcIixcImRlZmluaXRpb25cIjpcIkEgcG9saXRpY2FsIGNvbW1pdHRlZSB0aGF0IGhhcyBiZWVuIGF1dGhvcml6ZWQgYnkgYSBjYW5kaWRhdGUgdG8gYWNjZXB0IGNvbnRyaWJ1dGlvbnMgb3IgbWFrZSBleHBlbmRpdHVyZXMgb24gaGlzIG9yIGhlciBiZWhhbGYsIG9yIG9uZSB0aGF0IGFjY2VwdHMgY29udHJpYnV0aW9ucyBvciBtYWtlcyBleHBlbmRpdHVyZXMgb24gYmVoYWxmIG9mIGEgY2FuZGlkYXRlIGFuZCBoYXMgbm90IGJlZW4gZGlzYXZvd2VkIGJ5IHRoZSBjYW5kaWRhdGUuXCJ9LHtcInRlcm1cIjpcIkJ1bmRsZWQgY29udHJpYnV0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbnRyaWJ1dGlvbiBmb3J3YXJkZWQgdG8gYSByZXBvcnRpbmcgY29tbWl0dGVlIGJ5IGEgbG9iYnlpc3QvcmVnaXN0cmFudCBvciBsb2JieWlzdC9yZWdpc3RyYW50IFBBQywgb3IgcmVjZWl2ZWQgYnkgYSByZXBvcnRpbmcgY29tbWl0dGVlIGFuZCBjcmVkaXRlZCB0byBhIGxvYmJ5aXN0L3JlZ2lzdHJhbnQgb3IgbG9iYnlpc3QvcmVnaXN0cmFudCBQQUMuIFNlZSAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDQtMjIvQ1VSUkVOVCMxMDQtMjItYS02XFxcIj4xMDQuMjIoYSkoNik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJDYW1wYWlnbiB0cmF2ZWxlclwiLFwiZGVmaW5pdGlvblwiOlwiQW55IGNhbmRpZGF0ZSB0cmF2ZWxpbmcgaW4gY29ubmVjdGlvbiB3aXRoIGFuIGVsZWN0aW9uIGZvciBmZWRlcmFsIG9mZmljZSwgb3IgYW55IGluZGl2aWR1YWwgdHJhdmVsaW5nIGluIGNvbm5lY3Rpb24gd2l0aCBhbiBlbGVjdGlvbiBmb3IgZmVkZXJhbCBvZmZpY2Ugb24gYmVoYWxmIG9mIGEgY2FuZGlkYXRlIG9yIHBvbGl0aWNhbCBjb21taXR0ZWU7IG9yIGFueSBtZW1iZXIgb2YgdGhlIG5ld3MgbWVkaWEgdHJhdmVsaW5nIHdpdGggYSBjYW5kaWRhdGUuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC05My9DVVJSRU5UIzEwMC05My1hLTNcXFwiPjEwMC45MyhhKSgzKShpKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkNhbmRpZGF0ZVwiLFwiZGVmaW5pdGlvblwiOlwiQW4gaW5kaXZpZHVhbCBzZWVraW5nIG5vbWluYXRpb24gZm9yIGVsZWN0aW9uLCBvciByZWVsZWN0aW9uLCB0byBhIGZlZGVyYWwgb2ZmaWNlIGJlY29tZXMgYSBjYW5kaWRhdGUgd2hlbiBoZSBvciBzaGUgKG9yIHBlcnNvbnMgd29ya2luZyBvbiBoaXMgb3IgaGVyIGJlaGFsZikgcmVjZWl2ZXMgY29udHJpYnV0aW9ucyBvciBtYWtlcyBleHBlbmRpdHVyZXMgdGhhdCBleGNlZWQgJDUsMDAwLlwifSx7XCJ0ZXJtXCI6XCJDYW5kaWRhdGUgSURcIixcImRlZmluaXRpb25cIjpcIkEgdW5pcXVlIGlkZW50aWZpZXIgYXNzaWduZWQgdG8gZWFjaCBjYW5kaWRhdGUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBGRUMuIFRoZSBpbml0aWFsIGNoYXJhY3RlciBpbmRpY2F0ZXMgdGhlIG9mZmljZSBzb3VnaHQuIChIKW91c2UsIChTKWVuYXRlLCAoUClyZXNpZGVudC4gSWYgYSBwZXJzb24gcnVucyBmb3Igc2V2ZXJhbCBvZmZpY2VzLCB0aGV5IHdpbGwgaGF2ZSBzZXBhcmF0ZSBJRHMgZm9yIGVhY2ggb2ZmaWNlLlwifSx7XCJ0ZXJtXCI6XCJDYXNoLW9uLWhhbmRcIixcImRlZmluaXRpb25cIjpcIkNhc2ggb24gaGFuZCBpbmNsdWRlcyBmdW5kcyBoZWxkIGluIGNoZWNraW5nIGFuZCBzYXZpbmdzIGFjY291bnRzLCBjZXJ0aWZpY2F0ZXMgb2YgZGVwb3NpdCwgcGV0dHkgY2FzaCBmdW5kcywgdHJhdmVsZXLigJlzIGNoZWNrcywgdHJlYXN1cnkgYmlsbHMgYW5kIG90aGVyIGludmVzdG1lbnRzIHZhbHVlZCBhdCBjb3N0LiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwNC0zL0NVUlJFTlQjMTA0LTMtYS0xXFxcIj4xMSBDRlIgMTA0LjMoYSkoMSk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJDRlJcIixcImRlZmluaXRpb25cIjpcIkNvZGUgb2YgRmVkZXJhbCBSZWd1bGF0aW9ucy4gVGhlIGFubnVhbCBjb2xsZWN0aW9uIG9mIGV4ZWN1dGl2ZS1hZ2VuY3kgcmVndWxhdGlvbnMgcHVibGlzaGVkIGluIHRoZSBkYWlseSBGZWRlcmFsIFJlZ2lzdGVyLCBjb21iaW5lZCB3aXRoIHByZXZpb3VzbHkgaXNzdWVkIHJlZ3VsYXRpb25zIHRoYXQgYXJlIHN0aWxsIGluIGVmZmVjdC4gVGhlIHNlY3Rpb25zIG9mIHRoZSBDRlIgY29udGFpbmluZyBmZWRlcmFsIGNhbXBhaWduIGZpbmFuY2UgcmVndWxhdGlvbnMgbWF5IGJlIGZvdW5kIGluIFRpdGxlIDExIGFuZCBhcmUgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy9cXFwiPmF2YWlsYWJsZSBvbiB0aGUgRkVD4oCZcyB3ZWJzaXRlPC9hPiBvciBhcyBhIGZyZWUgcHVibGljYXRpb24gZnJvbSB0aGUgRkVDLlwifSx7XCJ0ZXJtXCI6XCJDbGVhcmx5IGlkZW50aWZpZWQgY2FuZGlkYXRlXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNhbmRpZGF0ZSBpcyBjbGVhcmx5IGlkZW50aWZpZWQgd2hlbiBoaXMgb3IgaGVyIG5hbWUsIG5pY2tuYW1lLCBwaG90b2dyYXBoIG9yIGRyYXdpbmcgYXBwZWFycywgb3Igd2hlbiBoaXMgb3IgaGVyIGlkZW50aXR5IGlzIG90aGVyd2lzZSBhcHBhcmVudCB0aHJvdWdoIGFuIHVuYW1iaWd1b3VzIHJlZmVyZW5jZSBzdWNoIGFzIOKAnHRoZSBQcmVzaWRlbnQs4oCdIOKAnHlvdXIgQ29uZ3Jlc3NtYW4s4oCdIG9yIOKAnHRoZSBpbmN1bWJlbnQs4oCdIG9yIHRocm91Z2ggYW4gdW5hbWJpZ3VvdXMgcmVmZXJlbmNlIHRvIGhpcyBvciBoZXIgc3RhdHVzIGFzIGEgY2FuZGlkYXRlIHN1Y2ggYXMg4oCcdGhlIERlbW9jcmF0aWMgcHJlc2lkZW50aWFsIG5vbWluZWXigJ0gb3Ig4oCcdGhlIFJlcHVibGljYW4gY2FuZGlkYXRlIGZvciBTZW5hdGUgaW4gdGhlIFN0YXRlIG9mIEdlb3JnaWEu4oCdIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0xNy9DVVJSRU5UIzEwMC0xN1xcXCI+MTAwLjE3PC9hPi5cIn0se1widGVybVwiOlwiQ29tbWVyY2lhbCB2ZW5kb3JcIixcImRlZmluaXRpb25cIjpcIkFueSBwZXJzb24gcHJvdmlkaW5nIGdvb2RzIG9yIHNlcnZpY2VzIHRvIGEgY2FuZGlkYXRlIG9yIHBvbGl0aWNhbCBjb21taXR0ZWUgd2hvc2UgdXN1YWwgYW5kIG5vcm1hbCBidXNpbmVzcyBpbnZvbHZlcyB0aGUgc2FsZSwgcmVudGFsLCBsZWFzZSBvciBwcm92aXNpb24gb2YgdGhvc2UgZ29vZHMgb3Igc2VydmljZXMuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNi0xL0NVUlJFTlQjMTE2LTEtY1xcXCI+MTE2LjEoYyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJDb21taXR0ZWUgdHlwZVwiLFwiZGVmaW5pdGlvblwiOlwiQSBkZWZpbml0aW9uIHRoYXQgY2F0ZWdvcml6ZXMgZ3JvdXBzIG9yZ2FuaXplZCB0byByZWNlaXZlIGFuZCBzcGVuZCBtb25leSBpbiBmZWRlcmFsIGVsZWN0aW9ucy4gVGhlIGJhc2ljIGNvbW1pdHRlZSB0eXBlcyBhcmUgYXV0aG9yaXplZCBjb21taXR0ZWVzLCBwb2xpdGljYWwgcGFydHkgY29tbWl0dGVlcywgc2VwYXJhdGUgc2VncmVnYXRlZCBmdW5kcyAoU1NGcykgYW5kIG5vbmNvbm5lY3RlZCBjb21taXR0ZWVzLlwifSx7XCJ0ZXJtXCI6XCJDb21tdW5pY2F0aW9ucyBmaWxlcnNcIixcImRlZmluaXRpb25cIjpcIkZvcm0gNSwgRm9ybSA3IGFuZCBGb3JtIDkgZmlsZXJzLCB3aG9zZSBhY3Rpdml0eSBpbmNsdWRlczogPHVsPjxsaT5Db250cmlidXRpb25zIHJlcG9ydGVkIGJ5IHBlcnNvbnMgb3RoZXIgdGhhbiBwb2xpdGljYWwgY29tbWl0dGVlczwvbGk+PGxpPkluZGVwZW5kZW50IGV4cGVuZGl0dXJlcyByZXBvcnRlZCBieSBwZXJzb25zIG90aGVyIHRoYW4gcG9saXRpY2FsIGNvbW1pdHRlZXM8L2xpPjxsaT5Db21tdW5pY2F0aW9uIGNvc3RzIHJlcG9ydGVkIGJ5IGNvcnBvcmF0aW9ucyBhbmQgbWVtYmVyc2hpcCBvcmdhbml6YXRpb25zPC9saT48bGk+RWxlY3Rpb25lZXJpbmcgY29tbXVuaWNhdGlvbnM8L2xpPjwvdWw+XCJ9LHtcInRlcm1cIjpcIkNvbmR1aXQgb3IgaW50ZXJtZWRpYXJ5XCIsXCJkZWZpbml0aW9uXCI6XCJBbnkgcGVyc29uIHdobyByZWNlaXZlcyBhbmQgZm9yd2FyZHMgYW4gZWFybWFya2VkIGNvbnRyaWJ1dGlvbiB0byBhIGNhbmRpZGF0ZSBvciBhIGNhbmRpZGF0ZeKAmXMgYXV0aG9yaXplZCBjb21taXR0ZWUuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMC02L0NVUlJFTlQjMTEwLTYtYi0yXFxcIj4xMTAuNihiKSgyKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkNvbm5lY3RlZCBvcmdhbml6YXRpb25cIixcImRlZmluaXRpb25cIjpcIkFuIG9yZ2FuaXphdGlvbiB0aGF0IHVzZXMgaXRzIHRyZWFzdXJ5IGZ1bmRzIHRvIGVzdGFibGlzaCwgYWRtaW5pc3RlciBvciBzb2xpY2l0IGNvbnRyaWJ1dGlvbnMgdG8gYSBzZXBhcmF0ZSBzZWdyZWdhdGVkIGZ1bmQuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC02L0NVUlJFTlQjMTAwLTZcXFwiPjEwMC42KGEpPC9hPi5cIn0se1widGVybVwiOlwiQ29udHJpYnV0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBIGdpZnQsIHN1YnNjcmlwdGlvbiwgbG9hbiwgYWR2YW5jZSBvciBkZXBvc2l0IG9mIG1vbmV5IG9yIGFueXRoaW5nIG9mIHZhbHVlIGdpdmVuIHRvIGluZmx1ZW5jZSBhIGZlZGVyYWwgZWxlY3Rpb247IG9yIHRoZSBwYXltZW50IGJ5IGFueSBwZXJzb24gb2YgY29tcGVuc2F0aW9uIGZvciB0aGUgcGVyc29uYWwgc2VydmljZXMgb2YgYW5vdGhlciBwZXJzb24gaWYgdGhvc2Ugc2VydmljZXMgYXJlIHJlbmRlcmVkIHdpdGhvdXQgY2hhcmdlIHRvIGEgcG9saXRpY2FsIGNvbW1pdHRlZSBmb3IgYW55IHB1cnBvc2UuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC01Mi9DVVJSRU5UIzEwMC01MlxcXCI+MTAwLjUyKGEpPC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtNTQvQ1VSUkVOVCMxMDAtNTRcXFwiPjEwMC41NDwvYT4uXCJ9LHtcInRlcm1cIjpcIkNvbnRyaWJ1dGlvbiBpbiB0aGUgbmFtZSBvZiBhbm90aGVyXCIsXCJkZWZpbml0aW9uXCI6XCJHaXZpbmcgbW9uZXkgb3IgYW55dGhpbmcgb2YgdmFsdWUsIGFsbCBvciBwYXJ0IG9mIHdoaWNoIHdhcyBwcm92aWRlZCB0byB0aGUgY29udHJpYnV0b3IgYnkgYW5vdGhlciBwZXJzb24gKHRoZSB0cnVlIGNvbnRyaWJ1dG9yKSB3aXRob3V0IGRpc2Nsb3NpbmcgdGhlIHNvdXJjZSBvZiB0aGUgbW9uZXkgb3IgdGhlIHRoaW5nIG9mIHZhbHVlIHRvIHRoZSByZWNpcGllbnQgY2FuZGlkYXRlIG9yIGNvbW1pdHRlZSBhdCB0aGUgdGltZSB0aGUgY29udHJpYnV0aW9uIGlzIG1hZGU7IG9yIG1ha2luZyBhIGNvbnRyaWJ1dGlvbiBvZiBtb25leSBvciBhbnl0aGluZyBvZiB2YWx1ZSBhbmQgYXR0cmlidXRpbmcgYXMgdGhlIHNvdXJjZSBhbm90aGVyIHBlcnNvbiB3aGVuIGluIGZhY3QgdGhlIGNvbnRyaWJ1dG9yIGlzIHRoZSBzb3VyY2UuIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTQvQ1VSUkVOVCMxMTAtNC1iXFxcIj4xMSBDRlIgMTEwLjQoYik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJDb29yZGluYXRlZFwiLFwiZGVmaW5pdGlvblwiOlwiTWFkZSBpbiBjb29wZXJhdGlvbiwgY29uc3VsdGF0aW9uIG9yIGNvbmNlcnQgd2l0aCwgb3IgYXQgdGhlIHJlcXVlc3Qgb3Igc3VnZ2VzdGlvbiBvZiwgYSBjYW5kaWRhdGUsIGEgY2FuZGlkYXRl4oCZcyBhdXRob3JpemVkIGNvbW1pdHRlZSBvciB0aGVpciBhZ2VudHMsIG9yIGEgcG9saXRpY2FsIHBhcnR5IGNvbW1pdHRlZSBvciBpdHMgYWdlbnRzLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDktMjAvQ1VSUkVOVCMxMDktMjBcXFwiPjEwOS4yMChhKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkNvb3JkaW5hdGVkIGNvbW11bmljYXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgY29tbXVuaWNhdGlvbiB0aGF0IHNhdGlzZmllcyBhIHRocmVlLXByb25nZWQgdGVzdDogPG9sIGNsYXNzPSdsaXN0LWJ1bGxldGVkJz4+PGxpPlRoZSBjb21tdW5pY2F0aW9uIG11c3QgYmUgcGFpZCBmb3IgYnkgYSBwZXJzb24gb3RoZXIgdGhhbiBhIGZlZGVyYWwgY2FuZGlkYXRlLCBhdXRob3JpemVkIGNvbW1pdHRlZSwgb3IgYSBwb2xpdGljYWwgcGFydHkgY29tbWl0dGVlLCBvciBhbnkgYWdlbnRzIG9mIHRoZSBhZm9yZW1lbnRpb25lZCBlbnRpdGllcyB3aXRoIHdob20gdGhlIGNvbW11bmljYXRpb24gaXMgY29vcmRpbmF0ZWQuPC9saT48bGk+T25lIG9yIG1vcmUgb2YgdGhlIGZpdmUgY29udGVudCBzdGFuZGFyZHMgc2V0IGZvcnRoIGluIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTA5LTIxL0NVUlJFTlQjMTA5LTIxLWNcXFwiPjExIENGUiAxMDkuMjEoYyk8L2E+IG11c3QgYmUgc2F0aXNmaWVkOyBhbmQ8L2xpPjxsaT5PbmUgb3IgbW9yZSBvZiB0aGUgZml2ZSBjb25kdWN0IHN0YW5kYXJkcyBzZXQgZm9ydGggaW4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDktMjEvQ1VSUkVOVCMxMDktMjEtZFxcXCI+MTEgQ0ZSIDEwOS4yMShkKTwvYT4gbXVzdCBiZSBzYXRpc2ZpZWQuPC9saT48L29sPkEgcGF5bWVudCBmb3IgYSBjb21tdW5pY2F0aW9uIHNhdGlzZnlpbmcgYWxsIHRocmVlIHByb25ncyBpcyBhbiBpbi1raW5kIGNvbnRyaWJ1dGlvbiB0byB0aGUgY2FuZGlkYXRlIG9yIHBvbGl0aWNhbCBwYXJ0eSBjb21taXR0ZWUgd2l0aCB3aGljaCBpdCB3YXMgY29vcmRpbmF0ZWQuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwOS0yMS9DVVJSRU5UIzEwOS0yMVxcXCI+MTA5LjIxPC9hPi5cIn0se1widGVybVwiOlwiQ29vcmRpbmF0ZWQgcGFydHkgZXhwZW5kaXR1cmVcIixcImRlZmluaXRpb25cIjpcIkEgc3BlY2lhbCB0eXBlIG9mIGV4cGVuZGl0dXJlIHRoYXQgY2FuIGJlIG1hZGUgb25seSBieSBhIG5hdGlvbmFsIG9yIHN0YXRlIHBvbGl0aWNhbCBwYXJ0eSBjb21taXR0ZWUgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBnZW5lcmFsIGVsZWN0aW9uIG9mIGEgY2FuZGlkYXRlLiBUaGVzZSBleHBlbmRpdHVyZXMgYXJlIHN1YmplY3QgdG8gYSBzZXBhcmF0ZSBzZXQgb2YgbGltaXRzIGFuZCBkbyBub3QgY291bnQgYWdhaW5zdCB0aGUgcGFydHnigJlzIG5vcm1hbCBjb250cmlidXRpb24gbGltaXRzIHdpdGggcmVzcGVjdCB0byBlYWNoIGNhbmRpZGF0ZS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTA5LTMwL0NVUlJFTlQjMTA5LTMwXFxcIj4xMDkuMzA8L2E+IGFuZCA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwOS0zMi9DVVJSRU5UIzEwOS0zMlxcXCI+MTA5LjMyLTM3PC9hPi5cIn0se1widGVybVwiOlwiQ29ycG9yYXRpb25cIixcImRlZmluaXRpb25cIjpcIkFueSBzZXBhcmF0ZWx5IGluY29ycG9yYXRlZCBlbnRpdHkgKG90aGVyIHRoYW4gYSBwb2xpdGljYWwgY29tbWl0dGVlIHRoYXQgaGFzIGluY29ycG9yYXRlZCBmb3IgbGlhYmlsaXR5IHB1cnBvc2VzIG9ubHkpLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMTM0L0NVUlJFTlQjMTAwLTEzNC1sXFxcIj4xMDAuMTM0KGwpPC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTQtMTIvQ1VSUkVOVCMxMTQtMTJcXFwiPjExNC4xMihhKTwvYT4uIFRoZSB0ZXJtIGNvcnBvcmF0aW9uIGNvdmVycyBib3RoIGZvci1wcm9maXQgYW5kIG5vbnByb2ZpdCBjb3Jwb3JhdGlvbnMgYW5kIGluY2x1ZGVzIG5vbnN0b2NrIGNvcnBvcmF0aW9ucywgaW5jb3Jwb3JhdGVkIG1lbWJlcnNoaXAgb3JnYW5pemF0aW9ucywgaW5jb3Jwb3JhdGVkIGNvb3BlcmF0aXZlcywgaW5jb3Jwb3JhdGVkIHRyYWRlIGFzc29jaWF0aW9ucywgcHJvZmVzc2lvbmFsIGNvcnBvcmF0aW9ucyBhbmQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgbGltaXRlZCBsaWFiaWxpdHkgY29tcGFuaWVzLlwifSx7XCJ0ZXJtXCI6XCJDdXN0b2RpYW4gb2YgUmVjb3Jkc1wiLFwiZGVmaW5pdGlvblwiOlwiVGhlIGluZGl2aWR1YWwgb3IgZW50aXR5IGhvbGRpbmcgcG9zc2Vzc2lvbiBvZiBhIHBvbGl0aWNhbCBjb21taXR0ZWXigJlzIGJvb2tzIGFuZCBhY2NvdW50cy5UaGUgQ3VzdG9kaWFuIG9mIFJlY29yZHMgaXMgbGlzdGVkIG9uIHRoZSBjb21taXR0ZWXigJlzIFN0YXRlbWVudCBvZiBPcmdhbml6YXRpb24uIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMi0yL0NVUlJFTlQjMTAyLTItYS0xLWlpXFxcIj4xMDIuMihhKSgxKShpaWkpPC9hPi5cIn0se1widGVybVwiOlwiRGF0ZSBtYWRlXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgZGF0ZSB0aGUgY29udHJpYnV0b3IgcmVsaW5xdWlzaGVzIGNvbnRyb2wgb3ZlciBhIGNvbnRyaWJ1dGlvbi4gQSBjb250cmlidXRpb24gdGhhdCBpcyBtYWlsZWQgaXMgY29uc2lkZXJlZCBtYWRlIG9uIHRoZSBkYXRlIG9mIHRoZSBwb3N0bWFyay4gSW4gdGhlIGNhc2Ugb2YgYW4gaW4ta2luZCBjb250cmlidXRpb24sIGEgY29udHJpYnV0aW9uIGlzIG1hZGUgb24gdGhlIGRhdGUgdGhlIGdvb2RzIG9yIHNlcnZpY2VzIGFyZSBwcm92aWRlZCBieSB0aGUgY29udHJpYnV0b3IuIFRoaXMgZGF0ZSBkZXRlcm1pbmVzIHRoZSBlbGVjdGlvbiBvciBjYWxlbmRhciB5ZWFyIGxpbWl0IGFnYWluc3Qgd2hpY2ggYSBjb250cmlidXRpb24gY291bnRzLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMS9DVVJSRU5UIzExMC0xLWItNlxcXCI+MTEwLjEoYikoNik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJEYXRlIHJlY2VpdmVkXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgZGF0ZSBhIGNvbW1pdHRlZSAob3IgYSBwZXJzb24gYWN0aW5nIG9uIHRoZSBjb21taXR0ZWXigJlzIGJlaGFsZikgdGFrZXMgcG9zc2Vzc2lvbiBvZiB0aGUgY29udHJpYnV0aW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDItOC9DVVJSRU5UIzEwMi04XFxcIj4xMDIuOChhKTwvYT4uIFRoaXMgZGF0ZSBpcyB1c2VkIGZvciBGRUMgcmVwb3J0aW5nLlwifSx7XCJ0ZXJtXCI6XCJEZWJ0XCIsXCJkZWZpbml0aW9uXCI6XCJEZWJ0cyBpbmNsdWRlIHVucGFpZCBiaWxscy4gRkVDIHJlcG9ydHMgc2hvdyB0aGUgYW1vdW50IG9mIHJlcG9ydGFibGUgZGVidCBhIGNvbW1pdHRlZSBvd2VzIHRvIG90aGVyIGVudGl0aWVzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGluZyBwZXJpb2QuXCJ9LHtcInRlcm1cIjpcIkRlbGVnYXRlXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBpbmRpdmlkdWFsIHdobyBpcyBvciBzZWVrcyB0byBiZWNvbWUgYSBkZWxlZ2F0ZSB0byBhIG5hdGlvbmFsIG5vbWluYXRpbmcgY29udmVudGlvbiBvciB0byBhIHN0YXRlLCBkaXN0cmljdCBvciBsb2NhbCBjb252ZW50aW9uLCBjYXVjdXMgb3IgcHJpbWFyeSBoZWxkIHRvIHNlbGVjdCBkZWxlZ2F0ZXMgdG8gYSBuYXRpb25hbCBub21pbmF0aW5nIGNvbnZlbnRpb24uIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMC0xNC9DVVJSRU5UIzExMC0xNC1iXFxcIj4xMTAuMTQoYikoMSk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJEZWxlZ2F0ZSBjb21taXR0ZWVcIixcImRlZmluaXRpb25cIjpcIkEgZ3JvdXAgb3JnYW5pemVkIGZvciB0aGUgcHVycG9zZSBvZiBpbmZsdWVuY2luZyB0aGUgc2VsZWN0aW9uIG9mIG9uZSBvciBtb3JlIGRlbGVnYXRlcy4gVGhlIHRlcm0gaW5jbHVkZXMgYSBncm91cCBvZiBkZWxlZ2F0ZXMsIGEgZ3JvdXAgb2YgaW5kaXZpZHVhbHMgc2Vla2luZyB0byBiZWNvbWUgZGVsZWdhdGVzIGFuZCBhIGdyb3VwIG9mIGluZGl2aWR1YWxzIHN1cHBvcnRpbmcgZGVsZWdhdGVzLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMTQvQ1VSUkVOVCMxMTAtMTQtYi0yXFxcIj4xMTAuMTQoYikoMik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJEZXNpZ25hdGVkL2Rlc2lnbmF0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbnRyaWJ1dGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIGRlc2lnbmF0ZWQgaW4gd3JpdGluZyBmb3IgYSBwYXJ0aWN1bGFyIGVsZWN0aW9uIGlmIDx1bCBjbGFzcz0nbGlzdC1idWxsZXRlZCc+PGxpPlRoZSBjb250cmlidXRpb24gaXMgbWFkZSBieSBjaGVjaywgbW9uZXkgb3JkZXIsIG9yIG90aGVyIG5lZ290aWFibGUgaW5zdHJ1bWVudCB3aGljaCBjbGVhcmx5IGluZGljYXRlcyB0aGUgcGFydGljdWxhciBlbGVjdGlvbiB3aXRoIHJlc3BlY3QgdG8gd2hpY2ggdGhlIGNvbnRyaWJ1dGlvbiBpcyBtYWRlOzwvbGk+PGxpPlRoZSBjb250cmlidXRpb24gaXMgYWNjb21wYW5pZWQgYnkgYSB3cml0aW5nLCBzaWduZWQgYnkgdGhlIGNvbnRyaWJ1dG9yLCB3aGljaCBjbGVhcmx5IGluZGljYXRlcyB0aGUgcGFydGljdWxhciBlbGVjdGlvbiB3aXRoIHJlc3BlY3QgdG8gd2hpY2ggdGhlIGNvbnRyaWJ1dGlvbiBpcyBtYWRlOyBvcjwvbGk+VGhlIGNvbnRyaWJ1dGlvbiBpcyByZWRlc2lnbmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTEvQ1VSUkVOVCMxMTAtMS1iLTQtaWlpXFxcIj4xMSBDRlIgMTEwLjEoYikoNSk8L2E+LjwvbGk+PC91bD4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMS9DVVJSRU5UIzExMC0xLWItNFxcXCI+MTEgQ0ZSIDExMC4xKGIpKDQpPC9hPi5cIn0se1widGVybVwiOlwiRGlyZWN0IG1haWxcIixcImRlZmluaXRpb25cIjpcIkFueSBtYWlsaW5ncyBtYWRlIGJ5IGEgY29tbWVyY2lhbCB2ZW5kb3Igb3IgbWFkZSBmcm9tIGEgY29tbWVyY2lhbCBsaXN0LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtODcvQ1VSUkVOVCMxMDAtODdcXFwiPjEwMC44NyhhKTwvYT4sIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTg5L0NVUlJFTlQjMTAwLTg5LWFcXFwiPjEwMC44OShhKTwvYT4sIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTE0Ny9DVVJSRU5UIzEwMC0xNDctYVxcXCI+MTAwLjE0NyhhKTwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTE0OS9DVVJSRU5UIzEwMC0xNDlcXFwiPjEwMC4xNDkoYSk8L2E+XCJ9LHtcInRlcm1cIjpcIkRpc2J1cnNlbWVudFwiLFwiZGVmaW5pdGlvblwiOlwiQW55IHB1cmNoYXNlIG9yIHBheW1lbnQgbWFkZSBieSBhIHBvbGl0aWNhbCBjb21taXR0ZWUgb3IgYW55IG90aGVyIHBlcnNvbiB0aGF0IGlzIHN1YmplY3QgdG8gdGhlIEZlZGVyYWwgRWxlY3Rpb24gQ2FtcGFpZ24gQWN0LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMi9DVVJSRU5UIzMwMC0yLWRcXFwiPjMwMC4yKGQpPC9hPi5cIn0se1widGVybVwiOlwiRGlzY2xhaW1lciBub3RpY2VcIixcImRlZmluaXRpb25cIjpcIkEg4oCcZGlzY2xhaW1lcuKAnSBub3RpY2UgaXMgYSBzdGF0ZW1lbnQgdGhhdCBpZGVudGlmaWVzIHRoZSBwZXJzb24ocykgd2hvIHBhaWQgZm9yIGEgY29tbXVuaWNhdGlvbiBhbmQgd2hldGhlciB0aGUgY29tbXVuaWNhdGlvbiB3YXMgYXV0aG9yaXplZCBieSBvbmUgb3IgbW9yZSBjYW5kaWRhdGVzLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMTEvQ1VSUkVOVCMxMTAtMTFcXFwiPjExMC4xMTwvYT4uXCJ9LHtcInRlcm1cIjpcIkRpc3RyaWN0XCIsXCJkZWZpbml0aW9uXCI6XCJBIFUuUy4gSG91c2Ugb2YgUmVwcmVzZW50YXRpdmVzIERpc3RyaWN0LiBCZWNhdXNlIFNlbmF0b3JzIHJlcHJlc2VudCBhbiBlbnRpcmUgc3RhdGUsIFNlbmF0ZSByYWNlcyBkbyBub3QgaGF2ZSBkaXN0cmljdHMgYXNzb2NpYXRlZCB3aXRoIHRoZW0uXCJ9LHtcInRlcm1cIjpcIkRvbmF0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBIHBheW1lbnQsIGdpZnQsIHN1YnNjcmlwdGlvbiwgbG9hbiwgYWR2YW5jZSwgZGVwb3NpdCBvciBhbnl0aGluZyBvZiB2YWx1ZSBnaXZlbiB0byBhIHBlcnNvbiBidXQgZG9lcyBub3QgaW5jbHVkZSBjb250cmlidXRpb25zLjExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzMwMC0yL0NVUlJFTlQjMzAwLTItZC0yXFxcIj4zMDAuMihlKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkVhcm1hcmtlZCBjb250cmlidXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgY29udHJpYnV0aW9uIHRoYXQgdGhlIGNvbnRyaWJ1dG9yIGRpcmVjdHMgKGVpdGhlciBvcmFsbHkgb3IgaW4gd3JpdGluZykgdG8gb3Igb24gYmVoYWxmIG9mIGEgY2xlYXJseSBpZGVudGlmaWVkIGNhbmRpZGF0ZSBvciBhdXRob3JpemVkIGNvbW1pdHRlZSB0aHJvdWdoIGFuIGludGVybWVkaWFyeSBvciBjb25kdWl0LiBFYXJtYXJraW5nIG1heSB0YWtlIHRoZSBmb3JtIG9mIGEgZGVzaWduYXRpb24sIGluc3RydWN0aW9uIG9yIGVuY3VtYnJhbmNlLCBhbmQgaXQgbWF5IGJlIGRpcmVjdCBvciBpbmRpcmVjdCwgZXhwcmVzcyBvciBpbXBsaWVkLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtNi9DVVJSRU5UIzExMC02XFxcIj4xMTAuNjwvYT4uXCJ9LHtcInRlcm1cIjpcIkVsZWN0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBbnkgb25lIG9mIHNldmVyYWwgcHJvY2Vzc2VzIGJ5IHdoaWNoIGFuIGluZGl2aWR1YWwgc2Vla3Mgbm9taW5hdGlvbiBmb3IgZWxlY3Rpb24sIG9yIGVsZWN0aW9uLCB0byBmZWRlcmFsIG9mZmljZS4gVGhleSBpbmNsdWRlOiBhIHByaW1hcnkgZWxlY3Rpb24sIGluY2x1ZGluZyBhIGNhdWN1cyBvciBjb252ZW50aW9uIHRoYXQgaGFzIGF1dGhvcml0eSB0byBzZWxlY3QgYSBub21pbmVlOyBhIGdlbmVyYWwgZWxlY3Rpb247IGEgcnVub2ZmIGVsZWN0aW9uOyBhbmQgYSBzcGVjaWFsIGVsZWN0aW9uIGhlbGQgdG8gZmlsbCBhIHZhY2FudCBzZWF0LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMi9DVVJSRU5UIzEwMC0yXFxcIj4xMDAuMjwvYT4uXCJ9LHtcInRlcm1cIjpcIkVsZWN0aW9uIGN5Y2xlXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgcGVyaW9kIGJlZ2lubmluZyB0aGUgZGF5IGFmdGVyIHRoZSBwcmV2aW91cyBnZW5lcmFsIGVsZWN0aW9uIGZvciBhIGdpdmVuIGZlZGVyYWwgb2ZmaWNlIGFuZCBlbmRpbmcgb24gdGhlIGRhdGUgb2YgdGhlIGdlbmVyYWwgZWxlY3Rpb24gZm9yIHRoYXQgb2ZmaWNlLiBUaGUgbnVtYmVyIG9mIHllYXJzIGluIGFuIGVsZWN0aW9uIGN5Y2xlIGRpZmZlcnMgYWNjb3JkaW5nIHRvIHRoZSBmZWRlcmFsIG9mZmljZSBzb3VnaHQuIFRoZSBlbGVjdGlvbiBjeWNsZSBzcGFucyB0d28geWVhcnMgZm9yIEhvdXNlIGNhbmRpZGF0ZXM7IGZvdXIgeWVhcnMgZm9yIHByZXNpZGVudGlhbCBjYW5kaWRhdGVzOyBhbmQgc2l4IHllYXJzIGZvciBTZW5hdGUgY2FuZGlkYXRlcy4gU2VlIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0zL0NVUlJFTlQjMTAwLTMtYlxcXCI+MTAwLjMoYik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJFbGVjdGlvbmVlcmluZyBjb21tdW5pY2F0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBbnkgYnJvYWRjYXN0LCBjYWJsZSBvciBzYXRlbGxpdGUgY29tbXVuaWNhdGlvbiB0aGF0ICgxKSByZWZlcnMgdG8gYSBjbGVhcmx5IGlkZW50aWZpZWQgY2FuZGlkYXRlIGZvciBmZWRlcmFsIG9mZmljZTsgKDIpIGlzIHB1YmxpY2x5IGRpc3RyaWJ1dGVkIHdpdGhpbiBjZXJ0YWluIHRpbWUgcGVyaW9kcyBiZWZvcmUgYW4gZWxlY3Rpb24gYW5kICgzKSBpcyB0YXJnZXRlZCB0byB0aGUgcmVsZXZhbnQgZWxlY3RvcmF0ZS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTI5L0NVUlJFTlQjMTAwLTI5XFxcIj4xMDAuMjk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJFbXBsb3llclwiLFwiZGVmaW5pdGlvblwiOlwiVGhlIG9yZ2FuaXphdGlvbiBvciBwZXJzb24gYnkgd2hvbSBhbiBpbmRpdmlkdWFsIGlzIGVtcGxveWVkLCBhbmQgbm90IHRoZSBuYW1lIG9mIGhpcyBvciBoZXIgc3VwZXJ2aXNvci4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjEvQ1VSUkVOVCMxMDAtMjFcXFwiPjExIENGUiAxMDAuMjE8L2E+LlwifSx7XCJ0ZXJtXCI6XCJFbmRpbmcgY2FzaC1vbi1oYW5kXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgdG90YWwgYW1vdW50IG9mIGNhc2ggb24gaGFuZCB0aGF0IHJlbWFpbnMgYWZ0ZXIgdGhlIGFtb3VudCBvZiBjYXNoLW9uLWhhbmQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVwb3J0aW5nIHBlcmlvZCBpcyBhZGp1c3RlZCB0byBhZGQgdGhlIHRvdGFsIHJlY2VpcHRzIGZvciB0aGUgcmVwb3J0aW5nIHBlcmlvZCBhbmQgc3VidHJhY3QgdGhlIHRvdGFsIGRpc2J1cnNlbWVudHMgZm9yIHRoZSByZXBvcnRpbmcgcGVyaW9kLlwifSx7XCJ0ZXJtXCI6XCJFeGVjdXRpdmUgYW5kIGFkbWluaXN0cmF0aXZlIHBlcnNvbm5lbFwiLFwiZGVmaW5pdGlvblwiOlwiSW5kaXZpZHVhbHMgZW1wbG95ZWQgYnkgYSBjb3Jwb3JhdGlvbiBvciBsYWJvciBvcmdhbml6YXRpb24gd2hvIGFyZSBwYWlkIG9uIGEgc2FsYXJ5IHJhdGhlciB0aGFuIGhvdXJseSBiYXNpcyBhbmQgd2hvIGhhdmUgcG9saWN5bWFraW5nLCBtYW5hZ2VyaWFsLCBwcm9mZXNzaW9uYWwsIG9yIHN1cGVydmlzb3J5IHJlc3BvbnNpYmlsaXRpZXMuIFRoZSBkZWZpbml0aW9uIGRvZXMgbm90IGluY2x1ZGUgcHJvZmVzc2lvbmFscyB3aG8gYXJlIHJlcHJlc2VudGVkIGJ5IGEgbGFib3Igb3JnYW5pemF0aW9uLCBzYWxhcmllZCBmb3JlbWVuIGFuZCBsb3dlci1sZXZlbCBzdXBlcnZpc29ycyBoYXZpbmcgZGlyZWN0IHN1cGVydmlzaW9uIG92ZXIgaG91cmx5IGVtcGxveWVlcywgZm9ybWVyIG9yIHJldGlyZWQgcGVyc29ubmVsIHdobyBhcmUgbm90IHN0b2NraG9sZGVycywgYW5kIGNvbnN1bHRhbnRzIHdobyBhcmUgbm90IGVtcGxveWVlcyB1bmRlciB0aGUgSW50ZXJuYWwgUmV2ZW51ZSBDb2RlLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTQtMS9DVVJSRU5UIzExNC0xLWNcXFwiPjExNC4xKGMpPC9hPiwgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZWNmci5nb3YvY2dpLWJpbi90ZXh0LWlkeD9TSUQ9OGZjYzI4Y2QwY2M3ZDYyNjJlNWRiZTM4NjUzMzVkZjAmbWM9dHJ1ZSZub2RlPXNlMjYuMTcuMzFfMTM0MDFfMmNfM182MSZyZ249ZGl2OFxcXCI+MjYgQ0ZSIDMxLjM0MDEoYyktMTwvYT4uXCJ9LHtcInRlcm1cIjpcIkV4ZW1wdCBwYXJ0eSBhY3Rpdml0aWVzXCIsXCJkZWZpbml0aW9uXCI6XCJDZXJ0YWluIGNhbmRpZGF0ZSBzdXBwb3J0IGFjdGl2aXRpZXMgdGhhdCBzdGF0ZSBhbmQgbG9jYWwgcGFydHkgZ3JvdXBzIG1heSB1bmRlcnRha2Ugd2l0aG91dCBtYWtpbmcgYSBjb250cmlidXRpb24gb3IgZXhwZW5kaXR1cmUsIHByb3ZpZGVkIHNwZWNpZmljIHJ1bGVzIGFyZSBmb2xsb3dlZC5cIn0se1widGVybVwiOlwiRXhwZW5kaXR1cmVcIixcImRlZmluaXRpb25cIjpcIkEgcHVyY2hhc2UsIHBheW1lbnQsIGRpc3RyaWJ1dGlvbiwgbG9hbiwgYWR2YW5jZSwgZGVwb3NpdCBvciBnaWZ0IG9mIG1vbmV5IG9yIGFueXRoaW5nIG9mIHZhbHVlIG1hZGUgZm9yIHRoZSBwdXJwb3NlIG9mIGluZmx1ZW5jaW5nIGEgZmVkZXJhbCBlbGVjdGlvbi4gQSB3cml0dGVuIGFncmVlbWVudCB0byBtYWtlIGFuIGV4cGVuZGl0dXJlIGlzIGFsc28gY29uc2lkZXJlZCBhbiBleHBlbmRpdHVyZS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTExMS9DVVJSRU5UIzEwMC0xMTFcXFwiPjEwMC4xMTE8L2E+IGFuZCA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0xMTIvQ1VSUkVOVCMxMDAtMTEyXFxcIj4xMDAuMTEyPC9hPi5cIn0se1widGVybVwiOlwiRXhwcmVzcyBhZHZvY2FjeVwiLFwiZGVmaW5pdGlvblwiOlwiVW5hbWJpZ3VvdXNseSBhZHZvY2F0aW5nIHRoZSBlbGVjdGlvbiBvciBkZWZlYXQgb2YgYSBjbGVhcmx5IGlkZW50aWZpZWQgZmVkZXJhbCBjYW5kaWRhdGUuIFRoZXJlIGFyZSB0d28gd2F5cyB0aGF0IGEgY29tbXVuaWNhdGlvbiBjYW4gYmUgZGVmaW5lZCBhcyBleHByZXNzIGFkdm9jYWN5IChjYW5kaWRhdGUgYWR2b2NhY3kpOiBieSB1c2Ugb2YgY2VydGFpbiDigJxleHBsaWNpdCB3b3JkcyBvZiBhZHZvY2FjeSBvZiBlbGVjdGlvbiBvciBkZWZlYXTigJ0gYW5kIGJ5IHRoZSDigJxvbmx5IHJlYXNvbmFibGUgaW50ZXJwcmV0YXRpb27igJ0gdGVzdC4gU2VlIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yMi9DVVJSRU5UIzEwMC0yMlxcXCI+MTAwLjIyPC9hPi5cIn0se1widGVybVwiOlwiRmFjaWxpdGF0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgdXNlIG9mIGNvcnBvcmF0ZSBvciBsYWJvciBvcmdhbml6YXRpb24gcmVzb3VyY2VzIG9yIGZhY2lsaXRpZXMgdG8gZW5nYWdlIGluIGZ1bmRyYWlzaW5nIGFjdGl2aXRpZXMgaW4gY29ubmVjdGlvbiB3aXRoIGFueSBmZWRlcmFsIGVsZWN0aW9uIChvdGhlciB0aGFuIHJhaXNpbmcgZnVuZHMgZm9yIHRoZSBvcmdhbml6YXRpb27igJlzIHNlcGFyYXRlIHNlZ3JlZ2F0ZWQgZnVuZCkuIEZhY2lsaXRhdGlvbiByZXN1bHRzIGluIGEgcHJvaGliaXRlZCBjb250cmlidXRpb24gdG8gdGhlIGNvbW1pdHRlZSB0aGF0IGJlbmVmaXRzIGZyb20gdGhlIGFjdGl2aXR5LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTQtMi9DVVJSRU5UIzExNC0yLWZcXFwiPjExNC4yKGYpPC9hPi5cIn0se1widGVybVwiOlwiRmFtaWx5XCIsXCJkZWZpbml0aW9uXCI6XCJGb3IgcHVycG9zZXMgb2YgdGhlIHJ1bGVzIGdvdmVybmluZyBmdW5kcmFpc2luZyBieSBjb3Jwb3JhdGUvbGFib3IvdHJhZGUgUEFDcywgdGhlIENvbW1pc3Npb24gdmlld3MgdGhlIHRlcm0gXFxcImZhbWlseVxcXCIgdG8gbWVhbiB0aGUgc3BvdXNlcywgcGFyZW50cywgYW5kIGNoaWxkcmVuIHdobyBsaXZlIGluIHRoZSBzYW1lIGhvdXNlaG9sZC4gU3BvdXNlIGlzIGRlZmluZWQgYnkgc3RhdGUgbGF3LiBTZWUgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL2Fkdmlzb3J5LW9waW5pb25zLzIwMTMtMDZcXFwiPkFPcyAyMDEzLTA2PC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL2Fkdmlzb3J5LW9waW5pb25zLzE5ODAtMTAyXFxcIj4xOTgwLTEwMjwvYT4uIEZvciBwdXJwb3NlcyBvZiB0aGUgcnVsZXMgZ292ZXJuaW5nIHRoZSB1c2Ugb2YgY2FtcGFpZ24gZnVuZHMgYnkgY2FuZGlkYXRlcywgYSBjYW5kaWRhdGXigJlzIGZhbWlseSBpbmNsdWRlcyB0aGUgY2FuZGlkYXRl4oCZcyBzcG91c2UsIGFueSBjaGlsZCwgc3RlcC1jaGlsZCwgcGFyZW50LCBncmFuZHBhcmVudCwgc2libGluZywgaGFsZi1zaWJsaW5nIG9yIHN0ZXAtc2libGluZyBvZiB0aGUgY2FuZGlkYXRlIG9yIHRoZSBjYW5kaWRhdGUncyBzcG91c2UsIHRoZSBzcG91c2Ugb2YgYW55IGNoaWxkLCBzdGVwLWNoaWxkLCBwYXJlbnQsIGdyYW5kcGFyZW50LCBzaWJsaW5nLCBoYWxmLXNpYmxpbmcgb3Igc3RlcC1zaWJsaW5nIG9mIHRoZSBjYW5kaWRhdGU7IGFuZCBhbnkgcGVyc29uIHdobyBzaGFyZXMgYSByZXNpZGVuY2Ugd2l0aCB0aGUgY2FuZGlkYXRlLiBTZWUgMTEgQ0ZSICA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMy0xL0NVUlJFTlQjMTEzLTEtZy03XFxcIj4xMTMuMShnKSg3KTwvYT4uIFB1YmxpY2x5IGZ1bmRlZCBwcmVzaWRlbnRpYWwgY2FuZGlkYXRlcyBzaG91bGQgcmVmZXIgdG8gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvOTAwMy0yL0NVUlJFTlQjOTAwMy0yLWMtMVxcXCI+OTAwMy4yKGMpKDEpPC9hPiBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy85MDM1LTIvMjAxNy1hbm51YWwtOTAzNSM5MDM1LTItYlxcXCI+OTAzNS4yKGIpPC9hPi5cIn0se1widGVybVwiOlwiRmVkZXJhbCBFbGVjdGlvbiBBY3Rpdml0eSAoRkVBKVwiLFwiZGVmaW5pdGlvblwiOlwiQWN0aXZpdHkgYnkgc3RhdGUsIGRpc3RyaWN0IGFuZCBsb2NhbCBwYXJ0eSBjb21taXR0ZWVzLCB3aGljaCBtYXkgYmUgcGFpZCBmb3Igd2l0aCBmZWRlcmFsIG9yIOKAkyBpbiB0aGUgY2FzZSBvZiB0aGUgZmlyc3QgdHdvIHR5cGVzIOKAkyBhIGNvbWJpbmF0aW9uIG9mIGZlZGVyYWwgYW5kIExldmluIGZ1bmRzLiBUaGUgZm91ciB0eXBlcyBvZiBmZWRlcmFsIGVsZWN0aW9uIGFjdGl2aXR5IGFyZSBhcyBmb2xsb3dzOjx1bCBjbGFzcz1cXFwibGlzdC1udW1iZXJlZFxcXCI+PGxpPlZvdGVyIHJlZ2lzdHJhdGlvbiBhY3Rpdml0eSBkdXJpbmcgdGhlIHBlcmlvZCAxMjAgZGF5cyBiZWZvcmUgYSBwcmltYXJ5IG9yIGdlbmVyYWwgZWxlY3Rpb24gYW5kIGVuZGluZyBvbiBlbGVjdGlvbiBkYXkgaXRzZWxmOzwvbGk+PGxpPlZvdGVyIGlkZW50aWZpY2F0aW9uLCBnZXQtb3V0LXRoZS12b3RlIGFuZCBnZW5lcmljIGNhbXBhaWduIGFjdGl2aXR5IGNvbmR1Y3RlZCBpbiBjb25uZWN0aW9uIHdpdGggYW4gZWxlY3Rpb24gaW4gd2hpY2ggYSBmZWRlcmFsIGNhbmRpZGF0ZSBhcHBlYXJzIG9uIHRoZSBiYWxsb3Q7PC9saT48bGk+QSBwdWJsaWMgY29tbXVuaWNhdGlvbiB0aGF0IHJlZmVycyB0byBhIGNsZWFybHkgaWRlbnRpZmllZCBjYW5kaWRhdGUgZm9yIGZlZGVyYWwgb2ZmaWNlIGFuZCB0aGF0IHByb21vdGVzLCBhdHRhY2tzLCBzdXBwb3J0cyBvciBvcHBvc2VzIGFueSBjYW5kaWRhdGUgZm9yIGZlZGVyYWwgb2ZmaWNlLiBUaGUgY29tbXVuaWNhdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGV4cHJlc3NseSBhZHZvY2F0ZSB0aGUgZWxlY3Rpb24gb3IgZGVmZWF0IG9mIHRoZSBmZWRlcmFsIGNhbmRpZGF0ZSB0byBxdWFsaWZ5IGFzIGZlZGVyYWwgZWxlY3Rpb24gYWN0aXZpdHk7IGFuZCA8L2xpPjxsaT5TZXJ2aWNlcyBwcm92aWRlZCBkdXJpbmcgYSBtb250aCBieSBhbiBlbXBsb3llZSBvZiBhIHN0YXRlLCBkaXN0cmljdCBvciBsb2NhbCBwYXJ0eSBjb21taXR0ZWUgd2hvIHNwZW5kcyBtb3JlIHRoYW4gMjUgcGVyY2VudCBvZiBoaXMgb3IgaGVyIGNvbXBlbnNhdGVkIHRpbWUgZHVyaW5nIHRoYXQgbW9udGggb24gYWN0aXZpdGllcyBpbiBjb25uZWN0aW9uIHdpdGggYSBmZWRlcmFsIGVsZWN0aW9uIGluY2x1ZGluZyBGRUEuPC9saT48L3VsPiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjQvQ1VSUkVOVCMxMDAtMjQtYlxcXCI+MTAwLjI0KGIpPC9hPi5cIn0se1widGVybVwiOlwiRmVkZXJhbCBmdW5kc1wiLFwiZGVmaW5pdGlvblwiOlwiRnVuZHMgdGhhdCBjb21wbHkgd2l0aCB0aGUgbGltaXRzLCBwcm9oaWJpdGlvbnMgYW5kIHJlcG9ydGluZyByZXF1aXJlbWVudHMgb2YgdGhlIEZlZGVyYWwgRWxlY3Rpb24gQ2FtcGFpZ24gQWN0LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMi9DVVJSRU5UIzMwMC0yLWdcXFwiPjMwMC4yKGcpPC9hPi5cIn0se1widGVybVwiOlwiRmVkZXJhbCBnb3Zlcm5tZW50IGNvbnRyYWN0b3JcIixcImRlZmluaXRpb25cIjpcIkEgcGVyc29uIHdobyBlbnRlcnMgaW50byBhIGNvbnRyYWN0LCBvciBpcyBiaWRkaW5nIG9uIHN1Y2ggYSBjb250cmFjdCwgd2l0aCBhbnkgYWdlbmN5IG9yIGRlcGFydG1lbnQgb2YgdGhlIFVuaXRlZCBTdGF0ZXMgZ292ZXJubWVudCBhbmQgaXMgcGFpZCwgb3IgaXMgdG8gYmUgcGFpZCwgZm9yIHNlcnZpY2VzLCBtYXRlcmlhbCwgZXF1aXBtZW50LCBzdXBwbGllcywgbGFuZCBvciBidWlsZGluZ3Mgd2l0aCBmdW5kcyBhcHByb3ByaWF0ZWQgYnkgQ29uZ3Jlc3MuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNS0xL0NVUlJFTlQjMTE1LTFcXFwiPjExNS4xPC9hPi5cIn0se1widGVybVwiOlwiRmVkZXJhbCBvZmZpY2Vob2xkZXJcIixcImRlZmluaXRpb25cIjpcIkFuIGluZGl2aWR1YWwgZWxlY3RlZCB0byBvciBzZXJ2aW5nIGluIHRoZSBvZmZpY2Ugb2YgUHJlc2lkZW50IG9yIFZpY2UgUHJlc2lkZW50IG9mIHRoZSBVbml0ZWQgU3RhdGVzLCBvciBhIFNlbmF0b3Igb3IgUmVwcmVzZW50YXRpdmUgaW4sIG9yIGEgRGVsZWdhdGUgb3IgUmVzaWRlbnQgQ29tbWlzc2lvbmVyLCB0byB0aGUgQ29uZ3Jlc3Mgb2YgdGhlIFVuaXRlZCBTdGF0ZXMuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMy0xL0NVUlJFTlQjMTEzLTEtY1xcXCI+MTEzLjEoYyk8L2E+IGFuZCA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzMwMC0yL0NVUlJFTlQjMzAwLTItb1xcXCI+MzAwLjIobyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJGZWRlcmFsbHkgY2hhcnRlcmVkIGNvcnBvcmF0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvcnBvcmF0aW9uIHRoYXQgaXMgb3JnYW5pemVkIHB1cnN1YW50IHRvIGEgZmVkZXJhbCBzdGF0dXRlIGFuZCB0aGF0IGJlY2FtZSBhIGNvcnBvcmF0aW9uIHdoZW4gaXQgcmVjZWl2ZWQgYSBjaGFydGVyIGZyb20gYSBmZWRlcmFsIGFnZW5jeS4gU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvZGF0YS9sZWdhbC9hZHZpc29yeS1vcGluaW9ucy8xOTg4LTEyXFxcIj5BT3MgMTk4OC0xMjwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvZGF0YS9sZWdhbC9hZHZpc29yeS1vcGluaW9ucy8xOTg0LTYzXFxcIj4xOTg0LTYzPC9hPi5cIn0se1widGVybVwiOlwiRmlsaW5nXCIsXCJkZWZpbml0aW9uXCI6XCJBIHJlcG9ydCwgZGVzaWduYXRpb24gb3Igc3RhdGVtZW50IHN1Ym1pdHRlZCB0byB0aGUgRkVDIG9yIFNlY3JldGFyeSBvZiB0aGUgU2VuYXRlIGJ5IGEgY2FuZGlkYXRlLCBjb21taXR0ZWUgb3Igb3RoZXIgZW50aXR5LiBSZXF1aXJlZCBmaWxpbmdzIGluY2x1ZGUgZGVjbGFyYXRpb25zIG9mIGNhbmRpZGFjeSBhbmQgY29tbWl0dGVlIHJlcG9ydHMgb2YgdGhlIG1vbmV5IHRoZXkgcmVjZWl2ZSBhbmQgc3BlbmQuICBTZWUgYWxzbyBcXFwiUmVwb3J0cywgZGVzaWduYXRpb25zIGFuZCBzdGF0ZW1lbnRzXFxcIi5cIn0se1widGVybVwiOlwiRm9yZWlnbiBuYXRpb25hbFwiLFwiZGVmaW5pdGlvblwiOlwiPG9sPjxsaT4gQW4gaW5kaXZpZHVhbCB3aG8gaXMgbm90IGEgY2l0aXplbiBvZiB0aGUgVW5pdGVkIFN0YXRlcyBvciBhIG5hdGlvbmFsIG9mIHRoZSBVbml0ZWQgU3RhdGVzIGFuZCBoYXMgbm90IGJlZW4gbGF3ZnVsbHkgYWRtaXR0ZWQgdG8gdGhlIFUuUy4gZm9yIHBlcm1hbmVudCByZXNpZGVuY2UsIGFzIGRlZmluZWQgaW4gOCBVLlMuQy4gwqcgMTEwMShhKSgyMCk7IG9yPC9saT48bGk+QSBmb3JlaWduIHByaW5jaXBhbCwgYXMgZGVmaW5lZCBpbiAyMiBVLlMuQy4gwqcgNjExKGIpLjwvbGk+PC9vbD4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTIwL0NVUlJFTlQjMTEwLTIwLWFcXFwiPjExMC4yMChhKSgzKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkdlbmVyaWMgY2FtcGFpZ24gYWN0aXZpdHlcIixcImRlZmluaXRpb25cIjpcIkEgdHlwZSBvZiBGZWRlcmFsIEVsZWN0aW9uIEFjdGl2aXR5LCBhcyBkaXN0aW5ndWlzaGVkIGZyb20gdm90ZXIgZHJpdmUgYWN0aXZpdHkuIEdlbmVyaWMgY2FtcGFpZ24gYWN0aXZpdHkgaXMgYSBwdWJsaWMgY29tbXVuaWNhdGlvbiB0aGF0IHByb21vdGVzIG9yIG9wcG9zZXMgYSBwb2xpdGljYWwgcGFydHkgYW5kIGRvZXMgbm90IHByb21vdGUgb3Igb3Bwb3NlIGEgY2xlYXJseSBpZGVudGlmaWVkIGZlZGVyYWwgY2FuZGlkYXRlIG9yIGEgbm9uZmVkZXJhbCBjYW5kaWRhdGUuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yNS9DVVJSRU5UIzEwMC0yNVxcXCI+MTAwLjI1PC9hPi5cIn0se1widGVybVwiOlwiR2V0LU91dC1UaGUtVm90ZSAoR09UVilcIixcImRlZmluaXRpb25cIjpcIkluIHJlZ2FyZCB0byBGRUEsIEdPVFYgYWN0aXZpdHkgZW5jb21wYXNzZXMgYWxsIG1lYW5zIG9mIGFzc2lzdGluZywgZW5jb3VyYWdpbmcgb3IgdXJnaW5nIHBvdGVudGlhbCB2b3RlcnMgdG8gdm90ZS4gVGhpcyBhY3Rpdml0eSBpbmNsdWRlcywgYnV0IGlzIG5vdCBsaW1pdGVkIHRvOiA8dWw+PGxpPkVuY291cmFnaW5nIG9yIHVyZ2luZyBwb3RlbnRpYWwgdm90ZXJzIHRvIHZvdGUsIHdoZXRoZXIgYnkgbWFpbCAoaW5jbHVkaW5nIGRpcmVjdCBtYWlsKSwgZW1haWwsIGluIHBlcnNvbiwgYnkgdGVsZXBob25lIChpbmNsdWRpbmcgcHJlcmVjb3JkZWQgdGVsZXBob25lIGNhbGxzLCBwaG9uZSBiYW5rcyBhbmQgbWVzc2FnaW5nIHN1Y2ggYXMgU01TIGFuZCBNTVMpLCBvciBieSBhbnkgb3RoZXIgbWVhbnM7PC9saT48bGk+SW5mb3JtaW5nIHBvdGVudGlhbCB2b3RlcnMsIHdoZXRoZXIgYnkgbWFpbCAoaW5jbHVkaW5nIGRpcmVjdCBtYWlsKSwgZW1haWwsIGluIHBlcnNvbiwgYnkgdGVsZXBob25lIChpbmNsdWRpbmcgcHJlLXJlY29yZGVkIHRlbGVwaG9uZSBjYWxscywgcGhvbmUgYmFua3MgYW5kIG1lc3NhZ2luZyBzdWNoIGFzIFNNUyBhbmQgTU1TKSwgb3IgYnkgYW55IG90aGVyIG1lYW5zLCBhYm91dCB0aGUgaG91cnMgb3IgbG9jYXRpb24gb2YgcG9sbGluZyBwbGFjZXMsIG9yIGFib3V0IGVhcmx5IHZvdGluZyBvciB2b3RpbmcgYnkgYWJzZW50ZWUgYmFsbG90OzwvbGk+PGxpPk9mZmVyaW5nIG9yIGFycmFuZ2luZyB0byB0cmFuc3BvcnQsIG9yIGFjdHVhbGx5IHRyYW5zcG9ydGluZyB2b3RlcnMgdG8gdGhlIHBvbGxzOzwvbGk+PGxpPkFueSBvdGhlciBhY3Rpdml0eSB0aGF0IGFzc2lzdHMgcG90ZW50aWFsIHZvdGVycyBpbiB2b3RpbmcuPC9saT48L3VsPiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjQvQ1VSUkVOVCMxMDAtMjQtYS0zXFxcIj4xMDAuMjQoYSkoMyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJIeWJyaWQgUEFDXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbW1pdHRlZSB0aGF0LCBpbiBhZGRpdGlvbiB0byBtYWtpbmcgY29udHJpYnV0aW9ucywgZXN0YWJsaXNoZXMgYSBzZXBhcmF0ZSBiYW5rIGFjY291bnQgdG8gZGVwb3NpdCBhbmQgd2l0aGRyYXcgZnVuZHMgcmFpc2VkIGluIHVubGltaXRlZCBhbW91bnRzIGZyb20gaW5kaXZpZHVhbHMsIGNvcnBvcmF0aW9ucywgbGFib3Igb3JnYW5pemF0aW9ucyBhbmQvb3Igb3RoZXIgcG9saXRpY2FsIGNvbW1pdHRlZXMsIGNvbnNpc3RlbnQgd2l0aCB0aGUgc3RpcHVsYXRlZCBqdWRnbWVudCBpbiA8aT5DYXJleSB2LiBGRUM8L2k+LiBUaGUgZnVuZHMgbWFpbnRhaW5lZCBpbiB0aGlzIHNlcGFyYXRlIGFjY291bnQgd2lsbCBub3QgYmUgdXNlZCB0byBtYWtlIGNvbnRyaWJ1dGlvbnMsIHdoZXRoZXIgZGlyZWN0LCBpbi1raW5kIG9yIHZpYSBjb29yZGluYXRlZCBjb21tdW5pY2F0aW9ucywgb3IgY29vcmRpbmF0ZWQgZXhwZW5kaXR1cmVzLCB0byBmZWRlcmFsIGNhbmRpZGF0ZXMgb3IgY29tbWl0dGVlcy5cIn0se1widGVybVwiOlwiSWRlbnRpZmljYXRpb25cIixcImRlZmluaXRpb25cIjpcIkZvciBwdXJwb3NlcyBvZiByZWNvcmRrZWVwaW5nIGFuZCByZXBvcnRpbmcsIGEgcGVyc29u4oCZcyBmdWxsIG5hbWUgYW5kIGFkZHJlc3MgYW5kLCBpbiB0aGUgY2FzZSBvZiBhbiBpbmRpdmlkdWFsLCBoaXMgb3IgaGVyIG9jY3VwYXRpb24gKHByaW5jaXBhbCBqb2IgdGl0bGUgb3IgcG9zaXRpb24pIGFuZCBlbXBsb3llciAob3JnYW5pemF0aW9uIG9yIHBlcnNvbiBieSB3aG9tIGFuIGluZGl2aWR1YWwgaXMgZW1wbG95ZWQpIGFzIHdlbGwuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0xMi9DVVJSRU5UIzEwMC0xMlxcXCI+MTAwLjEyPC9hPiwgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjAvQ1VSUkVOVCMxMDAtMjBcXFwiPjEwMC4yMDwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTIxL0NVUlJFTlQjMTAwLTIxXFxcIj4xMDAuMjE8L2E+LlwifSx7XCJ0ZXJtXCI6XCJJbi1raW5kIGNvbnRyaWJ1dGlvblwiLFwiZGVmaW5pdGlvblwiOlwiQSBjb250cmlidXRpb24gb2YgZ29vZHMsIHNlcnZpY2VzIG9yIHByb3BlcnR5IG9mZmVyZWQgZnJlZSBvciBhdCBsZXNzIHRoYW4gdGhlIHVzdWFsIGFuZCBub3JtYWwgY2hhcmdlLiBUaGUgdGVybSBhbHNvIGluY2x1ZGVzIHBheW1lbnRzIG1hZGUgb24gYmVoYWxmIG9mLCBidXQgbm90IGRpcmVjdGx5IHRvLCBjYW5kaWRhdGVzIGFuZCBwb2xpdGljYWwgY29tbWl0dGVlcyAoZXhjZXB0IGZvciBpbmRlcGVuZGVudCBleHBlbmRpdHVyZXMgb3Igbm9uLWNvb3JkaW5hdGVkIGNvbW11bmljYXRpb25zKS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTUyL0NVUlJFTlQjMTAwLTUyLWRcXFwiPjEwMC41MihkKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkluZGVwZW5kZW50IGV4cGVuZGl0dXJlXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBleHBlbmRpdHVyZSBmb3IgYSBjb21tdW5pY2F0aW9uIDx1bD48bGk+VGhhdCBleHByZXNzbHkgYWR2b2NhdGVzIHRoZSBlbGVjdGlvbiBvciBkZWZlYXQgb2YgYSBjbGVhcmx5IGlkZW50aWZpZWQgY2FuZGlkYXRlIGFuZDwvbGk+PGxpPlRoYXQgaXMgbm90IG1hZGUgaW4gY29vcGVyYXRpb24sIGNvbnN1bHRhdGlvbiBvciBjb25jZXJ0IHdpdGgsIG9yIGF0IHRoZSByZXF1ZXN0IG9yIHN1Z2dlc3Rpb24gb2YsIGFueSBjYW5kaWRhdGUsIG9yIGhpcyBvciBoZXIgYXV0aG9yaXplZCBjb21taXR0ZWVzIG9yIGFnZW50cywgb3IgYSBwb2xpdGljYWwgcGFydHkgY29tbWl0dGVlIG9yIGl0cyBhZ2VudHMuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0xNi9DVVJSRU5UIzEwMC0xNlxcXCI+MTAwLjE2PC9hPi48L2xpPjwvdWw+XCJ9LHtcInRlcm1cIjpcIkluZGVwZW5kZW50IGV4cGVuZGl0dXJlIG9ubHkgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJQb2xpdGljYWwgY29tbWl0dGVlcyB0aGF0IG1ha2Ugb25seSBpbmRlcGVuZGVudCBleHBlbmRpdHVyZXMgdGhhdCBtYXkgc29saWNpdCBhbmQgYWNjZXB0IHVubGltaXRlZCBjb250cmlidXRpb25zIGZyb20gaW5kaXZpZHVhbHMsIGNvcnBvcmF0aW9ucywgbGFib3Igb3JnYW5pemF0aW9ucyBhbmQgb3RoZXIgcG9saXRpY2FsIGNvbW1pdHRlZXMuIFRoZXkgbWF5IG5vdCBhY2NlcHQgY29udHJpYnV0aW9ucyBmcm9tIGZvcmVpZ24gbmF0aW9uYWxzLCBmZWRlcmFsIGNvbnRyYWN0b3JzLCBuYXRpb25hbCBiYW5rcyBvciBmZWRlcmFsbHkgY2hhcnRlcmVkIGNvcnBvcmF0aW9ucy4gU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvZGF0YS9sZWdhbC9hZHZpc29yeS1vcGluaW9ucy8yMDEwLTExL1xcXCI+QU8gMjAxMC0xMTwvYT4uIFN1Y2ggY29tbWl0dGVlcywgcG9wdWxhcmx5IGtub3duIGFzIFN1cGVyIFBBQ3MsIG11c3QgcmVnaXN0ZXIgd2l0aCB0aGUgQ29tbWlzc2lvbiBhbmQgY29tcGx5IHdpdGggYWxsIGFwcGxpY2FibGUgcmVwb3J0aW5nIHJlcXVpcmVtZW50cyBvZiB0aGUgQWN0LlwifSx7XCJ0ZXJtXCI6XCJKb2ludCBjb250cmlidXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgY29udHJpYnV0aW9uIG1hZGUgYnkgbW9yZSB0aGFuIG9uZSBwZXJzb24gb24gYSBzaW5nbGUgY2hlY2sgb3Igb3RoZXIgd3JpdHRlbiBpbnN0cnVtZW50LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMS9DVVJSRU5UIzExMC0xLWtcXFwiPjExMC4xKGspKDEpPC9hPi5cIn0se1widGVybVwiOlwiSm9pbnQgZnVuZHJhaXNpbmdcIixcImRlZmluaXRpb25cIjpcIkZ1bmRyYWlzaW5nIGNvbmR1Y3RlZCBqb2ludGx5IGJ5IGEgcG9saXRpY2FsIGNvbW1pdHRlZSBhbmQgb25lIG9yIG1vcmUgb3RoZXIgcG9saXRpY2FsIGNvbW1pdHRlZXMgb3IgdW5yZWdpc3RlcmVkIG9yZ2FuaXphdGlvbnMuICBKb2ludCBmdW5kcmFpc2luZyBpcyBvZnRlbiBjb25kdWN0ZWQgYmV0d2VlbiBhIHByaW5jaXBhbCBjYW1wYWlnbiBjb21taXR0ZWUgYW5kIGEgcG9saXRpY2FsIHBhcnR5IGNvbW1pdHRlZS5cIn0se1widGVybVwiOlwiSm9pbnQgZnVuZHJhaXNpbmcgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbW1pdHRlZSB0aGF0IGhhcyBiZWVuIHNldCB1cCBmb3IgdGhlIHB1cnBvc2VzIG9mIGZ1bmRyYWlzaW5nIGZvciBtdWx0aXBsZSBjb21taXR0ZWVzIGF0IHRoZSBzYW1lIHRpbWUgb3IgYW4gZXhpc3RpbmcgY29tbWl0dGVlIHRoYXQgaGFzIGJlZW4gYXV0aG9yaXplZCB0byBzZXJ2ZSB0aGF0IHB1cnBvc2UuXCJ9LHtcInRlcm1cIjpcIkxhYm9yIG9yZ2FuaXphdGlvblwiLFwiZGVmaW5pdGlvblwiOlwiQW4gb3JnYW5pemF0aW9uLCBhZ2VuY3kgb3IgZW1wbG95ZWUgcmVwcmVzZW50YXRpdmUgY29tbWl0dGVlIG9yIHBsYW4sIGluIHdoaWNoIGVtcGxveWVlcyBwYXJ0aWNpcGF0ZSBhbmQgd2hpY2ggZXhpc3RzIGZvciB0aGUgcHVycG9zZSBvZiBkZWFsaW5nIHdpdGggZW1wbG95ZXJzIG9uIGdyaWV2YW5jZXMsIGxhYm9yIGRpc3B1dGVzLCB3YWdlcywgaG91cnMgb2YgZW1wbG95bWVudCBvciB3b3JraW5nIGNvbmRpdGlvbnMuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNC0xL0NVUlJFTlQjMTE0LTEtZFxcXCI+MTE0LjEoZCk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJMZWFkZXJzaGlwIFBBQ1wiLFwiZGVmaW5pdGlvblwiOlwiQSBwb2xpdGljYWwgY29tbWl0dGVlIHRoYXQgaXMgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBlc3RhYmxpc2hlZCwgZmluYW5jZWQsIG1haW50YWluZWQgb3IgY29udHJvbGxlZCBieSBhIGNhbmRpZGF0ZSBvciBhbiBpbmRpdmlkdWFsIGhvbGRpbmcgZmVkZXJhbCBvZmZpY2UsIGJ1dCBpcyBub3QgYW4gYXV0aG9yaXplZCBjb21taXR0ZWUgb2YgdGhlIGNhbmRpZGF0ZSBvciBvZmZpY2Vob2xkZXIgYW5kIGlzIG5vdCBhZmZpbGlhdGVkIHdpdGggYW4gYXV0aG9yaXplZCBjb21taXR0ZWUgb2YgYSBjYW5kaWRhdGUgb3Igb2ZmaWNlaG9sZGVyLlwifSx7XCJ0ZXJtXCI6XCJMZXZpbiBmdW5kc1wiLFwiZGVmaW5pdGlvblwiOlwiQSBjYXRlZ29yeSBvZiBmdW5kcyByYWlzZWQgYnkgc3RhdGUsIGRpc3RyaWN0IGFuZCBsb2NhbCBwYXJ0eSBjb21taXR0ZWVzIHRoYXQgbWF5IGJlIHNwZW50IGZvciBjZXJ0YWluIEZlZGVyYWwgRWxlY3Rpb24gQWN0aXZpdGllcy4gTGV2aW4gZnVuZHMgYXJlIGRvbmF0aW9ucyBmcm9tIHNvdXJjZXMgb3JkaW5hcmlseSBwcm9oaWJpdGVkIGJ5IGZlZGVyYWwgbGF3IGJ1dCBwZXJtaXR0ZWQgYnkgc3RhdGUgbGF3LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMzEvQ1VSUkVOVCMzMDAtMzFcXFwiPjMwMC4zMTwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMzAwLTMyL0NVUlJFTlQjMzAwLTMyXFxcIj4zMDAuMzI8L2E+LlwifSx7XCJ0ZXJtXCI6XCJMaW1pdGVkIGxpYWJpbGl0eSBjb21wYW55IChMTEMpXCIsXCJkZWZpbml0aW9uXCI6XCJBIGJ1c2luZXNzIGVudGl0eSB0aGF0IGlzIHJlY29nbml6ZWQgYXMgYSBsaW1pdGVkIGxpYWJpbGl0eSBjb21wYW55IHVuZGVyIHRoZSBsYXdzIG9mIHRoZSBzdGF0ZSBpbiB3aGljaCBpdCBpcyBlc3RhYmxpc2hlZC4gTExDcyB0aGF0IGFyZSB0cmVhdGVkIGFzIHBhcnRuZXJzaGlwcyB1bmRlciB0aGUgSVJTIGNvZGUgbWF5IG1ha2UgY29udHJpYnV0aW9ucy4gTExDcyB0aGF0IGhhdmUgcHVibGljbHkgdHJhZGVkIHN0b2NrIG9yIGFyZSB0cmVhdGVkIGFzIGNvcnBvcmF0aW9ucyB1bmRlciB0aGUgSVJTIGNvZGUgYXJlIHByb2hpYml0ZWQgZnJvbSBtYWtpbmcgY29udHJpYnV0aW9ucy4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTEvQ1VSUkVOVCMxMTAtMS1nXFxcIj4xMTAuMShnKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkxvYmJ5aXN0L3JlZ2lzdHJhbnRcIixcImRlZmluaXRpb25cIjpcIkEgcGVyc29uIHdobyBpcyBhIGN1cnJlbnQgcmVnaXN0cmFudCB1bmRlciB0aGUgTG9iYnlpbmcgRGlzY2xvc3VyZSBBY3QsIG9yIGFuIGluZGl2aWR1YWwgd2hvIGlzIG5hbWVkIG9uIGEgY3VycmVudCByZWdpc3RyYXRpb24gb3IgcmVwb3J0IGZpbGVkIHVuZGVyIHRoZSBMb2JieWluZyBEaXNjbG9zdXJlIEFjdC4gU2VlIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwNC0yMi9DVVJSRU5UIzEwNC0yMlxcXCI+MTA0LjIyPC9hPi5cIn0se1widGVybVwiOlwiTG9iYnlpc3QvUmVnaXN0cmFudCBQQUNcIixcImRlZmluaXRpb25cIjpcIkFueSBwb2xpdGljYWwgY29tbWl0dGVlIGVzdGFibGlzaGVkIG9yIGNvbnRyb2xsZWQgYnkgYSBwZXJzb24gd2hvIGlzIGEgY3VycmVudCByZWdpc3RyYW50IHVuZGVyIExvYmJ5aW5nIERpc2Nsb3N1cmUgQWN0IG9yIGFuIGluZGl2aWR1YWwgd2hvIGlzIG5hbWVkIG9uIGEgY3VycmVudCByZWdpc3RyYXRpb24gb3IgcmVwb3J0IGZpbGVkIHVuZGVyIHRoZSBMb2JieWluZyBEaXNjbG9zdXJlIEFjdC5cIn0se1widGVybVwiOlwiTG9jYWwgb3IgZGlzdHJpY3QgcGFydHkgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBIHBvbGl0aWNhbCBjb21taXR0ZWUgdGhhdCwgYnkgdmlydHVlIG9mIHRoZSBieWxhd3Mgb2YgYSBwb2xpdGljYWwgcGFydHksIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZGF5LXRvLWRheSBvcGVyYXRpb24gb2YgYSBwb2xpdGljYWwgcGFydHkgYXQgYSBsZXZlbCBsb3dlciB0aGFuIHRoZSBzdGF0ZSBsZXZlbCAoZS5nLiwgY2l0eSwgY291bnR5LCB3YXJkKS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTE0L0NVUlJFTlQjMTAwLTE0LWJcXFwiPjEwMC4xNChiKTwvYT4uXCJ9LHtcInRlcm1cIjpcIkxvY2FsIHBhcnR5IG9yZ2FuaXphdGlvblwiLFwiZGVmaW5pdGlvblwiOlwiQSBsb2NhbCBwYXJ0eSBvcmdhbml6YXRpb24gaXMgYW4gb3JnYW5pemF0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGEgcG9saXRpY2FsIHBhcnR5J3MgYWN0aXZpdGllcyBiZWxvdyB0aGUgc3RhdGUgbGV2ZWwgKHN1Y2ggYXMgY2l0eSwgY291bnR5IG9yIGRpc3RyaWN0IGxldmVsKSBidXQgaXMgbm90IHJlZ2lzdGVyZWQgd2l0aCB0aGUgRmVkZXJhbCBFbGVjdGlvbiBDb21taXNzaW9uIGFzIGEgZGlzdHJpY3Qgb3IgbG9jYWwgcGFydHkgY29tbWl0dGVlLlwifSx7XCJ0ZXJtXCI6XCJNYWpvciBwYXJ0eVwiLFwiZGVmaW5pdGlvblwiOlwiQSBwb2xpdGljYWwgcGFydHkgd2hvc2UgY2FuZGlkYXRlIGluIHRoZSBwcmVjZWRpbmcgcHJlc2lkZW50aWFsIGVsZWN0aW9uIHJlY2VpdmVkLCBhcyB0aGUgY2FuZGlkYXRlIG9mIHN1Y2ggcGFydHksIDI1IHBlcmNlbnQgb3IgbW9yZSBvZiB0aGUgcG9wdWxhciB2b3RlLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy85MDAyLTYvQ1VSUkVOVCM5MDAyLTZcXFwiPjkwMDIuNjwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvOTAwOC0yL0NVUlJFTlQjOTAwOC0yXFxcIj45MDA4LjIoYyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJNYXR0ZXIgVW5kZXIgUmV2aWV3IChNVVIpXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBGRUMgZW5mb3JjZW1lbnQgYWN0aW9uLCBpbml0aWF0ZWQgYnkgYSBzd29ybiBjb21wbGFpbnQgb3IgYnkgYW4gaW50ZXJuYWwgYWRtaW5pc3RyYXRpdmUgYWN0aW9uLlwifSx7XCJ0ZXJtXCI6XCJNZW1iZXJcIixcImRlZmluaXRpb25cIjpcIldpdGggcmVzcGVjdCB0byBhIGxhYm9yIG9yZ2FuaXphdGlvbiwgYSB0cmFkZSBhc3NvY2lhdGlvbiwgYSBjb29wZXJhdGl2ZSBvciBvdGhlciBpbmNvcnBvcmF0ZWQgbWVtYmVyc2hpcCBvcmdhbml6YXRpb24sIGEgbWVtYmVyIGlzIGFuIGluZGl2aWR1YWwgb3Igb3RoZXIgZW50aXR5IHRoYXQ6IDx1bD48bGk+U2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgZm9yIG1lbWJlcnNoaXAgaW4gYSBtZW1iZXJzaGlwIG9yZ2FuaXphdGlvbjs8L2xpPjxsaT4gYWZmaXJtYXRpdmVseSBhY2NlcHRzIHRoZSBvcmdhbml6YXRpb27igJlzIGludml0YXRpb24gdG8gYmVjb21lIGEgbWVtYmVyOyBhbmQ8L2xpPjxsaT5tYWludGFpbnMgYSBsb25nLXRlcm0gYW5kIGNvbnRpbnVvdXMgYm9uZCB3aXRoIHRoZSBvcmdhbml6YXRpb24gYnk6PHVsPjxsaT5oYXZpbmcgYSBzaWduaWZpY2FudCBmaW5hbmNpYWwgYXR0YWNobWVudCwgc3VjaCBhcyBhIHNpZ25pZmljYW50IGludmVzdG1lbnQgb3Igb3duZXJzaGlwIHN0YWtlOzwvbGk+PGxpPnBheWluZyBhbm51YWwgZHVlczsgb3I8L2xpPjxsaT5oYXZpbmcgZGlyZWN0IHBhcnRpY2lwYXRvcnkgcmlnaHRzIGluIHRoZSBnb3Zlcm5hbmNlIG9mIHRoZSBvcmdhbml6YXRpb24uPC9saT48L3VsPjwvbGk+PC91bD4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTEvQ1VSUkVOVCMxMTQtMS1lLTJcXFwiPjExNC4xKGUpKDIpPC9hPi5cIn0se1widGVybVwiOlwiTWVtYmVyc2hpcCBvcmdhbml6YXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgbGFib3Igb3JnYW5pemF0aW9uIG9yIGEgdHJhZGUgYXNzb2NpYXRpb24sIGNvb3BlcmF0aXZlIG9yIG90aGVyIGluY29ycG9yYXRlZCBtZW1iZXJzaGlwIG9yZ2FuaXphdGlvbiB0aGF0Ojx1bD48bGk+aXMgY29tcG9zZWQgb2YgbWVtYmVyczs8L2xpPjxsaT5leHByZXNzbHkgc3RhdGVzIHRoZSBxdWFsaWZpY2F0aW9ucyBmb3IgbWVtYmVyc2hpcCBpbiBpdHMgYXJ0aWNsZXMgYW5kIGJ5LWxhd3M7PC9saT48bGk+bWFrZXMgaXRzIGFydGljbGVzLCBieS1sYXdzIGFuZCBvdGhlciBvcmdhbml6YXRpb25hbCBkb2N1bWVudHMgYXZhaWxhYmxlIHRvIGl0cyBtZW1iZXJzOzwvbGk+PGxpPmV4cHJlc3NseSBzZWVrcyBtZW1iZXJzOzwvbGk+PGxpPmFja25vd2xlZGdlcyB0aGUgYWNjZXB0YW5jZSBvZiBtZW1iZXJzaGlwLCBzdWNoIGFzIGJ5IHNlbmRpbmcgbWVtYmVyc2hpcCBjYXJkcyB0byBuZXcgbWVtYmVycyBvciBpbmNsdWRpbmcgdGhlbSBvbiBhIG1lbWJlcnNoaXAgbmV3c2xldHRlciBsaXN0OyBhbmQ8L2xpPjxsaT5pcyBub3Qgb3JnYW5pemVkIHByaW1hcmlseSBmb3IgdGhlIHB1cnBvc2Ugb2YgaW5mbHVlbmNpbmcgYSBmZWRlcmFsIGVsZWN0aW9uLjwvbGk+PC91bD4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTEzNC9DVVJSRU5UIzEwMC0xMzQtZVxcXCI+MTAwLjEzNChlKTwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTEvQ1VSUkVOVCMxMTQtMS1lXFxcIj4xMTQuMShlKSgxKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk1lbW8gZW50cnkvbWVtbyBpdGVtXCIsXCJkZWZpbml0aW9uXCI6XCJTdXBwbGVtZW50YWwgb3IgZXhwbGFuYXRvcnkgaW5mb3JtYXRpb24gb24gYSByZXBvcnRpbmcgc2NoZWR1bGUuIEEgbWVtbyBlbnRyeSBpcyBvZnRlbiB1c2VkIHRvIGRpc2Nsb3NlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYW4gaXRlbWl6ZWQgdHJhbnNhY3Rpb24gdGhhdCBpcyBpbmNsdWRlZCBpbiB0aGUgdG90YWwgcmVjZWlwdHMgb3IgZGlzYnVyc2VtZW50cyBmb3IgdGhlIGN1cnJlbnQgcmVwb3J0IG9yIGEgcHJldmlvdXMgcmVwb3J0LiBUaGUgZG9sbGFyIGFtb3VudCBpbiBhIG1lbW8gZW50cnkgaXMgbm90IGluY29ycG9yYXRlZCBpbnRvIHRoZSB0b3RhbCBmaWd1cmUgZm9yIHRoZSBzY2hlZHVsZS5cIn0se1widGVybVwiOlwiTWVtbyB0ZXh0XCIsXCJkZWZpbml0aW9uXCI6XCJBIGZpZWxkIG9mZmVyZWQgaW4gRkVDRmlsZSBzb2Z0d2FyZSBhbmQgc29tZSBjb21tZXJjaWFsIHNvZnR3YXJlIHRvIGFsbG93IGEgY29tbWl0dGVlIHRvIHByb3ZpZGUgYWRkaXRpb25hbCB0ZXh0IHRvIGRlc2NyaWJlIGEgcGFydGljdWxhciB0cmFuc2FjdGlvbiBpdCBpcyByZXBvcnRpbmcuXCJ9LHtcInRlcm1cIjpcIk11bHRpY2FuZGlkYXRlIGNvbW1pdHRlZVwiLFwiZGVmaW5pdGlvblwiOlwiQSBwb2xpdGljYWwgYWN0aW9uIGNvbW1pdHRlZSBvciBwYXJ0eSBjb21taXR0ZWUgdGhhdCBoYXMgYmVlbiByZWdpc3RlcmVkIGF0IGxlYXN0IDYgbW9udGhzLCBoYXMgbW9yZSB0aGFuIDUwIGNvbnRyaWJ1dG9ycyBhbmQsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBzdGF0ZSBwYXJ0eSBjb21taXR0ZWVzLCBoYXMgbWFkZSBjb250cmlidXRpb25zIHRvIGF0IGxlYXN0IDUgY2FuZGlkYXRlcyBmb3IgZmVkZXJhbCBvZmZpY2UuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC01L0NVUlJFTlQjMTAwLTUtZS0zXFxcIj4xMDAuNShlKSgzKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk5hdGlvbmFsIGJhbmtcIixcImRlZmluaXRpb25cIjpcIkEgYmFuayB0aGF0IGlzIHN1YmplY3QgdG8gdGhlIHN1cGVydmlzaW9uIG9mIHRoZSA8YSBocmVmPVxcXCJodHRwczovL3d3dy5oZWxwd2l0aG15YmFuay5nb3YvZGljdGlvbmFyeS9pbmRleC1kaWN0aW9uYXJ5Lmh0bWwjTlxcXCI+Q29tcHRyb2xsZXIgb2YgdGhlIEN1cnJlbmN5PC9hPi4gVGhlIE9mZmljZSBvZiB0aGUgQ29tcHRyb2xsZXIgb2YgdGhlIEN1cnJlbmN5IGlzIGEgYnVyZWF1IG9mIHRoZSBVLlMuIFRyZWFzdXJ5IERlcGFydG1lbnQuXCJ9LHtcInRlcm1cIjpcIk5hdGlvbmFsIGNvbW1pdHRlZVwiLFwiZGVmaW5pdGlvblwiOlwiQW4gb3JnYW5pemF0aW9uIHRoYXQsIGJ5IHZpcnR1ZSBvZiB0aGUgYnlsYXdzIG9mIGEgcG9saXRpY2FsIHBhcnR5LCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGRheS10by1kYXkgb3BlcmF0aW9uIG9mIHRoZSBwb2xpdGljYWwgcGFydHkgYXQgdGhlIG5hdGlvbmFsIGxldmVsLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBDb21taXNzaW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMTMvQ1VSUkVOVCMxMDAtMTNcXFwiPjEwMC4xMzwvYT4uXCJ9LHtcInRlcm1cIjpcIk5hdGlvbmFsIHBhcnR5IGNvbW1pdHRlZVwiLFwiZGVmaW5pdGlvblwiOlwiQSBwb2xpdGljYWwgY29tbWl0dGVlIGVzdGFibGlzaGVkIGFuZCBtYWludGFpbmVkIGJ5IGEgbmF0aW9uYWwgcG9saXRpY2FsIHBhcnR5LiBBIHBhcnR54oCZcyBuYXRpb25hbCBjb21taXR0ZWUsIEhvdXNlIGNhbXBhaWduIGNvbW1pdHRlZSBhbmQgU2VuYXRlIGNhbXBhaWduIGNvbW1pdHRlZSBhcmUgY29uc2lkZXJlZCBuYXRpb25hbCBwYXJ0eSBjb21taXR0ZWVzLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBDb21taXNzaW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTAtMS9DVVJSRU5UIzExMC0xLWMtMlxcXCI+MTEwLjEoYykoMik8L2E+OyA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMC0yL0NVUlJFTlQjMTEwLTItYy0yXFxcIj4xMTAuMihjKSgyKTwvYT47IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTMvQ1VSUkVOVCMxMTAtMy1iLTEtaWlcXFwiPjExMC4zKGIpKDIpPC9hPi5cIn0se1widGVybVwiOlwiTmV0IGRlYnRzIG91dHN0YW5kaW5nXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgdG90YWwgb2YgYSBjYW1wYWlnbuKAmXMgdW5wYWlkIGRlYnRzIGluY3VycmVkIHdpdGggcmVzcGVjdCB0byBhbiBlbGVjdGlvbiBwbHVzIGVzdGltYXRlZCBjb3N0cyB0byBsaXF1aWRhdGUgdGhlIGRlYnRzIHBsdXMgY29zdHMgb2YgdGVybWluYXRpbmcgcG9saXRpY2FsIGFjdGl2aXR5IChpZiBhcHByb3ByaWF0ZSkgbWludXMgY2FzaCBvbiBoYW5kIGFuZCByZWNlaXZhYmxlcy4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTEvQ1VSUkVOVCMxMTAtMS1iLTMtaWlcXFwiPjExMC4xKGIpKDMpKGlpKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk5vbmNvbm5lY3RlZCBjb21taXR0ZWVcIixcImRlZmluaXRpb25cIjpcIkFueSBjb21taXR0ZWUgdGhhdCBjb25kdWN0cyBhY3Rpdml0aWVzIGluIGNvbm5lY3Rpb24gd2l0aCBhbiBlbGVjdGlvbiwgYnV0IHRoYXQgaXMgbm90IGEgcGFydHkgY29tbWl0dGVlLCBhbiBhdXRob3JpemVkIGNvbW1pdHRlZSBvZiBhbnkgY2FuZGlkYXRlIGZvciBmZWRlcmFsIGVsZWN0aW9uLCBvciBhIHNlcGFyYXRlIHNlZ3JlZ2F0ZWQgZnVuZC4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTYvQ1VSUkVOVCMxMDAtNlxcXCI+MTA2LjYoYSk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJOb24tY29udHJpYnV0aW9uIGFjY291bnRcIixcImRlZmluaXRpb25cIjpcIkEgc2VwYXJhdGUgYmFuayBhY2NvdW50IHRvIGRlcG9zaXQgYW5kIHdpdGhkcmF3IGZ1bmRzIHJhaXNlZCBpbiB1bmxpbWl0ZWQgYW1vdW50cyBmcm9tIGluZGl2aWR1YWxzLCBjb3Jwb3JhdGlvbnMsIGxhYm9yIG9yZ2FuaXphdGlvbnMgYW5kL29yIG90aGVyIHBvbGl0aWNhbCBjb21taXR0ZWVzLCBjb25zaXN0ZW50IHdpdGggdGhlIHN0aXB1bGF0ZWQganVkZ21lbnQgaW4gPGk+Q2FyZXkgdi4gRkVDPC9pPi4gVGhlIGZ1bmRzIG1haW50YWluZWQgaW4gdGhpcyBzZXBhcmF0ZSBhY2NvdW50IHdpbGwgbm90IGJlIHVzZWQgdG8gbWFrZSBjb250cmlidXRpb25zLCB3aGV0aGVyIGRpcmVjdCwgaW4ta2luZCBvciB2aWEgY29vcmRpbmF0ZWQgY29tbXVuaWNhdGlvbnMsIG9yIGNvb3JkaW5hdGVkIGV4cGVuZGl0dXJlcywgdG8gZmVkZXJhbCBjYW5kaWRhdGVzIG9yIGNvbW1pdHRlZXMuXCJ9LHtcInRlcm1cIjpcIk5vbmVcIixcImRlZmluaXRpb25cIjpcIklmIGRhdGEgYXBwZWFycyBhcyBcXFwiTm9uZVxcXCIsIGl0J3MgYmVzdCB0byBjaGVjayB0aGUgc291cmNlIGRvY3VtZW50LiBDb21tb24gcmVhc29ucyB0aGF0IHRoZSBkYXRhIGFwcGVhcnMgYXMgXFxcIk5vbmVcXFwiIGFyZTo8dWw+PGxpPkRhdGEgaXMgbm90IHByb2Nlc3NlZCB5ZXQ7IG9mdGVuLCBwYXBlciBmaWxpbmdzIGNhdXNlIGRlbGF5cyBhbmQgaW5jb25zaXN0ZW50IHVwbG9hZCB0aW1lcy48L2xpPjxsaT5EYXRhIGlzIGZyb20gYW4gYW1lbmRtZW50IHRoYXQgZGlkIG5vdCBwcm9wZXJseSBpZGVudGlmeSB0aGUgZm9ybSBpdCB3YXMgYW1lbmRpbmcuPC9saT48bGk+VGhlIGZpbGVyIGRpZCBub3QgZmlsbCBvdXQgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSBmb3JtLjwvbGk+PC91bD5JZiB5b3UgdGhpbmsgdGhlcmUgaXMgYW4gZXJyb3IsIHlvdSBjYW4gcmVwb3J0IHRoYXQgdmlhIG91ciBmZWVkYmFjayB0b29sLlwifSx7XCJ0ZXJtXCI6XCJOb25mZWRlcmFsIGZ1bmRzXCIsXCJkZWZpbml0aW9uXCI6XCJGdW5kcyB0aGF0IGFyZSBub3Qgc3ViamVjdCB0byB0aGUgbGltaXRhdGlvbnMgb3IgcHJvaGliaXRpb25zIG9mIHRoZSBGZWRlcmFsIEVsZWN0aW9uIENhbXBhaWduIEFjdC4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMzAwLTIvQ1VSUkVOVCMzMDAtMi1rXFxcIj4zMDAuMihrKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk9jY3VwYXRpb25cIixcImRlZmluaXRpb25cIjpcIlRoZSBwcmluY2lwYWwgam9iIHRpdGxlIG9yIHBvc2l0aW9uIG9mIGFuIGluZGl2aWR1YWwgYW5kIHdoZXRoZXIgb3Igbm90IHNlbGYtZW1wbG95ZWQuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yMC9DVVJSRU5UIzEwMC0yMFxcXCI+MTAwLjIwPC9hPi5cIn0se1widGVybVwiOlwiT25lLXRoaXJkIHJ1bGVcIixcImRlZmluaXRpb25cIjpcIkEgZm9ybXVsYSB1c2VkIHRvIGVuc3VyZSB0aGUgdHJlYXN1cnkgZnVuZHMgb2YgYSBjb25uZWN0ZWQgb3JnYW5pemF0aW9uIGFyZSBub3QgdHJhZGVkIGZvciB2b2x1bnRhcnkgY29udHJpYnV0aW9ucyB3aGVuIHRoZSBvcmdhbml6YXRpb24gcGF5cyBmb3IgcHJpemVzIG9yIGVudGVydGFpbm1lbnQgdG8gb2ZmZXIgYXMgYW4gaW5jZW50aXZlIHRvIG1ha2UgYSBjb250cmlidXRpb24gdG8gaXRzIFNTRi4gVW5kZXIgdGhlIG9uZS10aGlyZCBydWxlLCB0aGUgU1NGIG11c3QgcmVpbWJ1cnNlIHRoZSBjb25uZWN0ZWQgb3JnYW5pemF0aW9uIGZvciBjb3N0cyB0aGF0IGV4Y2VlZCBvbmUtdGhpcmQgb2YgdGhlIG1vbmV5IHJhaXNlZC4gU2VlIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNC01L0NVUlJFTlQjMTE0LTUtYi0yXFxcIj4xMTQuNShiKSgyKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk9uZ29pbmcgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBbnkgcG9saXRpY2FsIGNvbW1pdHRlZSB0aGF0IGhhcyBub3QgdGVybWluYXRlZCBhbmQgZG9lcyBub3QgcXVhbGlmeSBhcyBhIHRlcm1pbmF0aW5nIGNvbW1pdHRlZS4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE2LTEvQ1VSUkVOVCMxMTYtMS1iXFxcIj4xMTYuMShiKTwvYT4uXCJ9LHtcInRlcm1cIjpcIk9wZXJhdGluZyBleHBlbmRpdHVyZXNcIixcImRlZmluaXRpb25cIjpcIkEgY29tbWl0dGVlJ3MgZGF5LXRvLWRheSBleHBlbmRpdHVyZXMgZm9yIGl0ZW1zIHN1Y2ggYXMgcmVudCwgb3ZlcmhlYWQsIGFkbWluaXN0cmF0aW9uLCBwZXJzb25uZWwsIGVxdWlwbWVudCwgdHJhdmVsLCBhZHZlcnRpc2luZyBhbmQgZnVuZHJhaXNpbmcuXCJ9LHtcInRlcm1cIjpcIk9yZGluYXJ5IGNvdXJzZSBvZiBidXNpbmVzc1wiLFwiZGVmaW5pdGlvblwiOlwiSW4gZGV0ZXJtaW5pbmcgd2hldGhlciBjcmVkaXQgd2FzIGV4dGVuZGVkIGluIHRoZSBvcmRpbmFyeSBjb3Vyc2Ugb2YgYnVzaW5lc3MsIHRoZSBDb21taXNzaW9uIHdpbGwgY29uc2lkZXLigJQ8dWwgY2xhc3M9J2xpc3QtYnVsbGV0ZWQnPjxsaT5XaGV0aGVyIHRoZSBjb21tZXJjaWFsIHZlbmRvciBmb2xsb3dlZCBpdHMgZXN0YWJsaXNoZWQgcHJvY2VkdXJlcyBhbmQgaXRzIHBhc3QgcHJhY3RpY2UgaW4gYXBwcm92aW5nIHRoZSBleHRlbnNpb24gb2YgY3JlZGl0OzwvbGk+PGxpPldoZXRoZXIgdGhlIGNvbW1lcmNpYWwgdmVuZG9yIHJlY2VpdmVkIHByb21wdCBwYXltZW50IGluIGZ1bGwgaWYgaXQgcHJldmlvdXNseSBleHRlbmRlZCBjcmVkaXQgdG8gdGhlIHNhbWUgY2FuZGlkYXRlIG9yIHBvbGl0aWNhbCBjb21taXR0ZWU7IGFuZDwvbGk+PGxpPldoZXRoZXIgdGhlIGV4dGVuc2lvbiBvZiBjcmVkaXQgY29uZm9ybWVkIHRvIHRoZSB1c3VhbCBhbmQgbm9ybWFsIHByYWN0aWNlIGluIHRoZSBjb21tZXJjaWFsIHZlbmRvcidzIHRyYWRlIG9yIGluZHVzdHJ5LiA8L2xpPjwvdWw+IDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNi0zL0NVUlJFTlQjMTE2LTMtY1xcXCI+MTE2LjMoYyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJPcmdhbml6YXRpb24gdHlwZVwiLFwiZGVmaW5pdGlvblwiOlwiQ2VydGFpbiBmaWxlcnMsIGxpa2Ugc2VwYXJhdGUgc2VncmVnYXRlZCBmdW5kcyBhbmQgY29tbXVuaWNhdGlvbiBjb3N0IGZpbGVycywgaWRlbnRpZnkgdGhlIHR5cGVzIG9mIG9yZ2FuaXphdGlvbnMgdGhleSBhcmUgY29ubmVjdGVkIHdpdGguIFRoZXNlIGNvbm5lY3RlZCBvcmdhbml6YXRpb25zIGNhbiBiZSBpZGVudGlmaWVkIGFzIGNvcnBvcmF0aW9ucywgdHJhZGUgYXNzb2NpYXRpb25zLCBsYWJvciBvcmdhbml6YXRpb25zLCBjb29wZXJhdGl2ZXMsIG1lbWJlcnNoaXAgb3JnYW5pemF0aW9ucyBvciBjb3Jwb3JhdGlvbnMgd2l0aG91dCBjYXBpdGFsIHN0b2NrLlwifSx7XCJ0ZXJtXCI6XCJPdmVybmlnaHQgZGVsaXZlcnkgc2VydmljZVwiLFwiZGVmaW5pdGlvblwiOlwiQSBwcml2YXRlIGRlbGl2ZXJ5IHNlcnZpY2UgYnVzaW5lc3Mgb2YgZXN0YWJsaXNoZWQgcmVsaWFiaWxpdHkgdGhhdCBvZmZlcnMgYW4gb3Zlcm5pZ2h0IChuZXh0IGJ1c2luZXNzIGRheSkgZGVsaXZlcnkgb3B0aW9uLlwifSx7XCJ0ZXJtXCI6XCJQYXJ0eSBjb21taXR0ZWVcIixcImRlZmluaXRpb25cIjpcIkEgcG9saXRpY2FsIGNvbW1pdHRlZSB0aGF0IHJlcHJlc2VudHMgYSBwb2xpdGljYWwgcGFydHkgYW5kIGlzIHBhcnQgb2YgdGhlIG9mZmljaWFsIHBhcnR5IHN0cnVjdHVyZSBhdCB0aGUgbmF0aW9uYWwsIHN0YXRlIG9yIGxvY2FsIGxldmVsLlwifSx7XCJ0ZXJtXCI6XCJQQVNPXCIsXCJkZWZpbml0aW9uXCI6XCJQQVNPIGlzIGFuIGFjcm9ueW0gdGhhdCBzdGFuZHMgZm9yIOKAnFByb21vdGUsIEF0dGFjaywgU3VwcG9ydCBvciBPcHBvc2Uu4oCdIFNlZSwgZS5nLiwgMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTI0L0NVUlJFTlQjMTAwLTI0LWItM1xcXCI+MTAwLjI0KGIpKDMpPC9hPi5cIn0se1widGVybVwiOlwiUGVyc29uXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBpbmRpdmlkdWFsLCBwYXJ0bmVyc2hpcCwgcG9saXRpY2FsIGNvbW1pdHRlZSwgY29ycG9yYXRpb24sIGxhYm9yIG9yZ2FuaXphdGlvbiBvciBhbnkgb3RoZXIgb3JnYW5pemF0aW9uIG9yIGdyb3VwIG9mIHBlcnNvbnMsIG5vdCBpbmNsdWRpbmcgdGhlIGZlZGVyYWwgZ292ZXJubWVudC4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTEwL0NVUlJFTlQjMTAwLTEwXFxcIj4xMDAuMTA8L2E+LlwifSx7XCJ0ZXJtXCI6XCJQZXJzb25hbCBmdW5kcyBvZiBhIGNhbmRpZGF0ZVwiLFwiZGVmaW5pdGlvblwiOlwiVGhlIHBlcnNvbmFsIGZ1bmRzIG9mIGEgY2FuZGlkYXRlIGluY2x1ZGU6IDx1bCBjbGFzcz0nbGlzdC1idWxsZXRlZCc+PGxpPkFzc2V0cyB3aGljaCB0aGUgY2FuZGlkYXRlIGhhcyBhIGxlZ2FsIHJpZ2h0IG9mIGFjY2VzcyB0byBvciBjb250cm9sIG92ZXIsIGFuZCB3aGljaCBoZSBvciBzaGUgaGFzIGxlZ2FsIHRpdGxlIHRvIG9yIGFuIGVxdWl0YWJsZSBpbnRlcmVzdCBpbiwgYXQgdGhlIHRpbWUgb2YgY2FuZGlkYWN5OzwvbGk+PGxpPkluY29tZSBmcm9tIGVtcGxveW1lbnQ7PC9saT48bGk+RGl2aWRlbmRzIGFuZCBpbnRlcmVzdCBmcm9tLCBhbmQgcHJvY2VlZHMgZnJvbSBzYWxlIG9yIGxpcXVpZGF0aW9uIG9mLCBzdG9ja3MgYW5kIG90aGVyIGludmVzdG1lbnRzOzwvbGk+PGxpPkluY29tZSBmcm9tIHRydXN0cywgaWYgZXN0YWJsaXNoZWQgYmVmb3JlIHRoZSBlbGVjdGlvbiBjeWNsZTs8L2xpPjxsaT5JbmNvbWUgZnJvbSB0cnVzdHMgZXN0YWJsaXNoZWQgYnkgYmVxdWVzdHMgKGV2ZW4gYWZ0ZXIgY2FuZGlkYWN5KTwvbGk+PGxpPkJlcXVlc3RzIHRvIHRoZSBjYW5kaWRhdGU7PC9saT48bGk+UGVyc29uYWwgZ2lmdHMgdGhhdCBoYWQgYmVlbiBjdXN0b21hcmlseSByZWNlaXZlZCBieSB0aGUgY2FuZGlkYXRlIHByaW9yIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGVsZWN0aW9uIGN5Y2xlOyBhbmQ8L2xpPjxsaT5Qcm9jZWVkcyBmcm9tIGxvdHRlcmllcyBhbmQgc2ltaWxhciBnYW1lcyBvZiBjaGFuY2UuPC9saT48L3VsPiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMzMvQ1VSUkVOVCMxMDAtMzNcXFwiPjEwMC4zMyhhKSBhbmQgKGIpPC9hPi5cIn0se1widGVybVwiOlwiUG9saXRpY2FsIEFjdGlvbiBDb21taXR0ZWUgKFBBQylcIixcImRlZmluaXRpb25cIjpcIlBvcHVsYXIgdGVybSBmb3IgYSBwb2xpdGljYWwgY29tbWl0dGVlIHRoYXQgaXMgbmVpdGhlciBhIHBhcnR5IGNvbW1pdHRlZSBub3IgYW4gYXV0aG9yaXplZCBjb21taXR0ZWUgb2YgYSBjYW5kaWRhdGUuIFBBQ3MgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBlc3RhYmxpc2hlZCwgYWRtaW5pc3RlcmVkIG9yIGZpbmFuY2lhbGx5IHN1cHBvcnRlZCBieSBhIGNvcnBvcmF0aW9uIG9yIGxhYm9yIG9yZ2FuaXphdGlvbiBhcmUgY2FsbGVkIHNlcGFyYXRlIHNlZ3JlZ2F0ZWQgZnVuZHMgKFNTRnMpLiBQQUNzIHdpdGhvdXQgc3VjaCBhIGNvcnBvcmF0ZSBvciBsYWJvciBzcG9uc29yIGFyZSBjYWxsZWQgbm9uY29ubmVjdGVkIFBBQ3MuXCJ9LHtcInRlcm1cIjpcIlBvbGl0aWNhbCBjb21taXR0ZWVcIixcImRlZmluaXRpb25cIjpcIkFuIGVudGl0eSB0aGF0IG1lZXRzIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6PHVsPjxsaT5BbiBhdXRob3JpemVkIGNvbW1pdHRlZSBvZiBhIGNhbmRpZGF0ZSAoc2VlIGRlZmluaXRpb24gb2YgY2FuZGlkYXRlKTwvbGk+PGxpPkFueSBjbHViLCBhc3NvY2lhdGlvbiBvciBvdGhlciBncm91cCBvZiBwZXJzb25zIHRoYXQgcmVjZWl2ZXMgY29udHJpYnV0aW9ucyBvciBtYWtlcyBleHBlbmRpdHVyZXMsIGVpdGhlciBvZiB3aGljaCBhZ2dyZWdhdGUgb3ZlciAkMSwwMDAgZHVyaW5nIGEgY2FsZW5kYXIgeWVhcjwvbGk+PGxpPkEgbG9jYWwgdW5pdCBvZiBhIHBvbGl0aWNhbCBwYXJ0eSAoZXhjZXB0IGEgc3RhdGUgcGFydHkgY29tbWl0dGVlKSB0aGF0OiAoMSkgcmVjZWl2ZXMgY29udHJpYnV0aW9ucyBhZ2dyZWdhdGluZyBvdmVyICQ1LDAwMCBkdXJpbmcgYSBjYWxlbmRhciB5ZWFyOyAoMikgbWFrZXMgY29udHJpYnV0aW9ucyBvciBleHBlbmRpdHVyZXMgZWl0aGVyIG9mIHdoaWNoIGFnZ3JlZ2F0ZSBvdmVyICQxLDAwMCBkdXJpbmcgYSBjYWxlbmRhciB5ZWFyIG9yICgzKSBtYWtlcyBwYXltZW50cyBhZ2dyZWdhdGluZyBvdmVyICQ1LDAwMCBkdXJpbmcgYSBjYWxlbmRhciB5ZWFyIGZvciBjZXJ0YWluIGFjdGl2aXRpZXMgdGhhdCBhcmUgZXhlbXB0IGZyb20gdGhlIGRlZmluaXRpb25zIG9mIGNvbnRyaWJ1dGlvbiBhbmQgZXhwZW5kaXR1cmUgKDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC04MC9DVVJSRU5UIzEwMC04MFxcXCI+MTAwLjgwPC9hPiwgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtODcvQ1VSUkVOVCMxMDAtODdcXFwiPjEwMC44NzwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTg5L0NVUlJFTlQjMTAwLTg5XFxcIj4xMDAuODk8L2E+OyAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMTQwL0NVUlJFTlQjMTAwLTE0MFxcXCI+MTAwLjE0MDwvYT4sIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTE0MC9DVVJSRU5UIzEwMC0xNDc+MTAwLjE0NzwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTE0OS9DVVJSRU5UIzEwMC0xNDlcXFwiPjEwMC4xNDk8L2E+KS48L2xpPjxsaT5Bbnkgc2VwYXJhdGUgc2VncmVnYXRlZCBmdW5kIHVwb24gaXRzIGVzdGFibGlzaG1lbnQuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC01L0NVUlJFTlQjMTAwLTUtYlxcXCI+MTAwLjU8L2E+LjwvbGk+PC91bD5cIn0se1widGVybVwiOlwiUG9saXRpY2FsIHBhcnR5XCIsXCJkZWZpbml0aW9uXCI6XCJBbiBhc3NvY2lhdGlvbiwgY29tbWl0dGVlIG9yIG9yZ2FuaXphdGlvbiB0aGF0IG5vbWluYXRlcyBvciBzZWxlY3RzIGEgY2FuZGlkYXRlIGZvciBlbGVjdGlvbiB0byBmZWRlcmFsIG9mZmljZSB3aG9zZSBuYW1lIGFwcGVhcnMgb24gdGhlIGVsZWN0aW9uIGJhbGxvdCBhcyB0aGUgY2FuZGlkYXRlIG9mIHRoZSBvcmdhbml6YXRpb24uXCJ9LHtcInRlcm1cIjpcIlBvc3RtYXJrZWRcIixcImRlZmluaXRpb25cIjpcIkEgVS5TLiBQb3N0YWwgU2VydmljZSBwb3N0bWFyayBvciB0aGUgdmVyaWZpYWJsZSBkYXRlIG9mIGRlcG9zaXQgd2l0aCBhbiBvdmVybmlnaHQgZGVsaXZlcnkgc2VydmljZS5cIn0se1widGVybVwiOlwiUHJlc2lkZW50aWFsIHB1YmxpYyBmdW5kc1wiLFwiZGVmaW5pdGlvblwiOlwiUHVibGljIGZ1bmRpbmcgb2YgcHJlc2lkZW50aWFsIGVsZWN0aW9ucyBtZWFucyB0aGF0IHF1YWxpZmllZCBwcmVzaWRlbnRpYWwgY2FuZGlkYXRlcyBtYXkgY2hvb3NlIHRvIHJlY2VpdmUgZmVkZXJhbCBnb3Zlcm5tZW50IGZ1bmRzIHRvIHBheSBmb3IgY2VydGFpbiBleHBlbnNlcyBvZiB0aGVpciBwb2xpdGljYWwgY2FtcGFpZ25zIGluIGJvdGggdGhlIHByaW1hcnkgYW5kIGdlbmVyYWwgZWxlY3Rpb25zLiBQcmlvciB0byB0aGUgMjAxNiBwcmVzaWRlbnRpYWwgZWxlY3Rpb24sIG5hdGlvbmFsIHBvbGl0aWNhbCBwYXJ0aWVzIGNvdWxkIGFsc28gcmVjZWl2ZSBmZWRlcmFsIG1vbmV5IGZvciB0aGVpciBuYXRpb25hbCBub21pbmF0aW5nIGNvbnZlbnRpb25zLlwifSx7XCJ0ZXJtXCI6XCJQcmluY2lwYWwgY2FtcGFpZ24gY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBbiBhdXRob3JpemVkIGNvbW1pdHRlZSBkZXNpZ25hdGVkIGJ5IGEgY2FuZGlkYXRlIGFzIHRoZSBwcmluY2lwYWwgY29tbWl0dGVlIHRvIHJhaXNlIGNvbnRyaWJ1dGlvbnMgYW5kIG1ha2UgZXhwZW5kaXR1cmVzIGZvciBoaXMgb3IgaGVyIGNhbXBhaWduIGZvciBhIGZlZGVyYWwgb2ZmaWNlLlwifSx7XCJ0ZXJtXCI6XCJQcmlvciBhcHByb3ZhbFwiLFwiZGVmaW5pdGlvblwiOlwiQSB3cml0dGVuIHJlcXVlc3QgdG8gYSBtZW1iZXIgY29ycG9yYXRpb24gb2YgYSB0cmFkZSBhc3NvY2lhdGlvbiB0byBhIG1lbWJlciBjb3Jwb3JhdGlvbiBmb3IgcGVybWlzc2lvbiB0byBzb2xpY2l0IHRoZSBtZW1iZXLigJlzIHJlc3RyaWN0ZWQgY2xhc3MuIFRoaXMgcmVxdWVzdCBmb3IgYXBwcm92YWwgbXVzdCBpbmZvcm0gdGhlIG1lbWJlciBjb3Jwb3JhdGlvbiB0aGF0IGNvcnBvcmF0ZSBhcHByb3ZhbCBpcyBuZWNlc3NhcnkgYmVmb3JlIHRoZSB0cmFkZSBhc3NvY2lhdGlvbiBvciBpdHMgU1NGIG1heSBjb25kdWN0IGEgc29saWNpdGF0aW9uIGFuZCB0aGUgY29ycG9yYXRpb24gbWF5IG5vdCBhcHByb3ZlIHNvbGljaXRhdGlvbnMgYnkgYW5vdGhlciB0cmFkZSBhc3NvY2lhdGlvbiBmb3IgdGhlIHNhbWUgY2FsZW5kYXIgeWVhci4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTgvQ1VSUkVOVCMxMTQtOC1kLTNcXFwiPjExNC44KGQpKDMpPC9hPi5cIn0se1widGVybVwiOlwiUHVibGljIGNvbW11bmljYXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgY29tbXVuaWNhdGlvbiBieSBtZWFucyBvZiBhbnkgYnJvYWRjYXN0LCBjYWJsZSBvciBzYXRlbGxpdGUgY29tbXVuaWNhdGlvbiwgbmV3c3BhcGVyLCBtYWdhemluZSwgb3V0ZG9vciBhZHZlcnRpc2luZyBmYWNpbGl0eSwgbWFzcyBtYWlsaW5nIG9yIHRlbGVwaG9uZSBiYW5rIHRvIHRoZSBnZW5lcmFsIHB1YmxpYywgb3IgYW55IG90aGVyIGZvcm0gb2YgZ2VuZXJhbCBwdWJsaWMgcG9saXRpY2FsIGFkdmVydGlzaW5nLiBUaGUgdGVybSBnZW5lcmFsIHB1YmxpYyBwb2xpdGljYWwgYWR2ZXJ0aXNpbmcgZG9lcyBub3QgaW5jbHVkZSBjb21tdW5pY2F0aW9ucyBtYWRlIG92ZXIgdGhlIGludGVybmV0LCBleGNlcHQgZm9yIGNvbW11bmljYXRpb25zIHBsYWNlZCBmb3IgYSBmZWUgb24gYW5vdGhlciBwZXJzb27igJlzIHdlYnNpdGUuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yNi9DVVJSRU5UIzEwMC0yNlxcXCI+MTAwLjI2PC9hPiwgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjcvQ1VSUkVOVCMxMDAtMjdcXFwiPjEwMC4yNzwvYT4gKGRlZmluaXRpb24gb2YgbWFzcyBtYWlsaW5nKSBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMjgvQ1VSUkVOVCMxMDAtMjhcXFwiPjEwMC4yODwvYT4gKGRlZmluaXRpb24gb2YgdGVsZXBob25lIGJhbmspLlwifSx7XCJ0ZXJtXCI6XCJRdWFsaWZpZWQvbm9uLXF1YWxpZmllZFwiLFwiZGVmaW5pdGlvblwiOlwiSW4gdGhlIGNvbnRleHQgb2YgbXVsdGljYW5kaWRhdGUgcG9saXRpY2FsIGNvbW1pdHRlZXMgaWRlbnRpZmllZCBpbiBGRUMgZGF0YSByZXBvcnRzIGFuZCBpbmRpY2VzLCB0aGUgZGVzaWduYXRpb24g4oCccXVhbGlmaWVk4oCdIG9yIOKAnG5vbi1xdWFsaWZpZWTigJ0gcmVmbGVjdHMgd2hldGhlciBhIHBvbGl0aWNhbCBjb21taXR0ZWUgaGFzIHNhdGlzZmllZCB0aGUgY3JpdGVyaWEgZm9yIG11bHRpY2FuZGlkYXRlIHBvbGl0aWNhbCBjb21taXR0ZWUgc3RhdHVzIChpLmUuLCB3aGV0aGVyIHRoZSBjb21taXR0ZWUgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgYXQgbGVhc3QgNiBtb250aHMsIHJlY2VpdmVkIGNvbnRyaWJ1dGlvbnMgZnJvbSBtb3JlIHRoYW4gNTAgcGVyc29ucywgYW5kIG1hZGUgY29udHJpYnV0aW9ucyB0byA1IG9yIG1vcmUgZmVkZXJhbCBjYW5kaWRhdGVzKS4gQ29tbWl0dGVlcyBsaXN0ZWQgYXMg4oCcbm9uLXF1YWxpZmllZOKAnSBkbyBub3Qgc2F0aXNmeSB0aGVzZSByZXF1aXJlbWVudHMuIFNlZSAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtNS9DVVJSRU5UIzEwMC01LWUtM1xcXCI+MTAwLjUoZSkoMyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJSZWF0dHJpYnV0ZWQgY29udHJpYnV0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgcG9ydGlvbiBvZiBhbiBleGNlc3NpdmUgY29udHJpYnV0aW9uIHRoYXQgaGFzIGJlZW4gYXR0cmlidXRlZCBpbiB3cml0aW5nIHRvIGFub3RoZXIgY29udHJpYnV0b3IgYW5kIHNpZ25lZCBieSBib3RoIGNvbnRyaWJ1dG9ycy4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTEwLTEvQ1VSUkVOVCMxMTAtMS1rLTMtaWlcXFwiPjExMC4xKGspKDMpKGlpKTwvYT4uXCJ9LHtcInRlcm1cIjpcIlJlY2VpcHRcIixcImRlZmluaXRpb25cIjpcIkFueXRoaW5nIG9mIHZhbHVlIChtb25leSwgZ29vZHMsIHNlcnZpY2VzIG9yIHByb3BlcnR5KSByZWNlaXZlZCBieSBhIHBvbGl0aWNhbCBjb21taXR0ZWUuXCJ9LHtcInRlcm1cIjpcIlJlZGVzaWduYXRlZCBjb250cmlidXRpb25cIixcImRlZmluaXRpb25cIjpcIldpdGggcmVnYXJkIHRvIGNvbnRyaWJ1dGlvbnMgbWFkZSB0byBjYW5kaWRhdGVzLCB0aGUgcG9ydGlvbiBvZiBhIGNvbnRyaWJ1dGlvbiB0aGF0IGhhcyBiZWVuIGRlc2lnbmF0ZWQgYnkgdGhlIGNvbnRyaWJ1dG9yLCBpbiB3cml0aW5nLCB0byBhbiBlbGVjdGlvbiBvdGhlciB0aGFuIHRoZSBvbmUgZm9yIHdoaWNoIHRoZSBmdW5kcyB3ZXJlIG9yaWdpbmFsbHkgZ2l2ZW4uIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMC0xL0NVUlJFTlQjMTEwLTEtYi00LWlpaVxcXCI+MTEwLjEoYikoNSk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJSZWZ1bmRlZCBjb250cmlidXRpb25cIixcImRlZmluaXRpb25cIjpcIkEgY29udHJpYnV0aW9uIGlzIHJlZnVuZGVkIHdoZW4gdGhlIHJlY2lwaWVudCBjb21taXR0ZWUgZGVwb3NpdHMgdGhlIGNvbnRyaWJ1dGlvbiBhbmQgc2VuZHMgdGhlIGNvbnRyaWJ1dG9yIGEgY2hlY2sgZm9yIHRoZSBhbW91bnQgKG9yIGEgcG9ydGlvbikgb2YgdGhlIGNvbnRyaWJ1dGlvbi4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAzLTMvQ1VSUkVOVCMxMDMtMy1iXFxcIj4xMDMuMyhiKTwvYT4uXCJ9LHtcInRlcm1cIjpcIlJlcG9ydHMsIGRlc2lnbmF0aW9ucyBhbmQgc3RhdGVtZW50c1wiLFwiZGVmaW5pdGlvblwiOlwiQWxsIGNvbW1pdHRlZXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBGRUMgYW5kIG90aGVyIHBlcnNvbnMgd2hvIG1ha2UgY2VydGFpbiBleHBlbmRpdHVyZXMgb3IgZGlzYnVyc2VtZW50cyBhcmUgcmVxdWlyZWQgdG8gZmlsZSByZXBvcnRzLCBkZXNpZ25hdGlvbnMgYW5kIHN0YXRlbWVudHMgdGhhdCBkaXNjbG9zZSB0aGVpciBmaW5hbmNpYWwgYWN0aXZpdHkuIFRoZSBjb250ZW50cyBvZiB0aG9zZSByZXBvcnRzIGFuZCBzdGF0ZW1lbnRzLCBhcyB3ZWxsIGFzIHRoZSBmaWxpbmcgc2NoZWR1bGUsIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiBjb21taXR0ZWUgb3Igb3JnYW5pemF0aW9uLCBvciB0aGUgdHlwZSBvZiBleHBlbmRpdHVyZSBvciBkaXNidXJzZW1lbnQgbWFkZS4gIFNlZSBhbHNvIFxcXCJGaWxpbmcuXFxcIi5cIn0se1widGVybVwiOlwiUmVzdHJpY3RlZCBjbGFzcy9zb2xpY2l0YWJsZSBjbGFzc1wiLFwiZGVmaW5pdGlvblwiOlwiVGhvc2UgcGVyc29ucywgaW5jbHVkaW5nIHRoZSBleGVjdXRpdmUgYW5kIGFkbWluaXN0cmF0aXZlIHBlcnNvbm5lbCwgbWVtYmVycyBvciBzdG9ja2hvbGRlcnMgKGFuZCB0aGUgZmFtaWxpZXMgb2YgZWFjaCkgd2l0aGluIGEgY29ycG9yYXRpb24gb3IgbGFib3Igb3JnYW5pemF0aW9uLCB3aG8gbWF5IGJlIHNvbGljaXRlZCBmb3IgY29udHJpYnV0aW9ucyB0byB0aGUgb3JnYW5pemF0aW9u4oCZcyBzZXBhcmF0ZSBzZWdyZWdhdGVkIGZ1bmQgYXQgYW55IHRpbWUgYW5kIHdobyBtYXkgcmVjZWl2ZSBjZXJ0YWluIGNvbW11bmljYXRpb25zIGZyb20gdGhlIG9yZ2FuaXphdGlvbi4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTEvQ1VSUkVOVCMxMTQtMS1qXFxcIj4xMTQuMShqKTwvYT47IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTMvQ1VSUkVOVCMxMTQtM1xcXCI+MTE0LjMoYSk8L2E+OyA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNC01L0NVUlJFTlQjMTE0LTUtZ1xcXCI+MTE0LjUoZyk8L2E+OyA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNC03L0NVUlJFTlQjMTE0LTdcXFwiPjExNC43KGEpIGFuZCAoaCk8L2E+OyBhbmQgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTQtOC9DVVJSRU5UIzExNC04LWNcXFwiPjExNC44KGMpLCAoaCkgYW5kIChpKTwvYT4uXCJ9LHtcInRlcm1cIjpcIlNlcGFyYXRlIHNlZ3JlZ2F0ZWQgZnVuZCAoU1NGKVwiLFwiZGVmaW5pdGlvblwiOlwiQSBwb2xpdGljYWwgY29tbWl0dGVlIGVzdGFibGlzaGVkLCBhZG1pbmlzdGVyZWQgb3IgZmluYW5jaWFsbHkgc3VwcG9ydGVkIGJ5IGEgY29ycG9yYXRpb24gb3IgbGFib3Igb3JnYW5pemF0aW9uLCBwb3B1bGFybHkgY2FsbGVkIGEgQ29ycG9yYXRlIG9yIExhYm9yIFBvbGl0aWNhbCBBY3Rpb24gQ29tbWl0dGVlIChQQUMpLiBTZWUgMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTEvQ1VSUkVOVCMxMTQtMS1hLTJcXFwiPjExNC4xKGEpKDIpKGlpaSk8L2E+LiBUaGUgdGVybSBcXFwiZmluYW5jaWFsbHkgc3VwcG9ydGVkXFxcIiBkb2VzIG5vdCBpbmNsdWRlIGNvbnRyaWJ1dGlvbnMgdG8gdGhlIFNTRiwgYnV0IGRvZXMgaW5jbHVkZSB0aGUgcGF5bWVudCBvZiBlc3RhYmxpc2htZW50LCBhZG1pbmlzdHJhdGlvbiBvciBzb2xpY2l0YXRpb24gY29zdHMuIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTYvQ1VSUkVOVCMxMDAtNi1jXFxcIj4xMSBDRlIgMTAwLjYoYyk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJTb2xpY2l0YXRpb24gKFNTRilcIixcImRlZmluaXRpb25cIjpcIkEgc3RhdGVtZW50IHRoYXQgcHVibGljaXplcyB0aGUgU1NG4oCZcyByaWdodCB0byBhY2NlcHQgdW5zb2xpY2l0ZWQgY29udHJpYnV0aW9ucyBmcm9tIGFueSBsYXdmdWwgY29udHJpYnV0b3I7IHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBjb250cmlidXRlIHRvIHRoZSBTU0Y7IG9yIGVuY291cmFnZXMgc3VwcG9ydCBmb3IgdGhlIFNTRi4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL2Fkdmlzb3J5LW9waW5pb25zLzE5ODQtNTUvXFxcIj5BTyAxOTg04oCTNTUsIG4uIDI8L2E+OyBBT3MgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL2Fkdmlzb3J5LW9waW5pb25zLzE5NzktNjYvXFxcIj4xOTc54oCTNjY8L2E+IGFuZCA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L2RhdGEvbGVnYWwvYWR2aXNvcnktb3BpbmlvbnMvMTk3OS0xMy9cXFwiPjE5NznigJMxMzwvYT4uXCJ9LHtcInRlcm1cIjpcIlNwZWNpYWwgZWxlY3Rpb25cIixcImRlZmluaXRpb25cIjpcIkEgcHJpbWFyeSwgZ2VuZXJhbCBvciBydW5vZmYgZWxlY3Rpb24gdGhhdCBpcyBub3QgYSByZWd1bGFybHkgc2NoZWR1bGVkIGVsZWN0aW9uIGFuZCB0aGF0IGlzIGhlbGQgdG8gZmlsbCBhIHZhY2FudCBzZWF0IGluIHRoZSBIb3VzZSBvZiBSZXByZXNlbnRhdGl2ZXMgb3IgdGhlIFNlbmF0ZS4gPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMi9DVVJSRU5UIzEwMC0yLWZcXFwiPjEwMC4yKGYpPC9hPi5cIn0se1widGVybVwiOlwiU3RhdGUgcGFydHkgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbW1pdHRlZSB3aGljaCwgYnkgdmlydHVlIG9mIHRoZSBieWxhd3Mgb2YgYSBwb2xpdGljYWwgcGFydHkgb3IgdGhlIG9wZXJhdGlvbiBvZiBzdGF0ZSBsYXcgaXMgcGFydCBvZiB0aGUgb2ZmaWNpYWwgcGFydHkgc3RydWN0dXJlIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGRheS10by1kYXkgb3BlcmF0aW9uIG9mIHRoZSBwYXJ0eSBhdCB0aGUgc3RhdGUgbGV2ZWwsIGluY2x1ZGluZyBhbiBlbnRpdHkgdGhhdCBpcyBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGVzdGFibGlzaGVkLCBmaW5hbmNlZCwgbWFpbnRhaW5lZCBvciBjb250cm9sbGVkIGJ5IHRoYXQgb3JnYW5pemF0aW9uLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBDb21taXNzaW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDAtMTQvQ1VSUkVOVCMxMDAtMTRcXFwiPjEwMC4xNChhKTwvYT4uXCJ9LHtcInRlcm1cIjpcIlN0YXR1c1wiLFwiZGVmaW5pdGlvblwiOlwiUmVmZXJzIHRvIHdoZXRoZXIgdGhlIGNhbmRpZGF0ZSBpcyBhbiBpbmN1bWJlbnQsIGNoYWxsZW5nZXIgb3IgcnVubmluZyB1bm9wcG9zZWQuXCJ9LHtcInRlcm1cIjpcIlN0b2NraG9sZGVyXCIsXCJkZWZpbml0aW9uXCI6XCJBIHBlcnNvbiB3aG8gaGFzIGEgdmVzdGVkIGJlbmVmaWNpYWwgaW50ZXJlc3QgaW4gc3RvY2ssIHRoZSBwb3dlciB0byBkaXJlY3QgaG93IHRoYXQgc3RvY2sgaXMgdm90ZWQgKGlmIGl0IGlzIHZvdGluZyBzdG9jaykgYW5kIHRoZSByaWdodCB0byByZWNlaXZlIGRpdmlkZW5kcy4xMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMTQtMS9DVVJSRU5UIzExNC0xLWhcXFwiPjExNC4xKGgpPC9hPi5cIn0se1widGVybVwiOlwiU3VwZXIgUEFDXCIsXCJkZWZpbml0aW9uXCI6XCJBIGNvbW1pdHRlZSB0aGF0IGludGVuZHMgdG8gbWFrZSBpbmRlcGVuZGVudCBleHBlbmRpdHVyZXMsIGFuZCDigJQgY29uc2lzdGVudCB3aXRoIHRoZSBVLlMuIENvdXJ0IG9mIEFwcGVhbHMgZm9yIHRoZSBEaXN0cmljdCBvZiBDb2x1bWJpYSBDaXJjdWl0IGRlY2lzaW9uIGluIDxpPlNwZWVjaE5vdyB2LiBGRUM8L2k+IOKAlCBpdCB0aGVyZWZvcmUgaW50ZW5kcyB0byByYWlzZSBmdW5kcyBpbiB1bmxpbWl0ZWQgYW1vdW50cy4gVGhpcyBjb21taXR0ZWUgd2lsbCBub3QgdXNlIHRob3NlIGZ1bmRzIHRvIG1ha2UgY29udHJpYnV0aW9ucywgd2hldGhlciBkaXJlY3QsIGluLWtpbmQgb3IgdmlhIGNvb3JkaW5hdGVkIGNvbW11bmljYXRpb25zLCB0byBmZWRlcmFsIGNhbmRpZGF0ZXMgb3IgY29tbWl0dGVlcy5cIn0se1widGVybVwiOlwiVGVybWluYXRpbmcgY29tbWl0dGVlXCIsXCJkZWZpbml0aW9uXCI6XCJBIHBvbGl0aWNhbCBjb21taXR0ZWUgdGhhdCBpcyB3aW5kaW5nIGRvd24gaXRzIGFjdGl2aXRpZXMgaW4gcHJlcGFyYXRpb24gZm9yIGZpbGluZyBhIHRlcm1pbmF0aW9uIHJlcG9ydC4gQSB0ZXJtaW5hdGluZyBjb21taXR0ZWUgaGFzIGNlYXNlZCB0byBtYWtlIG9yIHJlY2VpdmUgY29udHJpYnV0aW9ucyBvciBtYWtlIGV4cGVuZGl0dXJlcyAob3RoZXIgdGhhbiBmb3IgZGVidCByZXRpcmVtZW50IHB1cnBvc2VzIG9yIHdpbmRpbmctZG93biBjb3N0cykuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExNi0xL0NVUlJFTlQjMTE2LTFcXFwiPjExNi4xKGEpPC9hPi5cIn0se1widGVybVwiOlwidG8gRGlyZWN0XCIsXCJkZWZpbml0aW9uXCI6XCJGb3IgcHVycG9zZXMgb2YgMTEgQ0ZSIFBhcnQgMzAwLCB0byBkaXJlY3QgbWVhbnMgdG8gZ3VpZGUsIGRpcmVjdGx5IG9yIGluZGlyZWN0bHksIGEgcGVyc29uIHdobyBoYXMgZXhwcmVzc2VkIGFuIGludGVudCB0byBtYWtlIGEgY29udHJpYnV0aW9uLCBkb25hdGlvbiwgdHJhbnNmZXIgb2YgZnVuZHMgb3Igb3RoZXJ3aXNlIHByb3ZpZGUgYW55dGhpbmcgb2YgdmFsdWUsIGJ5IGlkZW50aWZ5aW5nIGEgY2FuZGlkYXRlLCBwb2xpdGljYWwgY29tbWl0dGVlIG9yIG9yZ2FuaXphdGlvbiBmb3IgdGhlIHJlY2VpcHQgb2Ygc3VjaCBmdW5kcyBvciB0aGluZ3Mgb2YgdmFsdWUuIFRoZSBjb250cmlidXRpb24sIGRvbmF0aW9uLCB0cmFuc2ZlciBvciB0aGluZyBvZiB2YWx1ZSBtYXkgYmUgcHJvdmlkZWQgZGlyZWN0bHkgb3IgdGhyb3VnaCBhbiBpbnRlcm1lZGlhcnkuIERpcmVjdGlvbiBkb2VzIG5vdCBpbmNsdWRlIG1lcmVseSBwcm92aWRpbmcgaW5mb3JtYXRpb24gb3IgZ3VpZGFuY2UgYXMgdG8gdGhlIGFwcGxpY2FiaWxpdHkgb2YgYSBwYXJ0aWN1bGFyIGxhdyBvciByZWd1bGF0aW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMi8yMDE3LWFubnVhbC0zMDAjMzAwLTItblxcXCI+MzAwLjIobik8L2E+LlwifSx7XCJ0ZXJtXCI6XCJ0byBTb2xpY2l0XCIsXCJkZWZpbml0aW9uXCI6XCJGb3IgdGhlIHB1cnBvc2VzIG9mIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzMwMFxcXCI+UGFydCAzMDA8L2E+LCB0byBzb2xpY2l0IG1lYW5zIHRvIGFzaywgcmVxdWVzdCBvciByZWNvbW1lbmQsIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSwgdGhhdCBhbm90aGVyIHBlcnNvbiBtYWtlIGEgY29udHJpYnV0aW9uLCBkb25hdGlvbiwgdHJhbnNmZXIgb2YgZnVuZHMgb3Igb3RoZXJ3aXNlIHByb3ZpZGUgYW55dGhpbmcgb2YgdmFsdWUuIEEgc29saWNpdGF0aW9uIGlzIGFuIG9yYWwgb3Igd3JpdHRlbiBjb21tdW5pY2F0aW9uIHRoYXQsIGNvbnN0cnVlZCBhcyByZWFzb25hYmx5IHVuZGVyc3Rvb2QgaW4gdGhlIGNvbnRleHQgaW4gd2hpY2ggaXQgaXMgbWFkZSwgY29udGFpbnMgYSBjbGVhciBtZXNzYWdlIGFza2luZywgcmVxdWVzdGluZyBvciByZWNvbW1lbmRpbmcgdGhhdCBhIHBlcnNvbiBtYWtlIGEgY29udHJpYnV0aW9uLCBkb25hdGlvbiwgdHJhbnNmZXIgb2YgZnVuZHMgb3Igb3RoZXJ3aXNlIHByb3ZpZGUgYW55dGhpbmcgb2YgdmFsdWUuIEEgc29saWNpdGF0aW9uIG1heSBiZSBtYWRlIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkuIFRoZSBjb250ZXh0IGluY2x1ZGVzIHRoZSBjb25kdWN0IG9mIHBlcnNvbnMgaW52b2x2ZWQgaW4gdGhlIGNvbW11bmljYXRpb24uIEEgc29saWNpdGF0aW9uIGRvZXMgbm90IGluY2x1ZGUgbWVyZSBzdGF0ZW1lbnRzIG9mIHBvbGl0aWNhbCBzdXBwb3J0IG9yIG1lcmUgZ3VpZGFuY2UgYXMgdG8gdGhlIGFwcGxpY2FiaWxpdHkgb2YgYSBwYXJ0aWN1bGFyIGxhdyBvciByZWd1bGF0aW9uLiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8zMDAtMi9DVVJSRU5UIzMwMC0yLWxcXFwiPjMwMC4yKG0pPC9hPi5cIn0se1widGVybVwiOlwiVG90YWwgZGlzYnVyc2VtZW50c1wiLFwiZGVmaW5pdGlvblwiOlwiVGhlIHN1bSBvZiBhbGwgcHVyY2hhc2VzIGFuZCBwYXltZW50cyBtYWRlIGR1cmluZyBhIGZpbGluZyBwZXJpb2QgYnkgYSBwb2xpdGljYWwgY29tbWl0dGVlIG9yIGFueSBvdGhlciBwZXJzb24sIGluY2x1ZGluZyBhbiBvcmdhbml6YXRpb24gdGhhdCBpcyBub3QgYSBwb2xpdGljYWwgY29tbWl0dGVlIHRoYXQgaXMgc3ViamVjdCB0byB0aGUgRmVkZXJhbCBFbGVjdGlvbiBDYW1wYWlnbiBBY3QuXCJ9LHtcInRlcm1cIjpcIlRvdGFsIHJlY2VpcHRzXCIsXCJkZWZpbml0aW9uXCI6XCJUaGUgc3VtIG9mIGFsbCBjb250cmlidXRpb25zIGFuZCBvdGhlciByZWNlaXB0cyByZWNlaXZlZCBieSBhIGNvbW1pdHRlZSBkdXJpbmcgYSBmaWxpbmcgcGVyaW9kLlwifSx7XCJ0ZXJtXCI6XCJUcmFkZSBhc3NvY2lhdGlvblwiLFwiZGVmaW5pdGlvblwiOlwiQSBtZW1iZXJzaGlwIG9yZ2FuaXphdGlvbiBjb25zaXN0aW5nIG9mIHBlcnNvbnMgZW5nYWdlZCBpbiBhIHNpbWlsYXIgb3IgcmVsYXRlZCBsaW5lIG9mIGNvbW1lcmNlLiBBIHRyYWRlIGFzc29jaWF0aW9uIGlzIG9yZ2FuaXplZCB0byBwcm9tb3RlIGFuZCBpbXByb3ZlIGJ1c2luZXNzIGNvbmRpdGlvbnMgaW4gdGhhdCBsaW5lIG9mIGNvbW1lcmNlIGFuZCBub3QgdG8gZW5nYWdlIGluIGEgcmVndWxhciBidXNpbmVzcyBmb3IgcHJvZml0LiBObyBwYXJ0IG9mIHRoZSBuZXQgZWFybmluZ3Mgb2YgYSB0cmFkZSBhc3NvY2lhdGlvbiBtYXkgaW51cmUgdG8gdGhlIGJlbmVmaXQgb2YgYW55IG1lbWJlci5cIn0se1widGVybVwiOlwiVHJlYXN1cmVyXCIsXCJkZWZpbml0aW9uXCI6XCJSZXF1aXJlZCBmb3IgZXZlcnkgcG9saXRpY2FsIGNvbW1pdHRlZS4gVGhlIHRyZWFzdXJlciBpcyByZXNwb25zaWJsZSBmb3IgZmlsaW5nIHRoZSBjb21taXR0ZWUncyByZWdpc3RyYXRpb24gZm9ybSwgZGVwb3NpdGluZyByZWNlaXB0cywgYXV0aG9yaXppbmcgZXhwZW5kaXR1cmVzLCBtb25pdG9yaW5nIGNvbnRyaWJ1dGlvbnMsIGtlZXBpbmcgcmVjb3Jkcywgc2lnbmluZyBhbGwgcmVwb3J0cyBhbmQgc3RhdGVtZW50cyBhbmQgZmlsaW5nIGFsbCByZXBvcnRzIGFuZCBzdGF0ZW1lbnRzIG9uIHRpbWUuXCJ9LHtcInRlcm1cIjpcIlRyZWFzdXJ5IGZ1bmRzXCIsXCJkZWZpbml0aW9uXCI6XCJGdW5kcyBvZiBhIGNvcnBvcmF0aW9uIG9yIGxhYm9yIG9yZ2FuaXphdGlvbiB0aGF0IGFyZSBkZXJpdmVkIGZyb20gY29tbWVyY2lhbCBhY3Rpdml0aWVzIG9yIGR1ZXMgcGF5bWVudHMuIFRyZWFzdXJ5IGZ1bmRzIG1heSBiZSB1c2VkIGZvciB0aGUgZXN0YWJsaXNobWVudCwgYWRtaW5pc3RyYXRpdmUgYW5kIGZ1bmRyYWlzaW5nIGNvc3RzIG9mIHRoZSBvcmdhbml6YXRpb27igJlzIHNlcGFyYXRlIHNlZ3JlZ2F0ZWQgZnVuZCwgYXMgd2VsbCBhcyBmb3IgbWFraW5nIGluZGVwZW5kZW50IGV4cGVuZGl0dXJlcyBhbmQgY29udHJpYnV0aW5nIHRvIFN1cGVyIFBBQ3MgYW5kIHRoZSBub24tY29udHJpYnV0aW9uIGFjY291bnRzIG9mIEh5YnJpZCBQQUNzLiBTZWUgMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTUvQ1VSUkVOVCMxMTQtNS1iXFxcIj4xMTQuNShiKTwvYT4gYW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTE0LTEwL0NVUlJFTlQjMTE0LTEwXFxcIj4xMTQuMTA8L2E+LlwifSx7XCJ0ZXJtXCI6XCJVbmRlc2lnbmF0ZWQgY29udHJpYnV0aW9uXCIsXCJkZWZpbml0aW9uXCI6XCJDb250cmlidXRvcnMgbWF5IGRlc2lnbmF0ZSBjb250cmlidXRpb25zIGZvciBhIHBhcnRpY3VsYXIgZWxlY3Rpb24gYnkgaW5kaWNhdGluZyBpbiB3cml0aW5nIHRoZSBzcGVjaWZpYyBlbGVjdGlvbiB0byB3aGljaCB0aGV5IGludGVuZCBhIGNvbnRyaWJ1dGlvbiB0byBhcHBseS4gQSBjb250cmlidXRpb24gdGhhdCBpcyBub3QgZGVzaWduYXRlZCBieSB0aGUgY29udHJpYnV0b3IgZm9yIGEgc3BlY2lmaWMgZWxlY3Rpb24gaXMgYW4gdW5kZXNpZ25hdGVkIGNvbnRyaWJ1dGlvbi4gVW5kZXNpZ25hdGVkIGNvbnRyaWJ1dGlvbnMgY291bnQgYWdhaW5zdCB0aGUgZG9ub3LigJlzIGNvbnRyaWJ1dGlvbiBsaW1pdHMgZm9yIHRoZSBjYW5kaWRhdGXigJlzIG5leHQgZWxlY3Rpb24uIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzExMC0xL0NVUlJFTlQjMTEwLTEtYi0yLWlpXFxcIj4xMTAuMShiKSgyKTwvYT4uXCJ9LHtcInRlcm1cIjpcIlVuaXF1ZSBpZGVudGlmaWVyXCIsXCJkZWZpbml0aW9uXCI6XCJBIHVuaXF1ZSB0aXRsZSBvciBjb2RlIGFzc2lnbmVkIGJ5IGEgcGFydHkgY29tbWl0dGVlIHRvIGVhY2ggcHJvZ3JhbSBvciBldmVudCBmb3Igd2hpY2ggaXQgcmVwb3J0cyBhbiBhbGxvY2F0aW9uIHJhdGlvLiBQYXJ0eSBjb21taXR0ZWVzIG11c3QgdXNlIHRoYXQgaWRlbnRpZmllciBjb25zaXN0ZW50bHkgd2hlbiByZXBvcnRpbmcgdGhlIGFjdGl2aXR5LiAxMSBDRlIgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9yZWd1bGF0aW9ucy8xMDQtMTcvQ1VSUkVOVCMxMDQtMTctYi0xLWlpaVxcXCI+MTA0LjE3KGIpKDEpKGlpaSk8L2E+LlwifSx7XCJ0ZXJtXCI6XCJVLlMuQy5cIixcImRlZmluaXRpb25cIjpcIlRoZSBVbml0ZWQgU3RhdGVzIENvZGUgKFUuUy5DLikgY29udGFpbnMgdGhlIGZlZGVyYWwgc3RhdHV0b3J5IGxhd3Mgb2YgdGhlIFVuaXRlZCBTdGF0ZXMsIGFycmFuZ2VkIGludG8gNTQgYnJvYWQgdGl0bGVzIGFjY29yZGluZyB0byBzdWJqZWN0IG1hdHRlci4gVGhlIEZFQyBhZG1pbmlzdGVycyB0aGUgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZmVjLmdvdi9kYXRhL2xlZ2FsL3N0YXR1dGVzL1xcXCI+Y2FtcGFpZ24gZmluYW5jZSBsYXdzPC9hPiBmb3VuZCBpbiBUaXRsZSA1MiBhbmQgdGhlIHBvcnRpb25zIG9mIFRpdGxlIDI2IG9mIHRoZSBVbml0ZWQgU3RhdGVzIENvZGUgY29uY2VybmluZyBwdWJsaWMgZmluYW5jaW5nIG9mIHByZXNpZGVudGlhbCBlbGVjdGlvbiBjYW1wYWlnbnMuXCJ9LHtcInRlcm1cIjpcIlVzdWFsIGFuZCBub3JtYWwgY2hhcmdlXCIsXCJkZWZpbml0aW9uXCI6XCJXaXRoIHJlZ2FyZCB0byBnb29kcyBwcm92aWRlZCB0byBhIHBvbGl0aWNhbCBjb21taXR0ZWUsIHRoZSB0ZXJtIHJlZmVycyB0byB0aGUgcHJpY2Ugb2YgdGhvc2UgZ29vZHMgaW4gdGhlIG1hcmtldCBmcm9tIHdoaWNoIHRoZXkgb3JkaW5hcmlseSB3b3VsZCBoYXZlIGJlZW4gcHVyY2hhc2VkIGF0IHRoZSB0aW1lIHRoZXkgd2VyZSBwcm92aWRlZC4gV2l0aCByZWdhcmQgdG8gc2VydmljZXMsIHRoZSB0ZXJtIHJlZmVycyB0byB0aGUgaG91cmx5IG9yIHBpZWNld29yayBjaGFyZ2UgZm9yIHRoZSBzZXJ2aWNlcyBhdCBhIGNvbW1lcmNpYWxseSByZWFzb25hYmxlIHJhdGUgcHJldmFpbGluZyBhdCB0aGUgdGltZSB0aGUgc2VydmljZXMgd2VyZSByZW5kZXJlZC4gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTAwLTUyL0NVUlJFTlQjMTAwLTUyLWQtMlxcXCI+MTAwLjUyKGQpKDIpPC9hPi5cIn0se1widGVybVwiOlwiVm90ZXIgZHJpdmUgYWN0aXZpdHlcIixcImRlZmluaXRpb25cIjpcIlZvdGVyIGlkZW50aWZpY2F0aW9uLCB2b3RlciByZWdpc3RyYXRpb24gYW5kIGdldC1vdXQtdGhlLXZvdGUtZHJpdmVzLCBvciBhbnkgb3RoZXIgYWN0aXZpdGllcyB0aGF0IHVyZ2UgdGhlIGdlbmVyYWwgcHVibGljIHRvIHJlZ2lzdGVyIG9yIHZvdGUsIG9yIHRoYXQgcHJvbW90ZSBvciBvcHBvc2UgYSBwb2xpdGljYWwgcGFydHksIHdpdGhvdXQgcHJvbW90aW5nIGFueSBmZWRlcmFsIG9yIG5vbmZlZGVyYWwgY2FuZGlkYXRlLCB0aGF0IGRvIG5vdCBxdWFsaWZ5IGFzIEZFQS4gVGhpcyBpcyBhIGNhdGVnb3J5IG9mIGFsbG9jYWJsZSBhY3Rpdml0eSBmb3IgbWl4ZWQgZmVkZXJhbC9ub25mZWRlcmFsIHBhcnR5IGFjdGl2aXR5IHNvbWV0aW1lcyBhbHNvIHJlZmVycmVkIHRvIGFzIGEg4oCcZ2VuZXJpYyB2b3RlciBkcml2ZS7igJ0gMTEgQ0ZSIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZlYy5nb3YvcmVndWxhdGlvbnMvMTA2LTcvQ1VSUkVOVCMxMDYtNy1jLTVcXFwiPjEwNi43KGMpKDUpPC9hPi5cIn0se1widGVybVwiOlwiVm90ZXIgaWRlbnRpZmljYXRpb25cIixcImRlZmluaXRpb25cIjpcIldpdGggcmVnYXJkIHRvIEZFQSwgdGhpcyBtZWFucyBhY3F1aXJpbmcgaW5mb3JtYXRpb24gYWJvdXQgcG90ZW50aWFsIHZvdGVycywgaW5jbHVkaW5nLCBidXQgbm90IGxpbWl0ZWQgdG8sIG9idGFpbmluZyB2b3RlciBsaXN0cyBhbmQgY3JlYXRpbmcgb3IgZW5oYW5jaW5nIHZvdGVyIGxpc3RzIGJ5IHZlcmlmeWluZyBvciBhZGRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZvdGVyc+KAmSBsaWtlbGlob29kIG9mIHZvdGluZyBpbiBhbiB1cGNvbWluZyBlbGVjdGlvbiBvciB2b3RpbmcgZm9yIHNwZWNpZmljIGNhbmRpZGF0ZXMuIDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yNC9DVVJSRU5UIzEwMC0yNC1hLTRcXFwiPjEwMC4yNChhKSg0KTwvYT4uXCJ9LHtcInRlcm1cIjpcIlZvdGVyIHJlZ2lzdHJhdGlvbiBhY3Rpdml0eVwiLFwiZGVmaW5pdGlvblwiOlwiSW4gcmVnYXJkIHRvIEZFQSwgdm90ZXIgcmVnaXN0cmF0aW9uIGFjdGl2aXR5IGVuY29tcGFzc2VzIGFsbCBtZWFucyBvZiBjb250YWN0aW5nIHBvdGVudGlhbCB2b3RlcnMgdG8gYXNzaXN0LCBlbmNvdXJhZ2Ugb3IgdXJnZSB0aGVtIHRvIHJlZ2lzdGVyIHRvIHZvdGUuIFRoaXMgYWN0aXZpdHkgaW5jbHVkZXMsIGJ1dCBpcyBub3QgbGltaXRlZCB0bzogPHVsPjxsaT5FbmNvdXJhZ2luZyBvciB1cmdpbmcgcG90ZW50aWFsIHZvdGVycyB0byByZWdpc3RlciB0byB2b3RlLCB3aGV0aGVyIGJ5IG1haWwgKGluY2x1ZGluZyBkaXJlY3QgbWFpbCksIGVtYWlsLCBpbiBwZXJzb24sIGJ5IHRlbGVwaG9uZSAoaW5jbHVkaW5nIHByZS1yZWNvcmRlZCB0ZWxlcGhvbmUgY2FsbHMsIHBob25lIGJhbmtzIGFuZCBtZXNzYWdpbmcgc3VjaCBhcyBTTVMgYW5kIE1NUyksIG9yIGJ5IGFueSBvdGhlciBtZWFuczs8L2xpPjxsaT5QcmVwYXJpbmcgYW5kIGRpc3RyaWJ1dGluZyBpbmZvcm1hdGlvbiBhYm91dCByZWdpc3RyYXRpb24gYW5kIHZvdGluZzs8L2xpPjxsaT5EaXN0cmlidXRpbmcgdm90ZXIgcmVnaXN0cmF0aW9uIGZvcm1zIG9yIGluc3RydWN0aW9ucyB0byBwb3RlbnRpYWwgdm90ZXJzOzwvbGk+PGxpPkFuc3dlcmluZyBxdWVzdGlvbnMgYWJvdXQgaG93IHRvIGNvbXBsZXRlIG9yIGZpbGUgYSB2b3RlciByZWdpc3RyYXRpb24gZm9ybSwgb3IgYXNzaXN0aW5nIHBvdGVudGlhbCB2b3RlcnMgaW4gY29tcGxldGluZyBvciBmaWxpbmcgc3VjaCBmb3Jtczs8L2xpPjxsaT5TdWJtaXR0aW5nIG9yIGRlbGl2ZXJpbmcgYSBjb21wbGV0ZWQgdm90ZXIgcmVnaXN0cmF0aW9uIGZvcm0gb24gYmVoYWxmIG9mIGEgcG90ZW50aWFsIHZvdGVyOzwvbGk+PGxpPk9mZmVyaW5nIG9yIGFycmFuZ2luZyB0byB0cmFuc3BvcnQsIG9yIGFjdHVhbGx5IHRyYW5zcG9ydGluZyBwb3RlbnRpYWwgdm90ZXJzIHRvIGEgYm9hcmQgb2YgZWxlY3Rpb25zIG9yIGNvdW50eSBjbGVya+KAmXMgb2ZmaWNlIGZvciB0aGVtIHRvIGZpbGwgb3V0IHZvdGVyIHJlZ2lzdHJhdGlvbiBmb3Jtczsgb3I8L2xpPjxsaT5hbnkgb3RoZXIgYWN0aXZpdHkgdGhhdCBhc3Npc3RzIHBvdGVudGlhbCB2b3RlcnMgdG8gcmVnaXN0ZXIgdG8gdm90ZS48L2xpPjwvdWw+IDExIENGUiA8YSBocmVmPVxcXCJodHRwczovL3d3dy5mZWMuZ292L3JlZ3VsYXRpb25zLzEwMC0yNC9DVVJSRU5UIzEwMC0yNC1hLTJcXFwiPjEwMC4yNChhKSgyKTwvYT4uXCJ9XVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy9kYXRhL3Rlcm1zLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG52YXIgYWNjZXNzaWJpbGl0eSA9IHJlcXVpcmUoJy4vYWNjZXNzaWJpbGl0eScpO1xuXG52YXIgZmVlZGJhY2sgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvZmVlZGJhY2suaGJzJyk7XG5cbnZhciBzdGF0dXNDbGFzc2VzID0ge1xuICBzdWNjZXNzOiAnbWVzc2FnZS0tc3VjY2VzcycsXG4gIGVycm9yOiAnbWVzc2FnZS0tZXJyb3InXG59O1xuXG4vKipcbiAqIEZlZWRiYWNrIHdpZGdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gQUpBWCBVUkxcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgc2VsZWN0b3I7IGRlZmF1bHRzIHRvICdib2R5J1xuICovXG5mdW5jdGlvbiBGZWVkYmFjayh1cmwsIHBhcmVudCkge1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgdGhpcy4kZmVlZGJhY2sgPSAkKGZlZWRiYWNrKCkpO1xuXG4gICQocGFyZW50IHx8ICdib2R5JykuYXBwZW5kKHRoaXMuJGZlZWRiYWNrKTtcblxuICB0aGlzLiRidXR0b24gPSB0aGlzLiRmZWVkYmFjay5maW5kKCcuanMtZmVlZGJhY2snKTtcbiAgdGhpcy4kcmVzZXQgPSB0aGlzLiRmZWVkYmFjay5maW5kKCcuanMtcmVzZXQnKTtcbiAgdGhpcy4kYm94ID0gdGhpcy4kZmVlZGJhY2suZmluZCgnLmpzLWZlZWRiYWNrLWJveCcpO1xuICB0aGlzLiRzdGF0dXMgPSB0aGlzLiRib3guZmluZCgnLmpzLXN0YXR1cycpO1xuICB0aGlzLiRtZXNzYWdlID0gdGhpcy4kYm94LmZpbmQoJy5qcy1tZXNzYWdlJyk7XG4gIHRoaXMuJGZvcm0gPSB0aGlzLiRmZWVkYmFjay5maW5kKCdmb3JtJyk7XG5cbiAgdGhpcy4kYnV0dG9uLm9uKCdjbGljaycsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xuICB0aGlzLiRyZXNldC5vbignY2xpY2snLCB0aGlzLnJlc2V0LmJpbmQodGhpcykpO1xuICB0aGlzLiRmb3JtLm9uKCdzdWJtaXQnLCB0aGlzLnN1Ym1pdC5iaW5kKHRoaXMpKTtcblxuICBhY2Nlc3NpYmlsaXR5LnJlbW92ZVRhYmluZGV4KHRoaXMuJGJveCk7XG5cbiAgJChkb2N1bWVudC5ib2R5KS5vbignZmVlZGJhY2s6b3BlbicsIHRoaXMuc2hvdy5iaW5kKHRoaXMpKTtcbn1cblxuRmVlZGJhY2sucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5pc09wZW4gPyB0aGlzLmhpZGUgOiB0aGlzLnNob3c7XG4gIG1ldGhvZC5hcHBseSh0aGlzKTtcbn07XG5cbkZlZWRiYWNrLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJGJveC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICB0aGlzLiRidXR0b24uYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICBhY2Nlc3NpYmlsaXR5LnJlc3RvcmVUYWJpbmRleCh0aGlzLiRib3gpO1xufTtcblxuRmVlZGJhY2sucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy4kYm94LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgdGhpcy4kYnV0dG9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICBhY2Nlc3NpYmlsaXR5LnJlbW92ZVRhYmluZGV4KHRoaXMuJGJveCk7XG59O1xuXG5GZWVkYmFjay5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24oZSkge1xuICAvKipcbiAgICogc2V0dXAgSlF1ZXJ5J3MgQUpBWCBtZXRob2RzIHRvIHNldHVwIENTUkYgdG9rZW4gaW4gdGhlIHJlcXVlc3QgYmVmb3JlIHNlbmRpbmcgaXQgb2ZmLlxuICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUxMDA1MzkvZGphbmdvLWNzcmYtY2hlY2stZmFpbGluZy13aXRoLWFuLWFqYXgtcG9zdC1yZXF1ZXN0XG4gICAqL1xuICAkLmFqYXhTZXR1cCh7XG4gICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKHhociwgc2V0dGluZ3MpIHtcbiAgICAgICBpZiAoISgvXmh0dHA6LiovLnRlc3Qoc2V0dGluZ3MudXJsKSB8fCAvXmh0dHBzOi4qLy50ZXN0KHNldHRpbmdzLnVybCkpKSB7XG4gICAgICAgICAgIC8vIE9ubHkgc2VuZCB0aGUgdG9rZW4gdG8gcmVsYXRpdmUgVVJMcyBpLmUuIGxvY2FsbHkuXG4gICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkZUb2tlbicsICQoJ2lucHV0W25hbWU9XCJjc3JmbWlkZGxld2FyZXRva2VuXCJdJykudmFsKCkpO1xuICAgICAgIH1cbiAgICAgfVxuICB9KTtcblxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdmFyIGRhdGEgPSBfLmNoYWluKHRoaXMuJGJveC5maW5kKCd0ZXh0YXJlYScpKVxuICAgIC5tYXAoZnVuY3Rpb24oZWxtKSB7XG4gICAgICB2YXIgJGVsbSA9ICQoZWxtKTtcbiAgICAgIHJldHVybiBbJGVsbS5hdHRyKCduYW1lJyksICRlbG0udmFsKCldO1xuICAgIH0pXG4gICAgLm9iamVjdCgpXG4gICAgLnZhbHVlKCk7XG5cbiAgaWYgKCFfLnNvbWUoXy52YWx1ZXMoZGF0YSkpKSB7XG4gICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgJzxoMiBjbGFzcz1cImZlZWRiYWNrX190aXRsZVwiPklucHV0IHJlcXVpcmVkPC9oMj4nICtcbiAgICAgICc8cD5QbGVhc2UgZmlsbCBvdXQgYXQgbGVhc3Qgb25lIGZpZWxkLjwvcD4nO1xuICAgIHZhciBidXR0b25UZXh0ID0gJ1RyeSBhZ2Fpbic7XG4gICAgdGhpcy5tZXNzYWdlKG1lc3NhZ2UsIGJ1dHRvblRleHQsICdlcnJvcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gJC5hamF4KHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgZGF0YVR5cGU6ICdqc29uJ1xuICB9KTtcblxuICBwcm9taXNlLmRvbmUodGhpcy5oYW5kbGVTdWNjZXNzLmJpbmQodGhpcykpO1xuICBwcm9taXNlLmZhaWwodGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbkZlZWRiYWNrLnByb3RvdHlwZS5oYW5kbGVTdWNjZXNzID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIG1lc3NhZ2UgPVxuICAgICc8aDIgY2xhc3M9XCJmZWVkYmFja19fdGl0bGVcIj5UaGFua3MgZm9yIGhlbHBpbmcgdXMgaW1wcm92ZTwvaDI+JyArXG4gICAgJzxwPlRoaXMgaW5mb3JtYXRpb24gaGFzIGJlZW4gcmVwb3J0ZWQgb24gR2l0SHViLCB3aGVyZSBpdFxcJ3MgcHVibGljbHkgdmlzaWJsZS4gJyArXG4gICAgJzxhIGhyZWY9XCInICsgcmVzcG9uc2UuaHRtbF91cmwgKyAnXCI+VHJhY2sgdGhlIHN0YXR1cyBvZiB5b3VyIGZlZWRiYWNrPC9hPi48L3A+JztcbiAgdmFyIGJ1dHRvblRleHQgPSAnU3VibWl0IGFub3RoZXIgaXNzdWUnO1xuICB0aGlzLiRib3guZmluZCgndGV4dGFyZWEnKS52YWwoJycpO1xuICB0aGlzLm1lc3NhZ2UobWVzc2FnZSwgYnV0dG9uVGV4dCwgJ3N1Y2Nlc3MnKTtcbn07XG5cbkZlZWRiYWNrLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWVzc2FnZSA9XG4gICAgJzxoMiBjbGFzcz1cImZlZWRiYWNrX190aXRsZVwiPlRoZXJlIHdhcyBhbiBlcnJvcjwvaDI+JyArXG4gICAgJzxwPlBsZWFzZSB0cnkgc3VibWl0dGluZyB5b3VyIGlzc3VlIGFnYWluLjwvcD4nO1xuICB2YXIgYnV0dG9uVGV4dCA9ICdUcnkgYWdhaW4nO1xuICB0aGlzLm1lc3NhZ2UobWVzc2FnZSwgYnV0dG9uVGV4dCwgJ2Vycm9yJyk7XG59O1xuXG5GZWVkYmFjay5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKHRleHQsIGJ1dHRvblRleHQsIHN0eWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy4kZm9ybS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICB0aGlzLiRzdGF0dXMuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gIHRoaXMuJHJlc2V0LnRleHQoYnV0dG9uVGV4dCk7XG4gIF8uZWFjaChzdGF0dXNDbGFzc2VzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHNlbGYuJG1lc3NhZ2UucmVtb3ZlQ2xhc3ModmFsdWUpO1xuICB9KTtcbiAgdGhpcy4kbWVzc2FnZS5odG1sKHRleHQpLmFkZENsYXNzKHN0YXR1c0NsYXNzZXNbc3R5bGVdKTtcbn07XG5cbkZlZWRiYWNrLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRmb3JtLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuICB0aGlzLiRzdGF0dXMuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge0ZlZWRiYWNrOiBGZWVkYmFja307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9mZWVkYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKCdDOi9mZWNfcHJvZC9mZWMtY21zLWRldmVsb3Avbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcycpO1xubW9kdWxlLmV4cG9ydHMgPSAoSGFuZGxlYmFyc1snZGVmYXVsdCddIHx8IEhhbmRsZWJhcnMpLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXY+XFxuICA8YnV0dG9uIGNsYXNzPVxcXCJqcy1mZWVkYmFjayBmZWVkYmFja19fdG9nZ2xlIGJ1dHRvbi0tY3RhLXByaW1hcnlcXFwiIGFyaWEtY29udHJvbHM9XFxcImZlZWRiYWNrXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5GZWVkYmFjazwvYnV0dG9uPlxcbiAgPGRpdiBpZD1cXFwiZmVlZGJhY2tcXFwiIGNsYXNzPVxcXCJqcy1mZWVkYmFjay1ib3ggZmVlZGJhY2tcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cXFwianMtZmVlZGJhY2sgYnV0dG9uLS1kb3duIGZlZWRiYWNrX19jbG9zZVxcXCI+PHNwYW4gY2xhc3M9XFxcInUtdmlzdWFsbHktaGlkZGVuXFxcIj5DbG9zZTwvc3Bhbj48L2J1dHRvbj5cXG4gICAgPGRpdiBjbGFzcz1cXFwianMtc3RhdHVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibWVzc2FnZSBtZXNzYWdlLS1pbnZlcnNlIGpzLW1lc3NhZ2VcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDx1bCBjbGFzcz1cXFwibGlzdC0tYnV0dG9uc1xcXCI+XFxuICAgICAgICA8bGk+PGJ1dHRvbiBjbGFzcz1cXFwianMtcmVzZXQgYnV0dG9uLS1jdGEtcHJpbWFyeSBmZWVkYmFja19fYnV0dG9uXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlN1Ym1pdCBhbm90aGVyIGlzc3VlPC9idXR0b24+PC9saT5cXG4gICAgICA8L3VsPlxcbiAgICA8L2Rpdj5cXG4gICAgPGZvcm0gaWQ9XFxcImZlZWRiYWNrLWZvcm1cXFwiIGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgIDxmaWVsZHNldD5cXG4gICAgICAgIDxsZWdlbmQgY2xhc3M9XFxcImZlZWRiYWNrX190aXRsZVxcXCI+SGVscCB1cyBpbXByb3ZlIEZFQy5nb3Y8L2xlZ2VuZD5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJ0LXNhbnNcXFwiPkRvbid0IGluY2x1ZGUgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGxpa2UgeW91ciBuYW1lLCBjb250YWN0IGluZm9ybWF0aW9uIG9yIFNvY2lhbCBTZWN1cml0eSBudW1iZXIuPC9wPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZmVlZGJhY2stMVxcXCIgY2xhc3M9XFxcImxhYmVsXFxcIj5XaGF0IHdlcmUgeW91IHRyeWluZyB0byBkbyBhbmQgaG93IGNhbiB3ZSBpbXByb3ZlIGl0Pyo8L2xhYmVsPlxcbiAgICAgICAgPHRleHRhcmVhIGlkPVxcXCJmZWVkYmFjay0xXFxcIiBuYW1lPVxcXCJhY3Rpb25cXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmZWVkYmFjay0yXFxcIiBjbGFzcz1cXFwibGFiZWxcXFwiPkdlbmVyYWwgZmVlZGJhY2s/PC9sYWJlbD5cXG4gICAgICAgIDx0ZXh0YXJlYSBpZD1cXFwiZmVlZGJhY2stMlxcXCIgbmFtZT1cXFwiZmVlZGJhY2tcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmZWVkYmFjay0zXFxcIiBjbGFzcz1cXFwibGFiZWxcXFwiPlRlbGwgdXMgYWJvdXQgeW91cnNlbGY8L2xhYmVsPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxhYmVsLS1oZWxwXFxcIj5JJ20gYSA8c3BhbiBjbGFzcz1cXFwidS1ibGFuay1zcGFjZVxcXCI+PC9zcGFuPiBpbnRlcmVzdGVkIGluIDxzcGFuIGNsYXNzPVxcXCJ1LWJsYW5rLXNwYWNlXFxcIj48L3NwYW4+Ljwvc3Bhbj5cXG4gICAgICAgIDx0ZXh0YXJlYSBpZD1cXFwiZmVlZGJhY2stM1xcXCIgbmFtZT1cXFwiYWJvdXRcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICA8cCBjbGFzcz1cXFwidC1zYW5zXFxcIj5UaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgcmVwb3J0ZWQgb24gR2l0SHViIHdoZXJlIGl0IHdpbGwgYmUgcHVibGljbHkgdmlzaWJsZS4gWW91IGNhbiByZXZpZXcgYWxsIHJlcG9ydGVkIGZlZWRiYWNrIG9uIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS8xOGYvZmVjL2lzc3Vlc1xcXCI+b3VyIEdpdEh1YiBwYWdlPC9hPi48L3A+XFxuICAgICAgICA8cCBjbGFzcz1cXFwidC1zYW5zIHQtbm90ZVxcXCI+KlJlcXVpcmVkPC9wPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGNsYXNzPVxcXCJidXR0b24tLXN0YW5kYXJkIGZlZWRiYWNrX19idXR0b25cXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgICAgIDwvZmllbGRzZXQ+XFxuICAgIDwvZm9ybT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9mZWMvc3RhdGljL2pzL3RlbXBsYXRlcy9mZWVkYmFjay5oYnNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSwgZG9jdW1lbnQgKi9cblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyoqXG4gICogU2tpcCBuYXYgbGlua1xuICAqIEBjb25zdHJ1Y3RvclxuICAqIEBwYXJhbSB7c3RyaW5nfSBhbmNob3IgLSBDU1Mgc2VsZWN0b3IgZm9yIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IHdpbGwgZnVuY3Rpb24gYXMgdGhlIHNraXAgbmF2XG4gICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEJvZHkgLSBDU1Mgc2VsZWN0b3IgZm9yIHRoZSBtYWluIGNvbnRlbnQgYXJlYSB0byBsb29rIGZvciBhIGZvY3VzYWJsZSBlbGVtZW50IGluXG4gICovXG5cbmZ1bmN0aW9uIFNraXBuYXYoYW5jaG9yLCB0YXJnZXRCb2R5KSB7XG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICB0aGlzLiR0YXJnZXRCb2R5ID0gJCh0YXJnZXRCb2R5KTtcbiAgdGhpcy4kdGFyZ2V0ID0gJCh0aGlzLmZpbmRUYXJnZXQoKSk7XG4gICQoZG9jdW1lbnQuYm9keSkub24oJ2NsaWNrIGtleXVwJywgdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNPblRhcmdldC5iaW5kKHRoaXMpKTtcbn1cblxuU2tpcG5hdi5wcm90b3R5cGUuZmluZFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy4kdGFyZ2V0Qm9keS5maW5kKCc6Zmlyc3QtY2hpbGQnKVxuICAgIC5ub3QoJ2RpdiwgaGVhZGVyLCBzZWN0aW9uLCBhcnRpY2xlLCBhc2lkZScpXG4gICAgLmZpbHRlcignOnZpc2libGUnKVswXTtcbn07XG5cblNraXBuYXYucHJvdG90eXBlLmZvY3VzT25UYXJnZXQgPSBmdW5jdGlvbihlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgXG4gIGlmIChlLmtleUNvZGUgPT09IDEzIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgIHRoaXMuJHRhcmdldC5hdHRyKCd0YWJpbmRleCcsJzAnKTtcbiAgICB0aGlzLiR0YXJnZXQuZm9jdXMoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7U2tpcG5hdjogU2tpcG5hdn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy9za2lwLW5hdi5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxud2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gJDtcblxucmVxdWlyZSgnYWNjZXNzaWJsZS1tZWdhLW1lbnUnKTtcblxuLyoqIFNpdGVOYXYgbW9kdWxlXG4gKiBPbiBtb2JpbGU6IENvbnRyb2xzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0aGUgaGFtYnVyZ2VyIG1lbnUgYW5kIHN1Ymxpc3RzXG4gKiBPbiBkZXNrdG9wOiBDb250cm9scyB0aGUgdmlzaWJpbGl0eSBvZiBkcm9wZG93biBzdWJsaXN0cyBvbiBob3ZlciBhbmQgZm9jdXNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHNlbGVjdG9yIC0gQ1NTIHNlbGVjdG9yIGZvciB0aGUgbmF2IGNvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBPcHRpb25zLCBpbmNsdWRpbmcgYmFzZSBVUkxzXG4gKi9cblxuZnVuY3Rpb24gU2l0ZU5hdihzZWxlY3Rvcikge1xuICB0aGlzLiRib2R5ID0gJCgnYm9keScpO1xuICB0aGlzLiRlbGVtZW50ID0gJChzZWxlY3Rvcik7XG4gIHRoaXMuJG1lbnUgPSB0aGlzLiRlbGVtZW50LmZpbmQoJyNzaXRlLW1lbnUnKTtcbiAgdGhpcy4kdG9nZ2xlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuanMtbmF2LXRvZ2dsZScpO1xuXG4gIHRoaXMuYXNzaWduQXJpYSgpO1xuXG4gIHRoaXMuaW5pdE1lbnUoKTtcblxuICAvLyBPcGVuIGFuZCBjbG9zZSB0aGUgbWVudSBvbiBtb2JpbGVcbiAgdGhpcy4kdG9nZ2xlLm9uKCdjbGljaycsIHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKTtcbn1cblxuU2l0ZU5hdi5wcm90b3R5cGUuaW5pdE1lbnUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbml0TWVnYU1lbnUoKTtcbn07XG5cblNpdGVOYXYucHJvdG90eXBlLmluaXRNZWdhTWVudSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAvLyBSZW1vdmUgaHJlZnMgYW5kIGRlZmF1bHQgY2xpY2sgYmVoYXZpb3IgZm9yIGxpbmtzIHRoYXQgaGF2ZSBzdWJtZW51c1xuICAgICQodGhpcykuZmluZCgnLnNpdGUtbmF2X19saW5rJykuYXR0cignaHJlZicsICcjMCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy4kbWVudS5hY2Nlc3NpYmxlTWVnYU1lbnUoe1xuICAgIHV1aWRQcmVmaXg6ICdtZWdhLW1lbnUnLFxuICAgIG1lbnVDbGFzczogJ3NpdGUtbmF2X19wYW5lbC0tbWFpbicsXG4gICAgdG9wTmF2SXRlbUNsYXNzOiAnc2l0ZS1uYXZfX2l0ZW0nLFxuICAgIHBhbmVsQ2xhc3M6ICdtZWdhLWNvbnRhaW5lcicsXG4gICAgcGFuZWxHcm91cENsYXNzOiAnbWVnYV9fZ3JvdXAnLFxuICAgIGhvdmVyQ2xhc3M6ICdpcy1ob3ZlcicsXG4gICAgZm9jdXNDbGFzczogJ2lzLWZvY3VzJyxcbiAgICBvcGVuQ2xhc3M6ICdpcy1vcGVuJyxcbiAgICBvcGVuRGVsYXk6IDUwMCxcbiAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICBzZWxlY3RvcnM6IHtcbiAgICAgIHRvcE5hdkl0ZW1zOiAnW2RhdGEtc3VibWVudV0nXG4gICAgfVxuICB9KTtcbn07XG5cblNpdGVOYXYucHJvdG90eXBlLmFzc2lnbkFyaWEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy4kbWVudS5hdHRyKCdhcmlhLWxhYmVsJywgJ1NpdGUtd2lkZSBuYXZpZ2F0aW9uJyk7XG4gIGlmIChoZWxwZXJzLmdldFdpbmRvd1dpZHRoKCkgPCBoZWxwZXJzLkJSRUFLUE9JTlRTLkxBUkdFKSB7XG4gICAgdGhpcy4kdG9nZ2xlLmF0dHIoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcbiAgICB0aGlzLiRtZW51LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gIH1cbn07XG5cblNpdGVOYXYucHJvdG90eXBlLnRvZ2dsZU1lbnUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuaXNPcGVuID8gdGhpcy5oaWRlTWVudSA6IHRoaXMuc2hvd01lbnU7XG4gIG1ldGhvZC5hcHBseSh0aGlzKTtcbn07XG5cblNpdGVOYXYucHJvdG90eXBlLnNob3dNZW51ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJGJvZHkuY3NzKHtcbiAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJ1xuICB9KTtcbiAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbicpO1xuICB0aGlzLiR0b2dnbGUuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICB0aGlzLiRtZW51LmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuICB0aGlzLmlzT3BlbiA9IHRydWU7XG59O1xuXG5TaXRlTmF2LnByb3RvdHlwZS5oaWRlTWVudSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRib2R5LmNzcyh7XG4gICAgJ292ZXJmbG93JzogJ2F1dG8nXG4gIH0pO1xuICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG4gIHRoaXMuJHRvZ2dsZS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gIHRoaXMuJG1lbnUuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgaWYgKHRoaXMuaXNNb2JpbGUpIHtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1thcmlhLWhpZGRlbj1mYWxzZV0nKS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU2l0ZU5hdjogU2l0ZU5hdlxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL3NpdGUtbmF2LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgc2Nyb2xsTW9uaXRvciA9IHJlcXVpcmUoJ3Njcm9sbG1vbml0b3InKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vKipcbiAqIFRhYmxlIG9mIENvbnRlbnRzIHdpZGdldFxuICpcbiAqIDEuIFRha2VzIGEgbGlzdCBvZiBsaW5rcyBhbmQgZmluZHMgYWxsIHNlY3Rpb25zIHdpdGggSURzIG1hdGNoaW5nIHRoZWlyIGhyZWZzXG4gKiAyLiBBZGRzIHNjcm9sbHdhdGNoZXJzIHRvIGhpZ2hsaWdodCB0aGUgbWVudSBpdGVtIHdoZW4gdGhlIHNlY3Rpb24gcmVhY2hlcyB0b3Agb2Ygdmlld3BvcnRcbiAqIDMuIEFuaW1hdGVzIHRoZSBkb2N1bWVudCB0byBzY3JvbGwgdG8gdGhlIHNlY3Rpb24gd2hlbiBjbGlja2luZyB0aGUgbGlua1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gU2VsZWN0b3IgZm9yIHRoZSBuYXZpZ2F0aW9uIG1lbnUgZm9yIHRoZSBUT0NcbiAqL1xuXG5mdW5jdGlvbiBUT0Moc2VsZWN0b3IpIHtcbiAgdGhpcy4kbWVudSA9ICQoc2VsZWN0b3IpO1xuICB0aGlzLnNlY3Rpb25zID0gdGhpcy5nZXRTZWN0aW9ucygpO1xuICB0aGlzLm9mZnNldCA9IC0xICogd2luZG93LmlubmVySGVpZ2h0O1xuICB0aGlzLndhdGNoZXJzID0gdGhpcy5hZGRXYXRjaGVycygpO1xuICB0aGlzLiRtZW51Lm9uKCdjbGljaycsICdhJywgdGhpcy5zY3JvbGxUby5iaW5kKHRoaXMpKTtcbiAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCB0aGlzLnVwZGF0ZVdhdGNoZXJzLmJpbmQodGhpcykpO1xufVxuXG5UT0MucHJvdG90eXBlLmdldFNlY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLiRtZW51LmZpbmQoJ2EnKS5tYXAoZnVuY3Rpb24oaWR4LCBlbG0pIHtcbiAgICByZXR1cm4gJChlbG0pLmF0dHIoJ2hyZWYnKTtcbiAgfSk7XG59O1xuXG5UT0MucHJvdG90eXBlLmFkZFdhdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZXR1cm4gdGhpcy5zZWN0aW9ucy5tYXAoZnVuY3Rpb24oaWR4LCBzZWN0aW9uKSB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VjdGlvbik7XG4gICAgdmFyIHdhdGNoZXIgPSBzY3JvbGxNb25pdG9yLmNyZWF0ZShlbG0sIHt0b3A6IHNlbGYub2Zmc2V0fSk7XG4gICAgd2F0Y2hlci4kbWVudUl0ZW0gPSBzZWxmLiRtZW51LmZpbmQoJ2FbaHJlZj1cIicgKyBzZWN0aW9uICsgJ1wiXScpO1xuICAgIHdhdGNoZXIuZW50ZXJWaWV3cG9ydChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuaGlnaGxpZ2h0QWN0aXZlSXRlbSh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2F0Y2hlcjtcbiAgfSk7XG59O1xuXG5UT0MucHJvdG90eXBlLmhpZ2hsaWdodEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbih3YXRjaGVyKSB7XG4gIHZhciAkY3VycmVudEhpZ2hsaWdodCA9IHRoaXMuJG1lbnUuZmluZCgnYS5pcy1hY3RpdmUnKTtcbiAgaWYgKHdhdGNoZXIuaXNJblZpZXdwb3J0KSB7XG4gICAgJGN1cnJlbnRIaWdobGlnaHQucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgIHdhdGNoZXIuJG1lbnVJdGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfVxufTtcblxuVE9DLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB2YXIgJGxpbmsgPSAkKGUudGFyZ2V0KTtcbiAgdmFyIHNlY3Rpb24gPSAkbGluay5hdHRyKCdocmVmJyk7XG4gIHZhciBzZWN0aW9uVG9wID0gJChzZWN0aW9uKS5vZmZzZXQoKS50b3AgKyAxMDtcbiAgJCgnYm9keSwgaHRtbCcpLmFuaW1hdGUoe1xuICAgIHNjcm9sbFRvcDogc2VjdGlvblRvcFxuICB9KTtcbn07XG5cblRPQy5wcm90b3R5cGUudXBkYXRlV2F0Y2hlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5ld09mZnNldCA9IC0xICogd2luZG93LmlubmVySGVpZ2h0O1xuICBfLmVhY2godGhpcy53YXRjaGVycywgZnVuY3Rpb24od2F0Y2hlcikge1xuICAgIHdhdGNoZXIub2Zmc2V0cy50b3AgPSBuZXdPZmZzZXQ7XG4gICAgd2F0Y2hlci5yZWNhbGN1bGF0ZUxvY2F0aW9uKCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFRPQzogVE9DIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvbW9kdWxlcy90b2MuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwic2Nyb2xsTW9uaXRvclwiLFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuc2Nyb2xsTW9uaXRvcj1lKCk6dC5zY3JvbGxNb25pdG9yPWUoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKG8pe2lmKGlbb10pcmV0dXJuIGlbb10uZXhwb3J0czt2YXIgcz1pW29dPXtleHBvcnRzOnt9LGlkOm8sbG9hZGVkOiExfTtyZXR1cm4gdFtvXS5jYWxsKHMuZXhwb3J0cyxzLHMuZXhwb3J0cyxlKSxzLmxvYWRlZD0hMCxzLmV4cG9ydHN9dmFyIGk9e307cmV0dXJuIGUubT10LGUuYz1pLGUucD1cIlwiLGUoMCl9KFtmdW5jdGlvbih0LGUsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89aSgxKSxzPW8uaXNJbkJyb3dzZXIsbj1pKDIpLHI9bmV3IG4ocz9kb2N1bWVudC5ib2R5Om51bGwpO3Iuc2V0U3RhdGVGcm9tRE9NKG51bGwpLHIubGlzdGVuVG9ET00oKSxzJiYod2luZG93LnNjcm9sbE1vbml0b3I9ciksdC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5WSVNJQklMSVRZQ0hBTkdFPVwidmlzaWJpbGl0eUNoYW5nZVwiLGUuRU5URVJWSUVXUE9SVD1cImVudGVyVmlld3BvcnRcIixlLkZVTExZRU5URVJWSUVXUE9SVD1cImZ1bGx5RW50ZXJWaWV3cG9ydFwiLGUuRVhJVFZJRVdQT1JUPVwiZXhpdFZpZXdwb3J0XCIsZS5QQVJUSUFMTFlFWElUVklFV1BPUlQ9XCJwYXJ0aWFsbHlFeGl0Vmlld3BvcnRcIixlLkxPQ0FUSU9OQ0hBTkdFPVwibG9jYXRpb25DaGFuZ2VcIixlLlNUQVRFQ0hBTkdFPVwic3RhdGVDaGFuZ2VcIixlLmV2ZW50VHlwZXM9W2UuVklTSUJJTElUWUNIQU5HRSxlLkVOVEVSVklFV1BPUlQsZS5GVUxMWUVOVEVSVklFV1BPUlQsZS5FWElUVklFV1BPUlQsZS5QQVJUSUFMTFlFWElUVklFV1BPUlQsZS5MT0NBVElPTkNIQU5HRSxlLlNUQVRFQ0hBTkdFXSxlLmlzT25TZXJ2ZXI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyxlLmlzSW5Ccm93c2VyPSFlLmlzT25TZXJ2ZXIsZS5kZWZhdWx0T2Zmc2V0cz17dG9wOjAsYm90dG9tOjB9fSxmdW5jdGlvbih0LGUsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gYz8wOnQ9PT1kb2N1bWVudC5ib2R5P3dpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDp0LmNsaWVudEhlaWdodH1mdW5jdGlvbiBuKHQpe3JldHVybiBjPzA6dD09PWRvY3VtZW50LmJvZHk/TWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCxkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpOnQuc2Nyb2xsSGVpZ2h0fWZ1bmN0aW9uIHIodCl7cmV0dXJuIGM/MDp0PT09ZG9jdW1lbnQuYm9keT93aW5kb3cucGFnZVlPZmZzZXR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcHx8ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A6dC5zY3JvbGxUb3B9dmFyIGg9aSgxKSxjPWguaXNPblNlcnZlcixhPWguaXNJbkJyb3dzZXIsbD1oLmV2ZW50VHlwZXMscD1pKDMpLHc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsaSl7ZnVuY3Rpb24gaCgpe2lmKGEudmlld3BvcnRUb3A9cihlKSxhLnZpZXdwb3J0Qm90dG9tPWEudmlld3BvcnRUb3ArYS52aWV3cG9ydEhlaWdodCxhLmRvY3VtZW50SGVpZ2h0PW4oZSksYS5kb2N1bWVudEhlaWdodCE9PXApe2Zvcih3PWEud2F0Y2hlcnMubGVuZ3RoO3ctLTspYS53YXRjaGVyc1t3XS5yZWNhbGN1bGF0ZUxvY2F0aW9uKCk7cD1hLmRvY3VtZW50SGVpZ2h0fX1mdW5jdGlvbiBjKCl7Zm9yKHU9YS53YXRjaGVycy5sZW5ndGg7dS0tOylhLndhdGNoZXJzW3VdLnVwZGF0ZSgpO2Zvcih1PWEud2F0Y2hlcnMubGVuZ3RoO3UtLTspYS53YXRjaGVyc1t1XS50cmlnZ2VyQ2FsbGJhY2tzKCl9byh0aGlzLHQpO3ZhciBhPXRoaXM7dGhpcy5pdGVtPWUsdGhpcy53YXRjaGVycz1bXSx0aGlzLnZpZXdwb3J0VG9wPW51bGwsdGhpcy52aWV3cG9ydEJvdHRvbT1udWxsLHRoaXMuZG9jdW1lbnRIZWlnaHQ9bihlKSx0aGlzLnZpZXdwb3J0SGVpZ2h0PXMoZSksdGhpcy5ET01MaXN0ZW5lcj1mdW5jdGlvbigpe3QucHJvdG90eXBlLkRPTUxpc3RlbmVyLmFwcGx5KGEsYXJndW1lbnRzKX0sdGhpcy5ldmVudFR5cGVzPWwsaSYmKHRoaXMuY29udGFpbmVyV2F0Y2hlcj1pLmNyZWF0ZShlKSk7dmFyIHAsdyx1O3RoaXMudXBkYXRlPWZ1bmN0aW9uKCl7aCgpLGMoKX0sdGhpcy5yZWNhbGN1bGF0ZUxvY2F0aW9ucz1mdW5jdGlvbigpe3RoaXMuZG9jdW1lbnRIZWlnaHQ9MCx0aGlzLnVwZGF0ZSgpfX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdGVuVG9ET009ZnVuY3Rpb24oKXthJiYod2luZG93LmFkZEV2ZW50TGlzdGVuZXI/KHRoaXMuaXRlbT09PWRvY3VtZW50LmJvZHk/d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLkRPTUxpc3RlbmVyKTp0aGlzLml0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuRE9NTGlzdGVuZXIpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5ET01MaXN0ZW5lcikpOih0aGlzLml0ZW09PT1kb2N1bWVudC5ib2R5P3dpbmRvdy5hdHRhY2hFdmVudChcIm9uc2Nyb2xsXCIsdGhpcy5ET01MaXN0ZW5lcik6dGhpcy5pdGVtLmF0dGFjaEV2ZW50KFwib25zY3JvbGxcIix0aGlzLkRPTUxpc3RlbmVyKSx3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLHRoaXMuRE9NTGlzdGVuZXIpKSx0aGlzLmRlc3Ryb3k9ZnVuY3Rpb24oKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcj8odGhpcy5pdGVtPT09ZG9jdW1lbnQuYm9keT8od2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLkRPTUxpc3RlbmVyKSx0aGlzLmNvbnRhaW5lcldhdGNoZXIuZGVzdHJveSgpKTp0aGlzLml0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuRE9NTGlzdGVuZXIpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5ET01MaXN0ZW5lcikpOih0aGlzLml0ZW09PT1kb2N1bWVudC5ib2R5Pyh3aW5kb3cuZGV0YWNoRXZlbnQoXCJvbnNjcm9sbFwiLHRoaXMuRE9NTGlzdGVuZXIpLHRoaXMuY29udGFpbmVyV2F0Y2hlci5kZXN0cm95KCkpOnRoaXMuaXRlbS5kZXRhY2hFdmVudChcIm9uc2Nyb2xsXCIsdGhpcy5ET01MaXN0ZW5lciksd2luZG93LmRldGFjaEV2ZW50KFwib25yZXNpemVcIix0aGlzLkRPTUxpc3RlbmVyKSl9KX0sdC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuRE9NTGlzdGVuZXI9ZnVuY3Rpb24odCl7dGhpcy5zZXRTdGF0ZUZyb21ET00odCl9LHQucHJvdG90eXBlLnNldFN0YXRlRnJvbURPTT1mdW5jdGlvbih0KXt2YXIgZT1yKHRoaXMuaXRlbSksaT1zKHRoaXMuaXRlbSksbz1uKHRoaXMuaXRlbSk7dGhpcy5zZXRTdGF0ZShlLGksbyx0KX0sdC5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24odCxlLGksbyl7dmFyIHM9ZSE9PXRoaXMudmlld3BvcnRIZWlnaHR8fGkhPT10aGlzLmNvbnRlbnRIZWlnaHQ7aWYodGhpcy5sYXRlc3RFdmVudD1vLHRoaXMudmlld3BvcnRUb3A9dCx0aGlzLnZpZXdwb3J0SGVpZ2h0PWUsdGhpcy52aWV3cG9ydEJvdHRvbT10K2UsdGhpcy5jb250ZW50SGVpZ2h0PWkscylmb3IodmFyIG49dGhpcy53YXRjaGVycy5sZW5ndGg7bi0tOyl0aGlzLndhdGNoZXJzW25dLnJlY2FsY3VsYXRlTG9jYXRpb24oKTt0aGlzLnVwZGF0ZUFuZFRyaWdnZXJXYXRjaGVycyhvKX0sdC5wcm90b3R5cGUudXBkYXRlQW5kVHJpZ2dlcldhdGNoZXJzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLndhdGNoZXJzLmxlbmd0aDtlLS07KXRoaXMud2F0Y2hlcnNbZV0udXBkYXRlKCk7Zm9yKGU9dGhpcy53YXRjaGVycy5sZW5ndGg7ZS0tOyl0aGlzLndhdGNoZXJzW2VdLnRyaWdnZXJDYWxsYmFja3ModCl9LHQucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUNvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiBuZXcgdH0sdC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyPWZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlP2U9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTplJiZlLmxlbmd0aD4wJiYoZT1lWzBdKTt2YXIgaT1uZXcgdChlLHRoaXMpO3JldHVybiBpLnNldFN0YXRlRnJvbURPTSgpLGkubGlzdGVuVG9ET00oKSxpfSx0LnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24odCxlKXtcInN0cmluZ1wiPT10eXBlb2YgdD90PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCk6dCYmdC5sZW5ndGg+MCYmKHQ9dFswXSk7dmFyIGk9bmV3IHAodGhpcyx0LGUpO3JldHVybiB0aGlzLndhdGNoZXJzLnB1c2goaSksaX0sdC5wcm90b3R5cGUuYmVnZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGUodCxlKX0sdH0oKTt0LmV4cG9ydHM9d30sZnVuY3Rpb24odCxlLGkpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8odCxlLGkpe2Z1bmN0aW9uIG8odCxlKXtpZigwIT09dC5sZW5ndGgpZm9yKEU9dC5sZW5ndGg7RS0tOylUPXRbRV0sVC5jYWxsYmFjay5jYWxsKHMsZSxzKSxULmlzT25lJiZ0LnNwbGljZShFLDEpfXZhciBzPXRoaXM7dGhpcy53YXRjaEl0ZW09ZSx0aGlzLmNvbnRhaW5lcj10LGk/aT09PStpP3RoaXMub2Zmc2V0cz17dG9wOmksYm90dG9tOml9OnRoaXMub2Zmc2V0cz17dG9wOmkudG9wfHx1LnRvcCxib3R0b206aS5ib3R0b218fHUuYm90dG9tfTp0aGlzLm9mZnNldHM9dSx0aGlzLmNhbGxiYWNrcz17fTtmb3IodmFyIGQ9MCxmPXcubGVuZ3RoO2Q8ZjtkKyspcy5jYWxsYmFja3Nbd1tkXV09W107dGhpcy5sb2NrZWQ9ITE7dmFyIG0sdixiLEksRSxUO3RoaXMudHJpZ2dlckNhbGxiYWNrcz1mdW5jdGlvbih0KXtzd2l0Y2godGhpcy5pc0luVmlld3BvcnQmJiFtJiZvKHRoaXMuY2FsbGJhY2tzW3JdLHQpLHRoaXMuaXNGdWxseUluVmlld3BvcnQmJiF2JiZvKHRoaXMuY2FsbGJhY2tzW2hdLHQpLHRoaXMuaXNBYm92ZVZpZXdwb3J0IT09YiYmdGhpcy5pc0JlbG93Vmlld3BvcnQhPT1JJiYobyh0aGlzLmNhbGxiYWNrc1tuXSx0KSx2fHx0aGlzLmlzRnVsbHlJblZpZXdwb3J0fHwobyh0aGlzLmNhbGxiYWNrc1toXSx0KSxvKHRoaXMuY2FsbGJhY2tzW2FdLHQpKSxtfHx0aGlzLmlzSW5WaWV3cG9ydHx8KG8odGhpcy5jYWxsYmFja3Nbcl0sdCksbyh0aGlzLmNhbGxiYWNrc1tjXSx0KSkpLCF0aGlzLmlzRnVsbHlJblZpZXdwb3J0JiZ2JiZvKHRoaXMuY2FsbGJhY2tzW2FdLHQpLCF0aGlzLmlzSW5WaWV3cG9ydCYmbSYmbyh0aGlzLmNhbGxiYWNrc1tjXSx0KSx0aGlzLmlzSW5WaWV3cG9ydCE9PW0mJm8odGhpcy5jYWxsYmFja3Nbbl0sdCksITApe2Nhc2UgbSE9PXRoaXMuaXNJblZpZXdwb3J0OmNhc2UgdiE9PXRoaXMuaXNGdWxseUluVmlld3BvcnQ6Y2FzZSBiIT09dGhpcy5pc0Fib3ZlVmlld3BvcnQ6Y2FzZSBJIT09dGhpcy5pc0JlbG93Vmlld3BvcnQ6byh0aGlzLmNhbGxiYWNrc1twXSx0KX1tPXRoaXMuaXNJblZpZXdwb3J0LHY9dGhpcy5pc0Z1bGx5SW5WaWV3cG9ydCxiPXRoaXMuaXNBYm92ZVZpZXdwb3J0LEk9dGhpcy5pc0JlbG93Vmlld3BvcnR9LHRoaXMucmVjYWxjdWxhdGVMb2NhdGlvbj1mdW5jdGlvbigpe2lmKCF0aGlzLmxvY2tlZCl7dmFyIHQ9dGhpcy50b3AsZT10aGlzLmJvdHRvbTtpZih0aGlzLndhdGNoSXRlbS5ub2RlTmFtZSl7dmFyIGk9dGhpcy53YXRjaEl0ZW0uc3R5bGUuZGlzcGxheTtcIm5vbmVcIj09PWkmJih0aGlzLndhdGNoSXRlbS5zdHlsZS5kaXNwbGF5PVwiXCIpO2Zvcih2YXIgcz0wLG49dGhpcy5jb250YWluZXI7bi5jb250YWluZXJXYXRjaGVyOylzKz1uLmNvbnRhaW5lcldhdGNoZXIudG9wLW4uY29udGFpbmVyV2F0Y2hlci5jb250YWluZXIudmlld3BvcnRUb3Asbj1uLmNvbnRhaW5lcldhdGNoZXIuY29udGFpbmVyO3ZhciByPXRoaXMud2F0Y2hJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RoaXMudG9wPXIudG9wK3RoaXMuY29udGFpbmVyLnZpZXdwb3J0VG9wLXMsdGhpcy5ib3R0b209ci5ib3R0b20rdGhpcy5jb250YWluZXIudmlld3BvcnRUb3AtcyxcIm5vbmVcIj09PWkmJih0aGlzLndhdGNoSXRlbS5zdHlsZS5kaXNwbGF5PWkpfWVsc2UgdGhpcy53YXRjaEl0ZW09PT0rdGhpcy53YXRjaEl0ZW0/dGhpcy53YXRjaEl0ZW0+MD90aGlzLnRvcD10aGlzLmJvdHRvbT10aGlzLndhdGNoSXRlbTp0aGlzLnRvcD10aGlzLmJvdHRvbT10aGlzLmNvbnRhaW5lci5kb2N1bWVudEhlaWdodC10aGlzLndhdGNoSXRlbToodGhpcy50b3A9dGhpcy53YXRjaEl0ZW0udG9wLHRoaXMuYm90dG9tPXRoaXMud2F0Y2hJdGVtLmJvdHRvbSk7dGhpcy50b3AtPXRoaXMub2Zmc2V0cy50b3AsdGhpcy5ib3R0b20rPXRoaXMub2Zmc2V0cy5ib3R0b20sdGhpcy5oZWlnaHQ9dGhpcy5ib3R0b20tdGhpcy50b3Asdm9pZCAwPT09dCYmdm9pZCAwPT09ZXx8dGhpcy50b3A9PT10JiZ0aGlzLmJvdHRvbT09PWV8fG8odGhpcy5jYWxsYmFja3NbbF0sbnVsbCl9fSx0aGlzLnJlY2FsY3VsYXRlTG9jYXRpb24oKSx0aGlzLnVwZGF0ZSgpLG09dGhpcy5pc0luVmlld3BvcnQsdj10aGlzLmlzRnVsbHlJblZpZXdwb3J0LGI9dGhpcy5pc0Fib3ZlVmlld3BvcnQsST10aGlzLmlzQmVsb3dWaWV3cG9ydH12YXIgcz1pKDEpLG49cy5WSVNJQklMSVRZQ0hBTkdFLHI9cy5FTlRFUlZJRVdQT1JULGg9cy5GVUxMWUVOVEVSVklFV1BPUlQsYz1zLkVYSVRWSUVXUE9SVCxhPXMuUEFSVElBTExZRVhJVFZJRVdQT1JULGw9cy5MT0NBVElPTkNIQU5HRSxwPXMuU1RBVEVDSEFOR0Usdz1zLmV2ZW50VHlwZXMsdT1zLmRlZmF1bHRPZmZzZXRzO28ucHJvdG90eXBlPXtvbjpmdW5jdGlvbih0LGUsaSl7c3dpdGNoKCEwKXtjYXNlIHQ9PT1uJiYhdGhpcy5pc0luVmlld3BvcnQmJnRoaXMuaXNBYm92ZVZpZXdwb3J0OmNhc2UgdD09PXImJnRoaXMuaXNJblZpZXdwb3J0OmNhc2UgdD09PWgmJnRoaXMuaXNGdWxseUluVmlld3BvcnQ6Y2FzZSB0PT09YyYmdGhpcy5pc0Fib3ZlVmlld3BvcnQmJiF0aGlzLmlzSW5WaWV3cG9ydDpjYXNlIHQ9PT1hJiZ0aGlzLmlzSW5WaWV3cG9ydCYmdGhpcy5pc0Fib3ZlVmlld3BvcnQ6aWYoZS5jYWxsKHRoaXMsdGhpcy5jb250YWluZXIubGF0ZXN0RXZlbnQsdGhpcyksaSlyZXR1cm59aWYoIXRoaXMuY2FsbGJhY2tzW3RdKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGFkZCBhIHNjcm9sbCBtb25pdG9yIGxpc3RlbmVyIG9mIHR5cGUgXCIrdCtcIi4gWW91ciBvcHRpb25zIGFyZTogXCIrdy5qb2luKFwiLCBcIikpO3RoaXMuY2FsbGJhY2tzW3RdLnB1c2goe2NhbGxiYWNrOmUsaXNPbmU6aXx8ITF9KX0sb2ZmOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuY2FsbGJhY2tzW3RdKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHJlbW92ZSBhIHNjcm9sbCBtb25pdG9yIGxpc3RlbmVyIG9mIHR5cGUgXCIrdCtcIi4gWW91ciBvcHRpb25zIGFyZTogXCIrdy5qb2luKFwiLCBcIikpO2Zvcih2YXIgaSxvPTA7aT10aGlzLmNhbGxiYWNrc1t0XVtvXTtvKyspaWYoaS5jYWxsYmFjaz09PWUpe3RoaXMuY2FsbGJhY2tzW3RdLnNwbGljZShvLDEpO2JyZWFrfX0sb25lOmZ1bmN0aW9uKHQsZSl7dGhpcy5vbih0LGUsITApfSxyZWNhbGN1bGF0ZVNpemU6ZnVuY3Rpb24oKXt0aGlzLmhlaWdodD10aGlzLndhdGNoSXRlbS5vZmZzZXRIZWlnaHQrdGhpcy5vZmZzZXRzLnRvcCt0aGlzLm9mZnNldHMuYm90dG9tLHRoaXMuYm90dG9tPXRoaXMudG9wK3RoaXMuaGVpZ2h0fSx1cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLmlzQWJvdmVWaWV3cG9ydD10aGlzLnRvcDx0aGlzLmNvbnRhaW5lci52aWV3cG9ydFRvcCx0aGlzLmlzQmVsb3dWaWV3cG9ydD10aGlzLmJvdHRvbT50aGlzLmNvbnRhaW5lci52aWV3cG9ydEJvdHRvbSx0aGlzLmlzSW5WaWV3cG9ydD10aGlzLnRvcDx0aGlzLmNvbnRhaW5lci52aWV3cG9ydEJvdHRvbSYmdGhpcy5ib3R0b20+dGhpcy5jb250YWluZXIudmlld3BvcnRUb3AsdGhpcy5pc0Z1bGx5SW5WaWV3cG9ydD10aGlzLnRvcD49dGhpcy5jb250YWluZXIudmlld3BvcnRUb3AmJnRoaXMuYm90dG9tPD10aGlzLmNvbnRhaW5lci52aWV3cG9ydEJvdHRvbXx8dGhpcy5pc0Fib3ZlVmlld3BvcnQmJnRoaXMuaXNCZWxvd1ZpZXdwb3J0fSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb250YWluZXIud2F0Y2hlcnMuaW5kZXhPZih0aGlzKSxlPXRoaXM7dGhpcy5jb250YWluZXIud2F0Y2hlcnMuc3BsaWNlKHQsMSk7Zm9yKHZhciBpPTAsbz13Lmxlbmd0aDtpPG87aSsrKWUuY2FsbGJhY2tzW3dbaV1dLmxlbmd0aD0wfSxsb2NrOmZ1bmN0aW9uKCl7dGhpcy5sb2NrZWQ9ITB9LHVubG9jazpmdW5jdGlvbigpe3RoaXMubG9ja2VkPSExfX07Zm9yKHZhciBkPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGkpe3RoaXMub24uY2FsbCh0aGlzLHQsZSxpKX19LGY9MCxtPXcubGVuZ3RoO2Y8bTtmKyspe3ZhciB2PXdbZl07by5wcm90b3R5cGVbdl09ZCh2KX10LmV4cG9ydHM9b31dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsTW9uaXRvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvc2Nyb2xsbW9uaXRvci9zY3JvbGxNb25pdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogU3RpY2t5XHJcbiAqIEBtb2R1bGVcclxuICovXHJcblxyXG5cclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKTtcclxudmFyIG9uID0gcmVxdWlyZSgnZW1teS9vbicpO1xyXG52YXIgb2ZmID0gcmVxdWlyZSgnZW1teS9vZmYnKTtcclxudmFyIGVtaXQgPSByZXF1aXJlKCdlbW15L2VtaXQnKTtcclxudmFyIGdldE9mZnNldHMgPSByZXF1aXJlKCdtdWNzcy9vZmZzZXRzJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGlja3k7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gU3RpY2t5KGVsLCBvcHRpb25zKXtcclxuXHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1pZCcpID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBjb25zb2xlLmxvZygnU3RpY2t5IGFscmVhZHkgZXhpc3QnKTtcclxuXHR9XHJcblxyXG5cdHRoaXMuZWwgPSBlbDtcclxuXHR0aGlzLnBhcmVudCA9IHRoaXMuZWwucGFyZW50Tm9kZTtcclxuXHJcblx0Ly9yZWNvZ25pemUgYXR0cmlidXRlc1xyXG5cdHZhciBkYXRhc2V0ID0gZWwuZGF0YXNldDtcclxuXHRpZiAoIWRhdGFzZXQpe1xyXG5cdFx0ZGF0YXNldCA9IHt9O1xyXG5cdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS13aXRoaW4nKSkgZGF0YXNldFsnd2l0aGluJ10gPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2l0aGluJyk7XHJcblx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW9mZnNldCcpKSBkYXRhc2V0WydvZmZzZXQnXSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vZmZzZXQnKTtcclxuXHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2snKSkgZGF0YXNldFsnc3RhY2snXSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGFjaycpO1xyXG5cdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGlja3ktY2xhc3MnKSkgZGF0YXNldFsnc3RpY2t5Q2xhc3MnXSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGlja3ktY2xhc3MnKTtcclxuXHR9XHJcblx0dGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIGRhdGFzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHQvL3F1ZXJ5IHNlbGVjdG9yLCBpZiBwYXNzZWQgb25lXHJcblx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zWyd3aXRoaW4nXSA9PT0gJ3N0cmluZycgJiYgdGhpcy5vcHRpb25zWyd3aXRoaW4nXS50cmltKCkgKXtcclxuXHRcdHRoaXMud2l0aGluID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9uc1snd2l0aGluJ10pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLndpdGhpbiA9IHRoaXMub3B0aW9uc1snd2l0aGluJ107XHJcblx0fVxyXG5cclxuXHQvL2tlZXAgbGlzdFxyXG5cdHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1pZCcsIFN0aWNreS5saXN0Lmxlbmd0aCk7XHJcblx0dGhpcy5pZCA9IFN0aWNreS5saXN0Lmxlbmd0aDtcclxuXHRTdGlja3kubGlzdC5wdXNoKHRoaXMpO1xyXG5cclxuXHQvL3N0YXRlXHJcblx0dGhpcy5pc0ZpeGVkID0gZmFsc2U7XHJcblx0dGhpcy5pc0JvdHRvbSA9IGZhbHNlO1xyXG5cdHRoaXMuaXNUb3AgPSB0cnVlO1xyXG5cdHRoaXMudXBkYXRlQ2xhc3NlcygpO1xyXG5cclxuXHQvL2JvdW5kYXJpZXMgdG8gc3RyaWN0IHdpdGhpblxyXG5cdHRoaXMucmVzdHJpY3RCb3ggPSB7XHJcblx0XHR0b3A6IDAsXHJcblx0XHRib3R0b206IDk5OTlcclxuXHR9O1xyXG5cclxuXHQvL3NlbGYgcG9zaXRpb24gJiBzaXplXHJcblx0dGhpcy5oZWlnaHQgPSAwO1xyXG5cdHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuXHQvL3BhcmVudCBwb3NpdGlvbiAmIHNpemVcclxuXHR0aGlzLnBhcmVudEJveCA9IHtcclxuXHRcdHRvcDogMCxcclxuXHRcdGhlaWdodDogMFxyXG5cdH1cclxuXHJcblx0Ly9taW5kIGdhcCBmcm9tIGJvdHRvbSAmIHRvcCBpbiBhZGRpdGlvbiB0byByZXN0cmljdEJveCAoZm9yIHN0YWNrcylcclxuXHR0aGlzLm9wdGlvbnMub2Zmc2V0ID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnNbJ29mZnNldCddKSB8fCAwO1xyXG5cdHRoaXMub2Zmc2V0ID0ge1xyXG5cdFx0dG9wOiAwLFxyXG5cdFx0Ym90dG9tOiAwXHJcblx0fTtcclxuXHJcblx0Ly9hZGRpdGlvbmFsIGdhcCBpZiBpdGVtIGJlaW5nIHNjcm9sbGVkXHJcblx0dGhpcy5zY3JvbGxPZmZzZXQgPSAwO1xyXG5cclxuXHQvL0RldGVjdCB3aGV0aGVyIHN0YWNraW5nIGlzIG5lZWRlZFxyXG5cdHZhciBwcmV2RWwgPSB0aGlzLmVsO1xyXG5cdHRoaXMuc3RhY2tJZCA9IFtdO1xyXG5cdHRoaXMuc3RhY2sgPSBbXTtcclxuXHRpZiAodGhpcy5vcHRpb25zWydzdGFjayddKSB7XHJcblx0XHR2YXIgc3RhY2sgPSB0aGlzLm9wdGlvbnNbJ3N0YWNrJ10uc3BsaXQoJywnKTtcclxuXHRcdGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IGktLTspe1xyXG5cdFx0XHRzdGFja1tpXSA9IHN0YWNrW2ldLnRyaW0oKTtcclxuXHRcdFx0aWYgKCFTdGlja3kuc3RhY2tbc3RhY2tbaV1dKSBTdGlja3kuc3RhY2tbc3RhY2tbaV1dID0gW107XHJcblx0XHRcdHRoaXMuc3RhY2tJZFtpXSA9IFN0aWNreS5zdGFja1tzdGFja1tpXV0ubGVuZ3RoO1xyXG5cdFx0XHR0aGlzLnN0YWNrLnB1c2goc3RhY2tbaV0pO1xyXG5cdFx0XHRTdGlja3kuc3RhY2tbc3RhY2tbaV1dLnB1c2godGhpcylcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5zdGFja0lkWzBdID0gU3RpY2t5Lm5vU3RhY2subGVuZ3RoO1xyXG5cdFx0U3RpY2t5Lm5vU3RhY2sucHVzaCh0aGlzKTtcclxuXHR9XHJcblxyXG5cclxuXHQvL3N0dWIgaXMgYSBzcGFjZXIgZmlsbGluZyBzcGFjZSB3aGVuIGVsZW1lbnQgaXMgc3R1Y2tcclxuXHR0aGlzLnN0dWIgPSB0aGlzLmVsLmNsb25lTm9kZSgpO1xyXG5cdHRoaXMuc3R1Yi5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9uc1snc3R1YkNsYXNzJ10pO1xyXG5cdHRoaXMuc3R1Yi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0dGhpcy5zdHViLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0dGhpcy5zdHViLnJlbW92ZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XHJcblxyXG5cdC8vc2F2ZSBpbml0aWFsIGlubGluZSBzdHlsZVxyXG5cdHRoaXMuaW5pdGlhbFN0eWxlID0gdGhpcy5lbC5zdHlsZS5jc3NUZXh0O1xyXG5cdHRoaXMuaW5pdGlhbERpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpWydkaXNwbGF5J107XHJcblxyXG5cdC8vZW5zdXJlIHBhcmVudCdzIGNvbnRhaW5lciByZWxhdGl2ZSBjb29yZGluYXRlc1xyXG5cdHZhciBwU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMucGFyZW50KTtcclxuXHRpZiAocFN0eWxlLnBvc2l0aW9uID09ICdzdGF0aWMnKSB0aGlzLnBhcmVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblxyXG5cdC8vYmluZCBtZXRob2RzXHJcblx0dGhpcy5jaGVjayA9IHRoaXMuY2hlY2suYmluZCh0aGlzKTtcclxuXHR0aGlzLnJlY2FsYyA9IHRoaXMucmVjYWxjLmJpbmQodGhpcyk7XHJcblx0dGhpcy5kaXNhYmxlID0gdGhpcy5kaXNhYmxlLmJpbmQodGhpcyk7XHJcblx0dGhpcy5lbmFibGUgPSB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpO1xyXG5cdHRoaXMuYmluZEV2ZW50cyA9IHRoaXMuYmluZEV2ZW50cy5iaW5kKHRoaXMpO1xyXG5cdHRoaXMuYWRqdXN0U2l6ZUFuZFBvc2l0aW9uID0gdGhpcy5hZGp1c3RTaXplQW5kUG9zaXRpb24uYmluZCh0aGlzKTtcclxuXHR0aGlzLnBhcmsgPSB0aGlzLnBhcmsuYmluZCh0aGlzKTtcclxuXHR0aGlzLnN0aWNrID0gdGhpcy5zdGljay5iaW5kKHRoaXMpO1xyXG5cdHRoaXMucGFya1N0YWNrID0gdGhpcy5wYXJrU3RhY2suYmluZCh0aGlzKTtcclxuXHR0aGlzLnN0aWNrU3RhY2sgPSB0aGlzLnN0aWNrU3RhY2suYmluZCh0aGlzKTtcclxuXHR0aGlzLmNhcHR1cmVTY3JvbGxPZmZzZXQgPSB0aGlzLmNhcHR1cmVTY3JvbGxPZmZzZXQuYmluZCh0aGlzKTtcclxuXHR0aGlzLm9ic2VydmVTdGFja1Njcm9sbCA9IHRoaXMub2JzZXJ2ZVN0YWNrU2Nyb2xsLmJpbmQodGhpcyk7XHJcblx0dGhpcy5zdG9wT2JzZXJ2aW5nU3RhY2tTY3JvbGwgPSB0aGlzLnN0b3BPYnNlcnZpbmdTdGFja1Njcm9sbC5iaW5kKHRoaXMpO1xyXG5cclxuXHRpZiAodGhpcy5pbml0aWFsRGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcblx0XHR0aGlzLmluaXRpYWxEaXNwbGF5ID0gJ2Jsb2NrJztcclxuXHRcdHRoaXMuZGlzYWJsZSgpO1xyXG5cdH1cclxuXHRlbHNlIHRoaXMuZW5hYmxlKCk7XHJcbn1cclxuXHJcbi8vbGlzdCBvZiBpbnN0YW5jZXNcclxuU3RpY2t5Lmxpc3QgPSBbXTtcclxuLy9tdXR1YWxseSBleGNsdXNpdmUgaXRlbXNcclxuU3RpY2t5Lm5vU3RhY2sgPSBbXTtcclxuLy9zdGFja3Mgb2YgaXRlbXNcclxuU3RpY2t5LnN0YWNrID0ge307XHJcbi8vaGVpZ2h0cyBvZiBzdGFja3NcclxuU3RpY2t5LnN0YWNrSGVpZ2h0cyA9IHt9O1xyXG5cclxuXHJcbi8qKiBVcGRhdGUgYWxsIHN0aWNreSBpbnN0YW5jZXMgKi9cclxuU3RpY2t5LnJlY2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuXHRTdGlja3kubGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdFx0aW5zdGFuY2UucmVjYWxjKCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuLyoqIEFQSSBldmVudHMgKi9cclxub24oZG9jdW1lbnQsICdzdGlja3k6cmVjYWxjJywgU3RpY2t5LnJlY2FsYyk7XHJcblxyXG5cclxudmFyIHByb3RvID0gU3RpY2t5LnByb3RvdHlwZTtcclxuXHJcblxyXG5wcm90by5vcHRpb25zID0ge1xyXG5cdCdvZmZzZXQnOiAwLFxyXG5cdCd3aXRoaW4nOiBudWxsLCAvL2VsZW1lbnQgb3IgYm91bmRpbmcgYm94XHJcblx0J3N0dWJDbGFzcyc6ICdzdGlja3ktc3R1YicsXHJcblx0J3N0aWNreUNsYXNzJzogJ2lzLXN0dWNrJyxcclxuXHQnYm90dG9tQ2xhc3MnOiAnaXMtYm90dG9tJyxcclxuXHQndG9wQ2xhc3MnOiAnaXMtdG9wJyxcclxuXHQnc3RhY2snOiBudWxsLFxyXG5cdCdjb2xsYXBzZSc6IHRydWUsXHJcblx0J3JlY2FsY0ludGVydmFsJzogMjBcclxufTtcclxuXHJcblxyXG4vKiogd2hlbiBlbGVtZW50IHJlbW92ZWQgb3IgbWFkZSBoaWRkZW4uICovXHJcbnByb3RvLmRpc2FibGUgPSBmdW5jdGlvbigpe1xyXG5cdGlmICh0aGlzLnN0dWIucGFyZW50Tm9kZSkgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5zdHViKTtcclxuXHR0aGlzLnVuYmluZEV2ZW50cygpO1xyXG5cdHRoaXMuaXNEaXNhYmxlZCA9IHRydWU7XHJcblx0U3RpY2t5LnJlY2FsYygpO1xyXG59O1xyXG5cclxuXHJcbi8qKiBlbmFibGVzIHByZXZpb3VzbHkgZGlzYWJsZWQgZWxlbWVudCAqL1xyXG5wcm90by5lbmFibGUgPSBmdW5jdGlvbigpe1xyXG5cdGlmICghdGhpcy5zdHViLnBhcmVudE5vZGUpIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLnN0dWIsIHRoaXMuZWwpO1xyXG5cdHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cdHRoaXMuYmluZEV2ZW50cygpO1xyXG5cdFN0aWNreS5yZWNhbGMoKTtcclxufTtcclxuXHJcblxyXG5wcm90by5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKXtcclxuXHRvbihkb2N1bWVudCwgJ3Njcm9sbCcsIHRoaXMuY2hlY2spO1xyXG5cdG9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVjYWxjKTtcclxuXHRvbih0aGlzLmVsLCAnbW91c2VvdmVyJywgdGhpcy5vYnNlcnZlU3RhY2tTY3JvbGwpO1xyXG5cdG9uKHRoaXMuZWwsICdtb3VzZW91dCcsIHRoaXMuc3RvcE9ic2VydmluZ1N0YWNrU2Nyb2xsKTtcclxufTtcclxuXHJcblxyXG5wcm90by51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpe1xyXG5cdG9mZihkb2N1bWVudCwgJ3Njcm9sbCcsIHRoaXMuY2hlY2spO1xyXG5cdG9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLnJlY2FsYyk7XHJcblx0b2ZmKHRoaXMuZWwsICdtb3VzZW92ZXInLCB0aGlzLm9ic2VydmVTdGFja1Njcm9sbCk7XHJcblx0b2ZmKHRoaXMuZWwsICdtb3VzZW91dCcsIHRoaXMuc3RvcE9ic2VydmluZ1N0YWNrU2Nyb2xsKTtcclxufTtcclxuXHJcblxyXG4vKiogY2hhbmdpbmcgc3RhdGUgbmVjZXNzaXR5IGNoZWNrZXIgKi9cclxucHJvdG8uY2hlY2sgPSBmdW5jdGlvbigpe1xyXG5cdHZhciB2cFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG5cdC8vY29uc29sZS5sb2coJ2NoZWNrOicgKyB0aGlzLmVsLmRhdGFzZXRbJ3N0aWNreUlkJ10sICdpc0ZpeGVkOicgKyB0aGlzLmlzRml4ZWQsIHRoaXMucmVzdHJpY3RCb3gpXHJcblx0aWYgKHRoaXMuaXNGaXhlZCl7XHJcblx0XHRpZiAoIXRoaXMuaXNUb3AgJiYgdnBUb3AgKyB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgdGhpcy5oZWlnaHQgKyB0aGlzLm10ICsgdGhpcy5tYiArIHRoaXMuc2Nyb2xsT2Zmc2V0ID49IHRoaXMucmVzdHJpY3RCb3guYm90dG9tIC0gdGhpcy5vZmZzZXQuYm90dG9tKXtcclxuXHRcdFx0Ly9jaGVjayBib3R0b20gcGFya2luZyBuZWVkZWRcclxuXHRcdFx0dGhpcy5wYXJrQm90dG9tKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRoaXMuaXNCb3R0b20gJiYgdnBUb3AgKyB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgdGhpcy5tdCArIHRoaXMuc2Nyb2xsT2Zmc2V0IDw9IHRoaXMucmVzdHJpY3RCb3gudG9wKXtcclxuXHRcdFx0Ly9jaGVjayB0b3AgcGFya2luZyBuZWVkZWRcclxuXHRcdFx0dGhpcy5wYXJrVG9wKCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmICh0aGlzLmlzVG9wIHx8IHRoaXMuaXNCb3R0b20pe1xyXG5cdFx0XHRpZiAodnBUb3AgKyB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgdGhpcy5tdCA+IHRoaXMucmVzdHJpY3RCb3gudG9wKXtcclxuXHRcdFx0XHQvL2ZyaW5nZSB2aW9sYXRpb24gZnJvbSB0b3BcclxuXHRcdFx0XHRpZiAodnBUb3AgKyB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgdGhpcy5oZWlnaHQgKyB0aGlzLm10ICsgdGhpcy5tYiA8IHRoaXMucmVzdHJpY3RCb3guYm90dG9tIC0gdGhpcy5vZmZzZXQuYm90dG9tKXtcclxuXHRcdFx0XHRcdC8vZnJpbmdlIHZpb2xhdGlvbiBmcm9tIHRvcCBvciBib3R0b20gdG8gdGhlIHN0aWNraW5nIHpvbmVcclxuXHRcdFx0XHRcdHRoaXMuc3RpY2soKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCF0aGlzLmlzQm90dG9tKSB7XHJcblx0XHRcdFx0XHQvL2ZyaW5nZSB2aW9sYXRpb24gZnJvbSB0b3AgbG93ZXIgdGhhbiBib3R0b21cclxuXHRcdFx0XHRcdHRoaXMuc3RpY2soKTtcclxuXHRcdFx0XHRcdHRoaXMucGFya0JvdHRvbSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmKHRoaXMuaXNCb3R0b20pe1xyXG5cdFx0XHRcdC8vZnJpbmdlIHZpb2xhdGlvbiBmcm9tIGJvdHRvbSB0byBoaWdoZXIgdGhhbiB0b3BcclxuXHRcdFx0XHR0aGlzLnN0aWNrKCk7XHJcblx0XHRcdFx0dGhpcy5wYXJrVG9wKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIHN0aWNraW5nIGlubmVyIHJvdXRpbmVzXHJcbiAqIHdoZW4gcGFyayB0b3AgbmVlZGVkXHJcbiAqL1xyXG5wcm90by5wYXJrVG9wID0gZnVuY3Rpb24oKXtcclxuXHQvL3RoaXMuZWwgPSB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcclxuXHR0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB0aGlzLmluaXRpYWxTdHlsZTtcclxuXHQvL3RoaXMuc3R1YiA9IHRoaXMucGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLmVsLCB0aGlzLnN0dWIpO1xyXG5cdHRoaXMuc3R1Yi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuXHR0aGlzLnNjcm9sbE9mZnNldCA9IDA7XHJcblxyXG5cdHRoaXMuaXNGaXhlZCA9IGZhbHNlO1xyXG5cdHRoaXMuaXNUb3AgPSB0cnVlO1xyXG5cdHRoaXMuaXNCb3R0b20gPSBmYWxzZTtcclxuXHR0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcclxuXHJcblx0dGhpcy5pc1N0YWNrUGFya2VkID0gdHJ1ZTtcclxuXHJcblx0Ly8gY29uc29sZS5sb2coJ3BhcmtUb3AnLCB0aGlzLmlkKVxyXG59O1xyXG5cclxuXHJcbi8qKiB3aGVuIHN0b3AgbmVlZGVkIHNvbWV3aGVyZSBpbiBiZXR3ZWVuIHRvcCBhbmQgYm90dG9tICovXHJcbnByb3RvLnBhcmsgPSBmdW5jdGlvbigpe1xyXG5cdC8vIGNvbnNvbGUubG9nKCdwYXJrTWlkZGxlJywgdGhpcy5pZClcclxuXHJcblx0dGhpcy5pc0ZpeGVkID0gZmFsc2U7XHJcblx0dGhpcy5pc1RvcCA9IGZhbHNlO1xyXG5cdHRoaXMuaXNCb3R0b20gPSBmYWxzZTtcclxuXHR0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcclxuXHJcblx0dGhpcy5pc1N0YWNrUGFya2VkID0gdHJ1ZTtcclxuXHJcblx0dmFyIG9mZnNldCA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgKyB0aGlzLm9mZnNldC50b3AgLSB0aGlzLnBhcmVudEJveC50b3AgKyB0aGlzLnNjcm9sbE9mZnNldDtcclxuXHR0aGlzLm1ha2VQYXJrZWRTdHlsZShvZmZzZXQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIHRvIG1ha2UgZml4ZWRcclxuICogZW5oYW5jZWQgcmVwbGFjZTogZmFrZWQgdmlzdWFsIHN0dWIgaXMgZmFzdGx5IHJlcGxhY2VkIHdpdGggbmF0dXJhbCBvbmVcclxuICovXHJcbnByb3RvLnN0aWNrID0gZnVuY3Rpb24oKXtcclxuXHQvL3RoaXMuZWwgPSB0aGlzLnBhcmVudC5yZXBsYWNlQ2hpbGQodGhpcy5zdHViLCB0aGlzLmVsKTtcclxuXHR0aGlzLnN0dWIuc3R5bGUuZGlzcGxheSA9IHRoaXMuaW5pdGlhbERpc3BsYXk7XHJcblx0dGhpcy5tYWtlU3RpY2tlZFN0eWxlKCk7XHJcblx0Ly90aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5lbCwgdGhpcy5zdHViKTtcclxuXHJcblx0dGhpcy5pc0ZpeGVkID0gdHJ1ZTtcclxuXHR0aGlzLmlzVG9wID0gZmFsc2U7XHJcblx0dGhpcy5pc0JvdHRvbSA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlQ2xhc3NlcygpO1xyXG5cclxuXHR0aGlzLmlzU3RhY2tQYXJrZWQgPSBmYWxzZTtcclxuXHJcblx0Ly8gY29uc29sZS5sb2coJ3N0aWNrJywgdGhpcy5pZClcclxufTtcclxuXHJcblxyXG4vKiogd2hlbiBib3R0b20gbGFuZCBuZWVkZWQgKi9cclxucHJvdG8ucGFya0JvdHRvbSA9IGZ1bmN0aW9uKCl7XHJcblx0dGhpcy5tYWtlUGFya2VkQm90dG9tU3R5bGUoKTtcclxuXHJcblx0dGhpcy5zY3JvbGxPZmZzZXQgPSAwO1xyXG5cclxuXHR0aGlzLmlzRml4ZWQgPSBmYWxzZTtcclxuXHR0aGlzLmlzQm90dG9tID0gdHJ1ZTtcclxuXHR0aGlzLmlzVG9wID0gZmFsc2U7XHJcblx0dGhpcy51cGRhdGVDbGFzc2VzKCk7XHJcblxyXG5cdHRoaXMuaXNTdGFja1BhcmtlZCA9IHRydWU7XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKCdwYXJrQm90dG9tJywgdGhpcy5pZClcclxufTtcclxuXHJcblxyXG4vKipcclxuICogcGFyayBhbGwgaXRlbXMgd2l0aGluIHN0YWNrIHBhc3NlZC9hbGwgc3RhY2tzIG9mIHRoaXNcclxuICogdXNlZCB3aGVuIGl0ZW0gd2FzIHNjcm9sbGVkIG9uXHJcbiAqL1xyXG5wcm90by5wYXJrU3RhY2sgPSBmdW5jdGlvbigpe1xyXG5cdHZhciBzdGFjayA9IFN0aWNreS5zdGFja1t0aGlzLnN0YWNrWzBdXTtcclxuXHR2YXIgZmlyc3QgPSBzdGFja1swXSwgbGFzdCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKXtcclxuXHRcdHZhciBpdGVtID0gc3RhY2tbaV1cclxuXHRcdGl0ZW0ucGFyaygpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKiogdW5wYXJrIGFsbCBpdGVtcyBvZiBzdGFjayBwYXNzZWQgKi9cclxucHJvdG8uc3RpY2tTdGFjayA9IGZ1bmN0aW9uKCl7XHJcblx0dmFyIHN0YWNrID0gU3RpY2t5LnN0YWNrW3RoaXMuc3RhY2tbMF1dXHJcblx0dmFyIGZpcnN0ID0gc3RhY2tbMF0sIGxhc3QgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKyl7XHJcblx0XHR2YXIgaXRlbSA9IHN0YWNrW2ldXHJcblx0XHRpdGVtLnN0aWNrKCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGJlZ2luIG9ic2VydmluZyBzY3JvbGwgdG8gcGFyayBzdGFja1xyXG4gKi9cclxucHJvdG8ub2JzZXJ2ZVN0YWNrU2Nyb2xsID0gZnVuY3Rpb24oKXtcclxuXHR2YXIgc3RhY2sgPSBTdGlja3kuc3RhY2tbdGhpcy5zdGFja1swXV1cclxuXHRpZiAoIXN0YWNrKSByZXR1cm47XHJcblxyXG5cdHZhciBmaXJzdCA9IHN0YWNrWzBdLCBsYXN0ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblxyXG5cdC8vaWYgc3RhY2sgaXMgcGFya2VkIHRvcCBvciBwYXJrZWQgYm90dG9tIC0gaWdub3JlXHJcblx0aWYgKGZpcnN0LmlzVG9wIHx8IGxhc3QuaXNUb3ApIHJldHVybjtcclxuXHJcblx0Ly9pZiBzdGFjayBpc27igJl0IGhpZ2hlciB0aGFuIHdpbmRvdyBoZWlnaHQgLSBpZ25vcmVcclxuXHRpZiAoU3RpY2t5LnN0YWNrSGVpZ2h0c1t0aGlzLnN0YWNrWzBdXSA8PSB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgdGhpcy5zY3JvbGxPZmZzZXQgPj0gMCkgcmV0dXJuO1xyXG5cclxuXHQvL2NhcHR1cmUgc3RhY2vigJlzIHNjcm9sbFxyXG5cdHRoaXMuc2Nyb2xsU3RhcnRPZmZzZXQgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApICsgdGhpcy5zY3JvbGxPZmZzZXQ7XHJcblxyXG5cdG9uKGRvY3VtZW50LCAnc2Nyb2xsJywgdGhpcy5jYXB0dXJlU2Nyb2xsT2Zmc2V0KTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKiogc3RvcCBvYnNlcnZpbmcgc2Nyb2xsICovXHJcbnByb3RvLnN0b3BPYnNlcnZpbmdTdGFja1Njcm9sbCA9IGZ1bmN0aW9uKCl7XHJcblx0dmFyIHN0YWNrID0gU3RpY2t5LnN0YWNrW3RoaXMuc3RhY2tbMF1dO1xyXG5cdGlmICghc3RhY2spIHJldHVybjtcclxuXHJcblx0dmFyIGxhc3QgPSBzdGFja1tzdGFjay5sZW5ndGgtMV0sIGZpcnN0ID0gc3RhY2tbMF07XHJcblxyXG5cdG9mZihkb2N1bWVudCwgJ3Njcm9sbCcsIHRoaXMuY2FwdHVyZVNjcm9sbE9mZnNldCk7XHJcblxyXG5cdGlmIChmaXJzdC5pc1RvcCB8fCBmaXJzdC5pc0JvdHRvbSB8fCBsYXN0LmlzVG9wIHx8IGxhc3QuaXNCb3R0b20pIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0aWYgKHRoaXMuaXNTdGFja1BhcmtlZCkgdGhpcy5zdGlja1N0YWNrKCk7XHJcbn07XHJcblxyXG4vKiogd2hlbiBpdGVtIHdhcyBzY3JvbGxlZCBvbiAtIGNhcHR1cmUgaG93IG11Y2ggaXQgaXMgc2Nyb2xsZWQgKi9cclxucHJvdG8uY2FwdHVyZVNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uKGUpe1xyXG5cclxuXHR2YXIgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5zY3JvbGxTdGFydE9mZnNldCAtICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XHJcblx0dmFyIHN0YWNrID0gU3RpY2t5LnN0YWNrW3RoaXMuc3RhY2tbMF1dO1xyXG5cdHZhciBsYXN0ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdLCBmaXJzdCA9IHN0YWNrWzBdO1xyXG5cclxuXHQvL2lnbm9yZSBvdXRzaWRlIHN0aWNraW5nXHJcblx0aWYgKGZpcnN0LmlzVG9wIHx8IGZpcnN0LmlzQm90dG9tIHx8IGxhc3QuaXNUb3AgfHwgbGFzdC5pc0JvdHRvbSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dmFyIHN0aWNrTmVlZGVkID0gZmFsc2UsIHBhcmtOZWVkZWQgPSBmYWxzZTtcclxuXHJcblx0Ly9pZiBib3R0b20gaXMgaGlnaGVyIG9yIGVxdWFsIHRoYW4gdmlld3BvcnTigJlzIGJvdHRvbSAtIHN0aWNrIHdpdGhpbiB2aWV3cG9ydFxyXG5cdGlmICggc2Nyb2xsT2Zmc2V0IDwgd2luZG93LmlubmVySGVpZ2h0IC0gKFN0aWNreS5zdGFja0hlaWdodHNbdGhpcy5zdGFja1swXV0pICl7XHJcblx0XHRzY3JvbGxPZmZzZXQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAoU3RpY2t5LnN0YWNrSGVpZ2h0c1t0aGlzLnN0YWNrWzBdXSk7XHJcblx0XHR0aGlzLnNjcm9sbFN0YXJ0T2Zmc2V0ID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSArIHNjcm9sbE9mZnNldDtcclxuXHRcdHN0aWNrTmVlZGVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vaWYgdG9wIGlzIGxvd2VyIG9yIGVxdWFsIHRvIHRoZSB2aWV3cG9ydOKAmXMgdG9wIC0gc3RpY2sgd2l0aGluIHZpZXdwb3J0XHJcblx0ZWxzZSBpZiAoIHNjcm9sbE9mZnNldCA+IDApe1xyXG5cdFx0c2Nyb2xsT2Zmc2V0ID0gMDtcclxuXHRcdHRoaXMuc2Nyb2xsU3RhcnRPZmZzZXQgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xyXG5cdFx0c3RpY2tOZWVkZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly9pZiBzdGFjayBpdGVtcyBpcyBzb21ld2hlcmUgaW4gYmV0d2VlblxyXG5cdGVsc2UgaWYgKCF0aGlzLmlzU3RhY2tQYXJrZWQgKXtcclxuXHRcdHBhcmtOZWVkZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKyl7XHJcblx0XHR2YXIgaXRlbSA9IHN0YWNrW2ldXHJcblx0XHRpdGVtLnNjcm9sbE9mZnNldCA9IHNjcm9sbE9mZnNldFxyXG5cdH1cclxuXHJcblx0aWYgKHN0aWNrTmVlZGVkICYmIHRoaXMuaXNTdGFja1BhcmtlZCkgcmV0dXJuIHRoaXMuc3RpY2tTdGFjaygpO1xyXG5cdGVsc2UgaWYgKHBhcmtOZWVkZWQgJiYgIXRoaXMuaXNTdGFja1BhcmtlZCkgcmV0dXJuIHRoaXMucGFya1N0YWNrKCk7XHJcbn07XHJcblxyXG4vKiogc2V0IHVwIHN0eWxlIG9mIGVsZW1lbnQgYXMgaWYgaXQgaXMgcGFya2VkIHNvbWV3aGVyZSAvIGF0IHRoZSBib3R0b20gKi9cclxucHJvdG8ubWFrZVBhcmtlZFN0eWxlID0gZnVuY3Rpb24odG9wKXtcclxuXHR0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB0aGlzLmluaXRpYWxTdHlsZTtcclxuXHR0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHR0aGlzLmVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XHJcblx0bWltaWNTdHlsZSh0aGlzLmVsLCB0aGlzLnN0dWIpO1xyXG5cdHRoaXMuZWwuc3R5bGUubGVmdCA9IHRoaXMuc3R1Yi5vZmZzZXRMZWZ0ICsgJ3B4JztcclxufTtcclxuXHJcbnByb3RvLm1ha2VQYXJrZWRCb3R0b21TdHlsZSA9IGZ1bmN0aW9uKCl7XHJcblx0dGhpcy5tYWtlUGFya2VkU3R5bGUodGhpcy5yZXN0cmljdEJveC5ib3R0b20gLSB0aGlzLm9mZnNldC5ib3R0b20gLSB0aGlzLnBhcmVudEJveC50b3AgLSB0aGlzLmhlaWdodCAtIHRoaXMubXQgLSB0aGlzLm1iKTtcclxufTtcclxuXHJcbnByb3RvLm1ha2VTdGlja2VkU3R5bGUgPSBmdW5jdGlvbigpe1xyXG5cdHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHRoaXMuaW5pdGlhbFN0eWxlO1xyXG5cdHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG5cdHRoaXMuZWwuc3R5bGUudG9wID0gdGhpcy5vZmZzZXQudG9wICsgdGhpcy5vcHRpb25zLm9mZnNldCArIHRoaXMuc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcclxuXHRtaW1pY1N0eWxlKHRoaXMuZWwsIHRoaXMuc3R1Yik7XHJcbn07XHJcblxyXG4vL21ha2VzIGVsZW1lbnQgY2xhc3NlcyByZWZsZWN0aW5nIGl0J3Mgc3RhdGUgKHRoaXMuaXNUb3AsIHRoaXMuaXNCb3R0b20sIHRoaXMuaXNGaXhlZClcclxucHJvdG8udXBkYXRlQ2xhc3NlcyA9IGZ1bmN0aW9uKCl7XHJcblx0aWYgKHRoaXMuaXNUb3Ape1xyXG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9uc1sndG9wQ2xhc3MnXSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnNbJ3RvcENsYXNzJ10pO1xyXG5cdH1cclxuXHJcblx0aWYgKHRoaXMuaXNGaXhlZCl7XHJcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zWydzdGlja3lDbGFzcyddKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9uc1snc3RpY2t5Q2xhc3MnXSk7XHJcblx0fVxyXG5cclxuXHRpZiAodGhpcy5pc0JvdHRvbSl7XHJcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zWydib3R0b21DbGFzcyddKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9uc1snYm90dG9tQ2xhc3MnXSk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbnByb3RvLnJlY2FsYyA9IGZ1bmN0aW9uKCl7XHJcblx0Ly9jb25zb2xlLmdyb3VwKCdyZWNhbGM6JyArIHRoaXMuZWwuZGF0YXNldFsnc3RpY2t5SWQnXSlcclxuXHQvL2VsZW1lbnQgdG8gbWltaWMgdmlzdWFsIHByb3BlcnRpZXMgZnJvbVxyXG5cdHZhciBtZWFzdXJlRWwgPSAodGhpcy5pc1RvcCA/IHRoaXMuZWwgOiB0aGlzLnN0dWIpO1xyXG5cclxuXHQvL3VwZGF0ZSBzdHViIGNvbnRlbnRcclxuXHR0aGlzLnN0dWIuaW5uZXJIVE1MID0gdGhpcy5lbC5pbm5lckhUTUw7XHJcblx0Y2xlYW5Ob2RlKHRoaXMuc3R1Yik7XHJcblxyXG5cdC8vdXBkYXRlIHBhcmVudCBjb250YWluZXIgc2l6ZSAmIG9mZnNldHNcclxuXHR0aGlzLnBhcmVudEJveCA9IGdldE9mZnNldHModGhpcy5wYXJlbnQpO1xyXG5cclxuXHQvL3VwZGF0ZSBzZWxmIHNpemUgJiBwb3NpdGlvblxyXG5cdHRoaXMuaGVpZ2h0ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XHJcblx0dmFyIG1TdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobWVhc3VyZUVsKTtcclxuXHR0aGlzLm1sID0gfn5tU3R5bGUubWFyZ2luTGVmdC5zbGljZSgwLC0yKTtcclxuXHR0aGlzLm1yID0gfn5tU3R5bGUubWFyZ2luUmlnaHQuc2xpY2UoMCwtMik7XHJcblx0dGhpcy5tdCA9IH5+bVN0eWxlLm1hcmdpblRvcC5zbGljZSgwLC0yKTtcclxuXHR0aGlzLm1iID0gfn5tU3R5bGUubWFyZ2luQm90dG9tLnNsaWNlKDAsLTIpO1xyXG5cclxuXHR0aGlzLnNjcm9sbE9mZnNldCA9IDA7XHJcblxyXG5cdC8vdXBkYXRlIHJlc3RyaWN0aW9uc1xyXG5cdHRoaXMucmVzdHJpY3RCb3ggPSB0aGlzLmdldFJlc3RyaWN0Qm94KHRoaXMud2l0aGluLCBtZWFzdXJlRWwpO1xyXG5cclxuXHQvL21ha2UgcmVzdHJpY3Rpb24gdXAgdG8gbmV4dCBzaWJsaW5nIHdpdGhpbiBvbmUgY29udGFpbmVyXHJcblx0dmFyIHByZXZTdGlja3k7XHJcblx0dGhpcy5vZmZzZXQuYm90dG9tID0gMDtcclxuXHR0aGlzLm9mZnNldC50b3AgPSAwO1xyXG5cdGlmICh0aGlzLnN0YWNrLmxlbmd0aCl7XHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5zdGFjay5sZW5ndGg7IGktLTspe1xyXG5cdFx0XHRpZiAocHJldlN0aWNreSA9IFN0aWNreS5zdGFja1t0aGlzLnN0YWNrW2ldXVt0aGlzLnN0YWNrSWRbaV0gLSAxXSl7XHJcblx0XHRcdFx0Ly9tYWtlIG9mZnNldHMgZm9yIHN0YWNrZWQgbW9kZVxyXG5cdFx0XHRcdHZhciBwcmV2TWVhc3VyZXIgPSAocHJldlN0aWNreS5pc1RvcCA/IHByZXZTdGlja3kuZWwgOiBwcmV2U3RpY2t5LnN0dWIpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnRvcCA9IHByZXZTdGlja3kub2Zmc2V0LnRvcCArIHByZXZTdGlja3kub3B0aW9ucy5vZmZzZXQ7XHJcblx0XHRcdFx0aWYgKCEodGhpcy5vcHRpb25zWydjb2xsYXBzZSddICYmICFpc092ZXJsYXAobWVhc3VyZUVsLCBwcmV2TWVhc3VyZXIpKSkge1xyXG5cdFx0XHRcdCBcdHRoaXMub2Zmc2V0LnRvcCArPSBwcmV2U3RpY2t5LmhlaWdodCArIE1hdGgubWF4KHByZXZTdGlja3kubXQsIHByZXZTdGlja3kubWIpLy9jb2xsYXBzZWQgbWFyZ2luXHJcblx0XHRcdFx0IFx0dmFyIG5leHRTdGlja3kgPSBTdGlja3kuc3RhY2tbdGhpcy5zdGFja1tpXV1bdGhpcy5zdGFja0lkW2ldXTtcclxuXHRcdFx0XHRcdC8vbXVsdGlzdGFja2luZy13YXkgb2YgY29ycmVjdGluZyBib3R0b20gb2Zmc2V0c1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaiA9IHRoaXMuc3RhY2tJZFtpXSAtIDE7IChwcmV2U3RpY2t5ID0gU3RpY2t5LnN0YWNrW3RoaXMuc3RhY2tbaV1dW2pdKTsgai0tKXtcclxuXHRcdFx0XHRcdFx0cHJldlN0aWNreS5vZmZzZXQuYm90dG9tID0gTWF0aC5tYXgocHJldlN0aWNreS5vZmZzZXQuYm90dG9tLCBuZXh0U3RpY2t5Lm9mZnNldC5ib3R0b20gKyBuZXh0U3RpY2t5LmhlaWdodCArIG5leHRTdGlja3kubXQgKyBuZXh0U3RpY2t5Lm1iKTtcclxuXHRcdFx0XHRcdFx0bmV4dFN0aWNreSA9IHByZXZTdGlja3k7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL3RyYWNrIHN0YWNrIGhlaWdodHM7XHJcblx0XHRcdFN0aWNreS5zdGFja0hlaWdodHNbdGhpcy5zdGFja1tpXV0gPSB0aGlzLm9mZnNldC50b3AgKyB0aGlzLmhlaWdodCArIHRoaXMubXQgKyB0aGlzLm1iO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAocHJldlN0aWNreSA9IFN0aWNreS5ub1N0YWNrW3RoaXMuc3RhY2tJZFswXSAtIDFdKXtcclxuXHRcdHByZXZTdGlja3kucmVzdHJpY3RCb3guYm90dG9tID0gdGhpcy5yZXN0cmljdEJveC50b3AgLSB0aGlzLm10O1xyXG5cdH1cclxuXHJcblx0Y2xlYXJUaW1lb3V0KHRoaXMuX3VwZFRpbWVvdXQpO1xyXG5cdHRoaXMuX3VwZFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuYWRqdXN0U2l6ZUFuZFBvc2l0aW9uLCAwKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogcmV0dXJuIGJveCB3aXRoIHNpemVzIGJhc2VkIG9uIGFueSByZXN0cmljdHdpdGhpbiBvYmplY3QgcGFzc2VkXHJcbiAqL1xyXG5wcm90by5nZXRSZXN0cmljdEJveCA9IGZ1bmN0aW9uKHdpdGhpbiwgbWVhc3VyZUVsKXtcclxuXHR2YXIgcmVzdHJpY3RCb3ggPSB7XHJcblx0XHR0b3A6IDAsXHJcblx0XHRib3R0b206IDBcclxuXHR9O1xyXG5cdGlmICh3aXRoaW4gaW5zdGFuY2VvZiBFbGVtZW50KXtcclxuXHRcdHZhciBvZmZzZXRSZWN0ID0gZ2V0T2Zmc2V0cyh3aXRoaW4pXHJcblx0XHRyZXN0cmljdEJveC50b3AgPSBNYXRoLm1heChvZmZzZXRSZWN0LnRvcCwgZ2V0T2Zmc2V0cyhtZWFzdXJlRWwpLnRvcCk7XHJcblx0XHQvL2NvbnNvbGUubG9nKGdldE9mZnNldHModGhpcy5zdHViKSlcclxuXHRcdHJlc3RyaWN0Qm94LmJvdHRvbSA9IHdpdGhpbi5vZmZzZXRIZWlnaHQgKyBvZmZzZXRSZWN0LnRvcDtcclxuXHR9IGVsc2UgaWYgKHdpdGhpbiBpbnN0YW5jZW9mIE9iamVjdCkge1xyXG5cdFx0aWYgKHdpdGhpbi50b3AgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcblx0XHRcdHZhciBvZmZzZXRSZWN0ID0gZ2V0T2Zmc2V0cyh3aXRoaW4udG9wKVxyXG5cdFx0XHRyZXN0cmljdEJveC50b3AgPSBNYXRoLm1heChvZmZzZXRSZWN0LnRvcCwgZ2V0T2Zmc2V0cyhtZWFzdXJlRWwpLnRvcCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN0cmljdEJveC50b3AgPSB3aXRoaW4udG9wO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHdpdGhpbi5ib3R0b20gaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcblx0XHRcdHZhciBvZmZzZXRSZWN0ID0gZ2V0T2Zmc2V0cyh3aXRoaW4uYm90dG9tKVxyXG5cdFx0XHRyZXN0cmljdEJveC5ib3R0b20gPSB3aXRoaW4uYm90dG9tLm9mZnNldEhlaWdodCArIG9mZnNldFJlY3QudG9wO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKG9mZnNldFJlY3QpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN0cmljdEJveC5ib3R0b20gPSB3aXRoaW4uYm90dG9tO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHQvL2Nhc2Ugb2YgcGFyZW50IGNvbnRhaW5lclxyXG5cdFx0cmVzdHJpY3RCb3gudG9wID0gZ2V0T2Zmc2V0cyhtZWFzdXJlRWwpLnRvcDtcclxuXHRcdHJlc3RyaWN0Qm94LmJvdHRvbSA9IHRoaXMucGFyZW50Qm94LmhlaWdodCArIHRoaXMucGFyZW50Qm94LnRvcDtcclxuXHR9XHJcblx0Ly9jb25zb2xlLmxvZygnUmVzdHJpY3Rib3gnLCByZXN0cmljdEJveClcclxuXHRyZXR1cm4gcmVzdHJpY3RCb3g7XHJcbn07XHJcblxyXG5cclxucHJvdG8uYWRqdXN0U2l6ZUFuZFBvc2l0aW9uID0gZnVuY3Rpb24oKXtcclxuXHRpZiAodGhpcy5pc1RvcCl7XHJcblx0XHR0aGlzLmVsLnN0eWxlLmNzc1RleHQgPSB0aGlzLmluaXRpYWxTdHlsZTtcclxuXHR9IGVsc2UgaWYgKHRoaXMuaXNCb3R0b20pe1xyXG5cdFx0dGhpcy5tYWtlUGFya2VkQm90dG9tU3R5bGUoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5tYWtlU3RpY2tlZFN0eWxlKCk7XHJcblx0fVxyXG5cclxuXHR0aGlzLmNoZWNrKCk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4vKiogcmVtb3ZlcyBpZnJhbWUsIG9iamVjdHMgZXRjIHNoaXQgKi9cclxudmFyIGJhZFRhZ3MgPSBbJ29iamVjdCcsICdpZnJhbWUnLCAnZW1iZWQnLCAnaW1nJ107XHJcbmZ1bmN0aW9uIGNsZWFuTm9kZShub2RlKXtcclxuXHRub2RlLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcclxuXHR2YXIgaWRUYWdzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaWRdJyk7XHJcblx0Zm9yICh2YXIgayA9IDA7IGsgPCBpZFRhZ3MubGVuZ3RoOyBrKyspe1xyXG5cdFx0aWRUYWdzW2tdLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTsgLy9hdm9pZCBhbnkgdW5pcXVlbmVzc1xyXG5cdFx0aWRUYWdzW2tdLnJlbW92ZUF0dHJpYnV0ZSgnbmFtZScpOyAvL2F2b2lkIGFueSB1bmlxdWVuZXNzXHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYmFkVGFncy5sZW5ndGg7IGkrKyl7XHJcblx0XHR2YXIgdGFncyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChiYWRUYWdzW2ldKTtcclxuXHRcdGZvciAodmFyIGogPSB0YWdzLmxlbmd0aDsgai0tOyApe1xyXG5cdFx0XHRpZiAodGFnc1tqXS50YWdOYW1lID09PSAnU0NSSVBUJykgdGFnc1tqXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0YWdzW2pdKVxyXG5cdFx0XHR0YWdzW2pdLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XHJcblx0XHRcdHRhZ3Nbal0ucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XHJcblx0XHRcdHRhZ3Nbal0ucmVtb3ZlQXR0cmlidXRlKCdyZWwnKTtcclxuXHRcdFx0dGFnc1tqXS5yZW1vdmVBdHRyaWJ1dGUoJ3NyY2RvYycpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcbnZhciBkaXJlY3Rpb25zID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXSxcclxuXHRtaW1pY1Byb3BlcnRpZXMgPSBbJ3BhZGRpbmctJywgJ2JvcmRlci0nXTtcclxuXHJcblxyXG4vKiogY29waWVzIHNpemUtcmVsYXRlZCBzdHlsZSBvZiBzdHViICovXHJcbmZ1bmN0aW9uIG1pbWljU3R5bGUodG8sIGZyb20pe1xyXG5cdHZhciBzdHViU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGZyb20pLFxyXG5cdFx0c3R1Yk9mZnNldCA9IGdldE9mZnNldHMoZnJvbSksXHJcblx0XHRwbCA9IDAsIHByID0gMCwgbWwgPSAwO1xyXG5cdGlmIChzdHViU3R5bGVbJ2JveC1zaXppbmcnXSAhPT0gJ2JvcmRlci1ib3gnKXtcclxuXHRcdHBsID0gfn5zdHViU3R5bGUucGFkZGluZ0xlZnQuc2xpY2UoMCwtMilcclxuXHRcdHByID0gfn5zdHViU3R5bGUucGFkZGluZ1JpZ2h0LnNsaWNlKDAsLTIpXHJcblx0fVxyXG5cclxuXHR0by5zdHlsZS53aWR0aCA9IChzdHViT2Zmc2V0LndpZHRoIC0gcGwgLSBwcikgKyAncHgnO1xyXG5cdHRvLnN0eWxlLmxlZnQgPSBzdHViT2Zmc2V0LmxlZnQgKyAncHgnO1xyXG5cdHRvLnN0eWxlLm1hcmdpbkxlZnQgPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWltaWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKXtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGlyZWN0aW9ucy5sZW5ndGg7IGorKyl7XHJcblx0XHRcdHZhciBwcm9wID0gbWltaWNQcm9wZXJ0aWVzW2ldICsgZGlyZWN0aW9uc1tqXTtcclxuXHRcdFx0dG8uc3R5bGVbcHJvcF0gPSBzdHViU3R5bGVbcHJvcF07XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5cclxuLyoqIGNoZWNrcyBvdmVybGFwcGluZyB3aWR0aHMgKi9cclxuZnVuY3Rpb24gaXNPdmVybGFwKGxlZnQsIHJpZ2h0KXtcclxuXHR2YXIgbExlZnQgPSBsZWZ0Lm9mZnNldExlZnQsXHJcblx0XHRsUmlnaHQgPSBsZWZ0Lm9mZnNldExlZnQgKyBsZWZ0Lm9mZnNldFdpZHRoLFxyXG5cdFx0ckxlZnQgPSByaWdodC5vZmZzZXRMZWZ0LFxyXG5cdFx0clJpZ2h0ID0gcmlnaHQub2Zmc2V0V2lkdGggKyByaWdodC5vZmZzZXRMZWZ0O1xyXG5cdGlmIChsUmlnaHQgPCByTGVmdCAmJiBsTGVmdCA8IHJMZWZ0XHJcblx0XHR8fCBsUmlnaHQgPiByUmlnaHQgJiYgbExlZnQgPiByUmlnaHQpe1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtc3RpY2t5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy94dGVuZC9tdXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEBtb2R1bGUgZW1teS9vblxuICovXG5cblxudmFyIGljaWNsZSA9IHJlcXVpcmUoJ2ljaWNsZScpO1xudmFyIGxpc3RlbmVycyA9IHJlcXVpcmUoJy4vbGlzdGVuZXJzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmonKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuXG4vKipcbiAqIEJpbmQgZm4gdG8gYSB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHsqfSB0YXJndGUgQSBzaW5nbGUgdGFyZ2V0IHRvIGJpbmQgZXZ0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEFuIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259PyBjb25kaXRpb24gQW4gb3B0aW9uYWwgZmlsdGVyaW5nIGZuIGZvciBhIGNhbGxiYWNrXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGFjY2VwdHMgYW4gZXZlbnQgYW5kIHJldHVybnMgY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIG9uKHRhcmdldCwgZXZ0LCBmbil7XG5cdGlmICghdGFyZ2V0KSByZXR1cm4gdGFyZ2V0O1xuXG5cdC8vY29uc2lkZXIgb2JqZWN0IG9mIGV2ZW50c1xuXHRpZiAoaXNPYmplY3QoZXZ0KSkge1xuXHRcdGZvcih2YXIgZXZ0TmFtZSBpbiBldnQpIHtcblx0XHRcdG9uKHRhcmdldCwgZXZ0TmFtZSwgZXZ0W2V2dE5hbWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8vZ2V0IHRhcmdldCBgb25gIG1ldGhvZCwgaWYgYW55XG5cdC8vcHJlZmVyIG5hdGl2ZS1saWtlIG1ldGhvZCBuYW1lXG5cdC8vdXNlciBtYXkgb2NjYXNpb25hbGx5IGV4cG9zZSBgb25gIHRvIHRoZSBnbG9iYWwsIGluIGNhc2Ugb2YgYnJvd3NlcmlmeVxuXHQvL2J1dCBpdCBpcyB1bmxpa2VseSBvbmUgd291bGQgcmVwbGFjZSBuYXRpdmUgYGFkZEV2ZW50TGlzdGVuZXJgXG5cdHZhciBvbk1ldGhvZCA9ICB0YXJnZXRbJ2FkZEV2ZW50TGlzdGVuZXInXSB8fCB0YXJnZXRbJ2FkZExpc3RlbmVyJ10gfHwgdGFyZ2V0WydhdHRhY2hFdmVudCddIHx8IHRhcmdldFsnb24nXTtcblxuXHR2YXIgY2IgPSBmbjtcblxuXHRldnQgPSAnJyArIGV2dDtcblxuXHQvL2ludm9rZSBtZXRob2QgZm9yIGVhY2ggc3BhY2Utc2VwYXJhdGVkIGV2ZW50IGZyb20gYSBsaXN0XG5cdGV2dC5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24oZXZ0KXtcblx0XHR2YXIgZXZ0UGFydHMgPSBldnQuc3BsaXQoJy4nKTtcblx0XHRldnQgPSBldnRQYXJ0cy5zaGlmdCgpO1xuXG5cdFx0Ly91c2UgdGFyZ2V0IGV2ZW50IHN5c3RlbSwgaWYgcG9zc2libGVcblx0XHRpZiAob25NZXRob2QpIHtcblx0XHRcdC8vYXZvaWQgc2VsZi1yZWN1cnNpb25zXG5cdFx0XHQvL2lmIGl04oCZcyBmcm96ZW4gLSBpZ25vcmUgY2FsbFxuXHRcdFx0aWYgKGljaWNsZS5mcmVlemUodGFyZ2V0LCAnb24nICsgZXZ0KSl7XG5cdFx0XHRcdG9uTWV0aG9kLmNhbGwodGFyZ2V0LCBldnQsIGNiKTtcblx0XHRcdFx0aWNpY2xlLnVuZnJlZXplKHRhcmdldCwgJ29uJyArIGV2dCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3NhdmUgdGhlIGNhbGxiYWNrIGFueXdheVxuXHRcdGxpc3RlbmVycy5hZGQodGFyZ2V0LCBldnQsIGNiLCBldnRQYXJ0cyk7XG5cdH0pO1xuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cblxuLyoqXG4gKiBXcmFwIGFuIGZuIHdpdGggY29uZGl0aW9uIHBhc3NpbmdcbiAqL1xub24ud3JhcCA9IGZ1bmN0aW9uKHRhcmdldCwgZXZ0LCBmbiwgY29uZGl0aW9uKXtcblx0dmFyIGNiID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGNvbmRpdGlvbi5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cykpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xuXG5cdGNiLmZuID0gZm47XG5cblx0cmV0dXJuIGNiO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9lbW15L29uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHZhciBwcm90b3R5cGU7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAocHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLCBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogQG1vZHVsZSBlbW15L29mZlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBvZmY7XHJcblxyXG52YXIgaWNpY2xlID0gcmVxdWlyZSgnaWNpY2xlJyk7XHJcbnZhciBzbGljZSA9IHJlcXVpcmUoJ3NsaWNlZCcpO1xyXG52YXIgbGlzdGVuZXJzID0gcmVxdWlyZSgnLi9saXN0ZW5lcnMnKTtcclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlIGxpc3RlbmVyW3NdIGZyb20gdGhlIHRhcmdldFxyXG4gKlxyXG4gKiBAcGFyYW0ge1t0eXBlXX0gZXZ0IFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gW2Rlc2NyaXB0aW9uXVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICovXHJcbmZ1bmN0aW9uIG9mZih0YXJnZXQsIGV2dCwgZm4pIHtcclxuXHRpZiAoIXRhcmdldCkgcmV0dXJuIHRhcmdldDtcclxuXHJcblx0dmFyIGNhbGxiYWNrcywgaTtcclxuXHJcblx0Ly91bmJpbmQgYWxsIGxpc3RlbmVycyBpZiBubyBmbiBzcGVjaWZpZWRcclxuXHRpZiAoZm4gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xyXG5cclxuXHRcdC8vdHJ5IHRvIHVzZSB0YXJnZXQgcmVtb3ZlQWxsIG1ldGhvZCwgaWYgYW55XHJcblx0XHR2YXIgYWxsT2ZmID0gdGFyZ2V0WydyZW1vdmVBbGwnXSB8fCB0YXJnZXRbJ3JlbW92ZUFsbExpc3RlbmVycyddO1xyXG5cclxuXHRcdC8vY2FsbCB0YXJnZXQgcmVtb3ZlQWxsXHJcblx0XHRpZiAoYWxsT2ZmKSB7XHJcblx0XHRcdGFsbE9mZi5hcHBseSh0YXJnZXQsIGFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvL3RoZW4gZm9yZ2V0IG93biBjYWxsYmFja3MsIGlmIGFueVxyXG5cclxuXHRcdC8vdW5iaW5kIGFsbCBldnRzXHJcblx0XHRpZiAoIWV2dCkge1xyXG5cdFx0XHRjYWxsYmFja3MgPSBsaXN0ZW5lcnModGFyZ2V0KTtcclxuXHRcdFx0Zm9yIChldnQgaW4gY2FsbGJhY2tzKSB7XHJcblx0XHRcdFx0b2ZmKHRhcmdldCwgZXZ0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly91bmJpbmQgYWxsIGNhbGxiYWNrcyBmb3IgYW4gZXZ0XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0ZXZ0ID0gJycgKyBldnQ7XHJcblxyXG5cdFx0XHQvL2ludm9rZSBtZXRob2QgZm9yIGVhY2ggc3BhY2Utc2VwYXJhdGVkIGV2ZW50IGZyb20gYSBsaXN0XHJcblx0XHRcdGV2dC5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xyXG5cdFx0XHRcdHZhciBldnRQYXJ0cyA9IGV2dC5zcGxpdCgnLicpO1xyXG5cdFx0XHRcdGV2dCA9IGV2dFBhcnRzLnNoaWZ0KCk7XHJcblx0XHRcdFx0Y2FsbGJhY2tzID0gbGlzdGVuZXJzKHRhcmdldCwgZXZ0LCBldnRQYXJ0cyk7XHJcblxyXG5cdFx0XHRcdC8vcmV0dXJuZWQgYXJyYXkgb2YgY2FsbGJhY2tzIChhcyBldmVudCBpcyBkZWZpbmVkKVxyXG5cdFx0XHRcdGlmIChldnQpIHtcclxuXHRcdFx0XHRcdHZhciBvYmogPSB7fTtcclxuXHRcdFx0XHRcdG9ialtldnRdID0gY2FsbGJhY2tzO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2tzID0gb2JqO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9mb3IgZWFjaCBncm91cCBvZiBjYWxsYmFja3MgLSB1bmJpbmQgYWxsXHJcblx0XHRcdFx0Zm9yICh2YXIgZXZ0TmFtZSBpbiBjYWxsYmFja3MpIHtcclxuXHRcdFx0XHRcdHNsaWNlKGNhbGxiYWNrc1tldnROYW1lXSkuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcclxuXHRcdFx0XHRcdFx0b2ZmKHRhcmdldCwgZXZ0TmFtZSwgY2IpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblxyXG5cdC8vdGFyZ2V0IGV2ZW50cyAoc3RyaW5nIG5vdGF0aW9uIHRvIGFkdmFuY2VkX29wdGltaXphdGlvbnMpXHJcblx0dmFyIG9mZk1ldGhvZCA9IHRhcmdldFsncmVtb3ZlRXZlbnRMaXN0ZW5lciddIHx8IHRhcmdldFsncmVtb3ZlTGlzdGVuZXInXSB8fCB0YXJnZXRbJ2RldGFjaEV2ZW50J10gfHwgdGFyZ2V0WydvZmYnXTtcclxuXHJcblx0Ly9pbnZva2UgbWV0aG9kIGZvciBlYWNoIHNwYWNlLXNlcGFyYXRlZCBldmVudCBmcm9tIGEgbGlzdFxyXG5cdGV2dC5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xyXG5cdFx0dmFyIGV2dFBhcnRzID0gZXZ0LnNwbGl0KCcuJyk7XHJcblx0XHRldnQgPSBldnRQYXJ0cy5zaGlmdCgpO1xyXG5cclxuXHRcdC8vdXNlIHRhcmdldCBgb2ZmYCwgaWYgcG9zc2libGVcclxuXHRcdGlmIChvZmZNZXRob2QpIHtcclxuXHRcdFx0Ly9hdm9pZCBzZWxmLXJlY3Vyc2lvbiBmcm9tIHRoZSBvdXRzaWRlXHJcblx0XHRcdGlmIChpY2ljbGUuZnJlZXplKHRhcmdldCwgJ29mZicgKyBldnQpKSB7XHJcblx0XHRcdFx0b2ZmTWV0aG9kLmNhbGwodGFyZ2V0LCBldnQsIGZuKTtcclxuXHRcdFx0XHRpY2ljbGUudW5mcmVlemUodGFyZ2V0LCAnb2ZmJyArIGV2dCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vaWYgaXTigJlzIGZyb3plbiAtIGlnbm9yZSBjYWxsXHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZm4uY2xvc2VkQ2FsbCkgZm4uY2xvc2VkQ2FsbCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vZm9yZ2V0IGNhbGxiYWNrXHJcblx0XHRsaXN0ZW5lcnMucmVtb3ZlKHRhcmdldCwgZXZ0LCBmbiwgZXZ0UGFydHMpO1xyXG5cdH0pO1xyXG5cclxuXHJcblx0cmV0dXJuIHRhcmdldDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZW1teS9vZmYuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxyXG4gKiBAbW9kdWxlIGVtbXkvZW1pdFxyXG4gKi9cclxudmFyIGljaWNsZSA9IHJlcXVpcmUoJ2ljaWNsZScpO1xyXG52YXIgc2xpY2UgPSByZXF1aXJlKCdzbGljZWQnKTtcclxudmFyIGxpc3RlbmVycyA9IHJlcXVpcmUoJy4vbGlzdGVuZXJzJyk7XHJcbnZhciBpc0Jyb3dzZXIgPSByZXF1aXJlKCdpcy1icm93c2VyJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgc2ltcGxlIHdyYXBwZXIgdG8gaGFuZGxlIHN0cmluZ3kvcGxhaW4gZXZlbnRzXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgZXZ0KXtcclxuXHRpZiAoIXRhcmdldCkgcmV0dXJuO1xyXG5cclxuXHR2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuXHRpZiAodHlwZW9mIGV2dCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xyXG5cdFx0ZXZ0LnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbihldnQpe1xyXG5cdFx0XHRldnQgPSBldnQuc3BsaXQoJy4nKVswXTtcclxuXHJcblx0XHRcdGVtaXQuYXBwbHkodGhpcywgW3RhcmdldCwgZXZ0XS5jb25jYXQoYXJncykpO1xyXG5cdFx0fSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKiogZGV0ZWN0IGVudiAqL1xyXG52YXIgJCA9IHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogalF1ZXJ5O1xyXG52YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGRvY3VtZW50O1xyXG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3c7XHJcblxyXG5cclxuLyoqXHJcbiAqIEVtaXQgYW4gZXZlbnQsIG9wdGlvbmFsbHkgd2l0aCBkYXRhIG9yIGJ1YmJsaW5nXHJcbiAqIEFjY2VwdCBvbmx5IHNpbmdsZSBlbGVtZW50cy9ldmVudHNcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBBbiBldmVudCBuYW1lLCBlLiBnLiAnY2xpY2snXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBBbnkgZGF0YSB0byBwYXNzIHRvIGV2ZW50LmRldGFpbHMgKERPTSkgb3IgZXZlbnQuZGF0YSAoZWxzZXdoZXJlKVxyXG4gKiBAcGFyYW0ge2Jvb2x9IGJ1YmJsZXMgV2hldGhlciB0byB0cmlnZ2VyIGJ1YmJsaW5nIGV2ZW50IChET00pXHJcbiAqXHJcbiAqXHJcbiAqIEByZXR1cm4ge3RhcmdldH0gYSB0YXJnZXRcclxuICovXHJcbmZ1bmN0aW9uIGVtaXQodGFyZ2V0LCBldmVudE5hbWUsIGRhdGEsIGJ1YmJsZXMpe1xyXG5cdHZhciBlbWl0TWV0aG9kLCBldnQgPSBldmVudE5hbWU7XHJcblxyXG5cdC8vQ3JlYXRlIHByb3BlciBldmVudCBmb3IgRE9NIG9iamVjdHNcclxuXHRpZiAoaXNCcm93c2VyICYmICh0YXJnZXQgaW5zdGFuY2VvZiBOb2RlIHx8IHRhcmdldCA9PT0gd2luKSkge1xyXG5cdFx0Ly9OT1RFOiB0aGlzIGRvZXNub3QgYnViYmxlIG9uIG9mZi1ET00gZWxlbWVudHNcclxuXHJcblx0XHRpZiAoaXNCcm93c2VyICYmIGV2ZW50TmFtZSBpbnN0YW5jZW9mIEV2ZW50KSB7XHJcblx0XHRcdGV2dCA9IGV2ZW50TmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vSUU5LWNvbXBsaWFudCBjb25zdHJ1Y3RvclxyXG5cdFx0XHRldnQgPSBkb2MuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcblx0XHRcdGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCBidWJibGVzLCB0cnVlLCBkYXRhKTtcclxuXHJcblx0XHRcdC8vYSBtb2Rlcm4gY29uc3RydWN0b3Igd291bGQgYmU6XHJcblx0XHRcdC8vIHZhciBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbDogZGF0YSwgYnViYmxlczogYnViYmxlcyB9KVxyXG5cdFx0fVxyXG5cclxuXHRcdGVtaXRNZXRob2QgPSB0YXJnZXQuZGlzcGF0Y2hFdmVudDtcclxuXHR9XHJcblxyXG5cdC8vY3JlYXRlIGV2ZW50IGZvciBqUXVlcnkgb2JqZWN0XHJcblx0ZWxzZSBpZiAoJCAmJiB0YXJnZXQgaW5zdGFuY2VvZiAkKSB7XHJcblx0XHQvL1RPRE86IGRlY2lkZSBob3cgdG8gcGFzcyBkYXRhXHJcblx0XHRldnQgPSAkLkV2ZW50KCBldmVudE5hbWUsIGRhdGEgKTtcclxuXHRcdGV2dC5kZXRhaWwgPSBkYXRhO1xyXG5cclxuXHRcdC8vRklYTUU6IHJlZmVyZW5jZSBjYXNlIHdoZXJlIHRyaWdnZXJIYW5kbGVyIG5lZWRlZCAoc29tZXRoaW5nIHdpdGggbXVsdGlwbGUgY2FsbHMpXHJcblx0XHRlbWl0TWV0aG9kID0gYnViYmxlcyA/IHRhcmd0ZS50cmlnZ2VyIDogdGFyZ2V0LnRyaWdnZXJIYW5kbGVyO1xyXG5cdH1cclxuXHJcblx0Ly9kZXRlY3QgdGFyZ2V0IGV2ZW50c1xyXG5cdGVsc2Uge1xyXG5cdFx0Ly9lbWl0IC0gZGVmYXVsdFxyXG5cdFx0Ly90cmlnZ2VyIC0ganF1ZXJ5XHJcblx0XHQvL2Rpc3BhdGNoRXZlbnQgLSBET01cclxuXHRcdC8vcmFpc2UgLSBub2RlLXN0YXRlXHJcblx0XHQvL2ZpcmUgLSA/Pz9cclxuXHRcdGVtaXRNZXRob2QgPSB0YXJnZXRbJ2Rpc3BhdGNoRXZlbnQnXSB8fCB0YXJnZXRbJ2VtaXQnXSB8fCB0YXJnZXRbJ3RyaWdnZXInXSB8fCB0YXJnZXRbJ2ZpcmUnXSB8fCB0YXJnZXRbJ3JhaXNlJ107XHJcblx0fVxyXG5cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpO1xyXG5cclxuXHJcblx0Ly91c2UgbG9ja3MgdG8gYXZvaWQgc2VsZi1yZWN1cnNpb24gb24gb2JqZWN0cyB3cmFwcGluZyB0aGlzIG1ldGhvZFxyXG5cdGlmIChlbWl0TWV0aG9kKSB7XHJcblx0XHRpZiAoaWNpY2xlLmZyZWV6ZSh0YXJnZXQsICdlbWl0JyArIGV2ZW50TmFtZSkpIHtcclxuXHRcdFx0Ly91c2UgdGFyZ2V0IGV2ZW50IHN5c3RlbSwgaWYgcG9zc2libGVcclxuXHRcdFx0ZW1pdE1ldGhvZC5hcHBseSh0YXJnZXQsIFtldnRdLmNvbmNhdChhcmdzKSk7XHJcblx0XHRcdGljaWNsZS51bmZyZWV6ZSh0YXJnZXQsICdlbWl0JyArIGV2ZW50TmFtZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vaWYgZXZlbnQgd2FzIGZyb3plbiAtIHByb2JhYmx5IGl0IGlzIGVtaXR0ZXIgaW5zdGFuY2VcclxuXHRcdC8vc28gcGVyZm9ybSBub3JtYWwgY2FsbGJhY2tcclxuXHR9XHJcblxyXG5cclxuXHQvL2ZhbGwgYmFjayB0byBkZWZhdWx0IGV2ZW50IHN5c3RlbVxyXG5cdHZhciBldnRDYWxsYmFja3MgPSBsaXN0ZW5lcnModGFyZ2V0LCBldnQpO1xyXG5cclxuXHQvL2NvcHkgY2FsbGJhY2tzIHRvIGZpcmUgYmVjYXVzZSBsaXN0IGNhbiBiZSBjaGFuZ2VkIGJ5IHNvbWUgY2FsbGJhY2sgKGxpa2UgYG9mZmApXHJcblx0dmFyIGZpcmVMaXN0ID0gc2xpY2UoZXZ0Q2FsbGJhY2tzKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGZpcmVMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG5cdFx0ZmlyZUxpc3RbaV0gJiYgZmlyZUxpc3RbaV0uYXBwbHkodGFyZ2V0LCBhcmdzKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2VtbXkvZW1pdC5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9pcy1icm93c2VyL2NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXHJcbiAqIENhbGN1bGF0ZSBhYnNvbHV0ZSBvZmZzZXRzIG9mIGFuIGVsZW1lbnQsIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cclxuICpcclxuICogQG1vZHVsZSBtdWNzcy9vZmZzZXRzXHJcbiAqXHJcbiAqL1xyXG52YXIgd2luID0gd2luZG93O1xyXG52YXIgZG9jID0gZG9jdW1lbnQ7XHJcbnZhciBSZWN0ID0gcmVxdWlyZSgnLi9SZWN0Jyk7XHJcbnZhciBoYXNTY3JvbGwgPSByZXF1aXJlKCcuL2hhcy1zY3JvbGwnKTtcclxudmFyIHNjcm9sbGJhciA9IHJlcXVpcmUoJy4vc2Nyb2xsYmFyJyk7XHJcbnZhciBpc0ZpeGVkRWwgPSByZXF1aXJlKCcuL2lzLWZpeGVkJyk7XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFic29sdXRlIG9mZnNldHMgb2YgYW55IHRhcmdldCBwYXNzZWRcclxuICpcclxuICogQHBhcmFtICAgIHtFbGVtZW50fHdpbmRvd30gICBlbCAgIEEgdGFyZ2V0LiBQYXNzIHdpbmRvdyB0byBjYWxjdWxhdGUgdmlld3BvcnQgb2Zmc2V0c1xyXG4gKiBAcmV0dXJuICAge09iamVjdH0gICBPZmZzZXRzIG9iamVjdCB3aXRoIHRyYmwuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IG9mZnNldHM7XHJcblxyXG5mdW5jdGlvbiBvZmZzZXRzIChlbCkge1xyXG5cdGlmICghZWwpIHRocm93IEVycm9yKCdCYWQgYXJndW1lbnQnKTtcclxuXHJcblx0Ly9jYWxjIGNsaWVudCByZWN0XHJcblx0dmFyIGNSZWN0LCByZXN1bHQ7XHJcblxyXG5cdC8vcmV0dXJuIHZwIG9mZnNldHNcclxuXHRpZiAoZWwgPT09IHdpbikge1xyXG5cdFx0cmVzdWx0ID0gbmV3IFJlY3QoXHJcblx0XHRcdHdpbi5wYWdlWE9mZnNldCxcclxuXHRcdFx0d2luLnBhZ2VZT2Zmc2V0XHJcblx0XHQpO1xyXG5cclxuXHRcdHJlc3VsdC53aWR0aCA9IHdpbi5pbm5lcldpZHRoIC0gKGhhc1Njcm9sbC55KCkgPyBzY3JvbGxiYXIgOiAwKSxcclxuXHRcdHJlc3VsdC5oZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQgLSAoaGFzU2Nyb2xsLngoKSA/IHNjcm9sbGJhciA6IDApXHJcblx0XHRyZXN1bHQucmlnaHQgPSByZXN1bHQubGVmdCArIHJlc3VsdC53aWR0aDtcclxuXHRcdHJlc3VsdC5ib3R0b20gPSByZXN1bHQudG9wICsgcmVzdWx0LmhlaWdodDtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0Ly9yZXR1cm4gYWJzb2x1dGUgb2Zmc2V0cyBpZiBkb2N1bWVudCByZXF1ZXN0ZWRcclxuXHRlbHNlIGlmIChlbCA9PT0gZG9jKSB7XHJcblx0XHR2YXIgcmVzID0gb2Zmc2V0cyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcclxuXHRcdHJlcy5ib3R0b20gPSBNYXRoLm1heCh3aW5kb3cuaW5uZXJIZWlnaHQsIHJlcy5ib3R0b20pO1xyXG5cdFx0cmVzLnJpZ2h0ID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGgsIHJlcy5yaWdodCk7XHJcblx0XHRpZiAoaGFzU2Nyb2xsLnkoZG9jLmRvY3VtZW50RWxlbWVudCkpIHJlcy5yaWdodCAtPSBzY3JvbGxiYXI7XHJcblx0XHRpZiAoaGFzU2Nyb2xsLngoZG9jLmRvY3VtZW50RWxlbWVudCkpIHJlcy5ib3R0b20gLT0gc2Nyb2xsYmFyO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblxyXG5cdC8vRklYTUU6IHdoeSBub3QgZXZlcnkgZWxlbWVudCBoYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZD9cclxuXHR0cnkge1xyXG5cdFx0Y1JlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRjUmVjdCA9IG5ldyBSZWN0KFxyXG5cdFx0XHRlbC5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlbC5jbGllbnRUb3BcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHQvL3doZXRoZXIgZWxlbWVudCBpcyBvciBpcyBpbiBmaXhlZFxyXG5cdHZhciBpc0ZpeGVkID0gaXNGaXhlZEVsKGVsKTtcclxuXHR2YXIgeE9mZnNldCA9IGlzRml4ZWQgPyAwIDogd2luLnBhZ2VYT2Zmc2V0O1xyXG5cdHZhciB5T2Zmc2V0ID0gaXNGaXhlZCA/IDAgOiB3aW4ucGFnZVlPZmZzZXQ7XHJcblxyXG5cdHJlc3VsdCA9IG5ldyBSZWN0KFxyXG5cdFx0Y1JlY3QubGVmdCArIHhPZmZzZXQsXHJcblx0XHRjUmVjdC50b3AgKyB5T2Zmc2V0LFxyXG5cdFx0Y1JlY3QubGVmdCArIHhPZmZzZXQgKyBlbC5vZmZzZXRXaWR0aCxcclxuXHRcdGNSZWN0LnRvcCArIHlPZmZzZXQgKyBlbC5vZmZzZXRIZWlnaHQsXHJcblx0XHRlbC5vZmZzZXRXaWR0aCxcclxuXHRcdGVsLm9mZnNldEhlaWdodFxyXG5cdCk7XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL211Y3NzL29mZnNldHMuanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxyXG4gKiBTaW1wbGUgcmVjdCBjb25zdHJ1Y3Rvci5cclxuICogSXQgaXMganVzdCBmYXN0ZXIgYW5kIHNtYWxsZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAbW9kdWxlIG11Y3NzL1JlY3RcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGwgbGVmdFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdCB0b3BcclxuICogQHBhcmFtIHtudW1iZXJ9IHIgcmlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IGIgYm90dG9tXHJcbiAqIEBwYXJhbSB7bnVtYmVyfT8gdyB3aWR0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0/IGggaGVpZ2h0XHJcbiAqXHJcbiAqIEByZXR1cm4ge1JlY3R9IEEgcmVjdGFuZ2xlIG9iamVjdFxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWN0IChsLHQscixiLHcsaCkge1xyXG5cdHRoaXMudG9wPXR8fDA7XHJcblx0dGhpcy5ib3R0b209Ynx8MDtcclxuXHR0aGlzLmxlZnQ9bHx8MDtcclxuXHR0aGlzLnJpZ2h0PXJ8fDA7XHJcblx0aWYgKHchPT11bmRlZmluZWQpIHRoaXMud2lkdGg9d3x8dGhpcy5yaWdodC10aGlzLmxlZnQ7XHJcblx0aWYgKGghPT11bmRlZmluZWQpIHRoaXMuaGVpZ2h0PWh8fHRoaXMuYm90dG9tLXRoaXMudG9wO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9tdWNzcy9SZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcclxuICogV2luZG93IHNjcm9sbGJhciBkZXRlY3Rvci5cclxuICpcclxuICogQG1vZHVsZSBtdWNzcy9oYXMtc2Nyb2xsXHJcbiAqL1xyXG5leHBvcnRzLnggPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbn07XHJcbmV4cG9ydHMueSA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gd2luZG93LmlubmVyV2lkdGggPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL211Y3NzL2hhcy1zY3JvbGwuanNcbi8vIG1vZHVsZSBpZCA9IDI2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxyXG4gKiBDYWxjdWxhdGUgc2Nyb2xsYmFyIHdpZHRoLlxyXG4gKlxyXG4gKiBAbW9kdWxlIG11Y3NzL3Njcm9sbGJhclxyXG4gKi9cclxuXHJcbi8vIENyZWF0ZSB0aGUgbWVhc3VyZW1lbnQgbm9kZVxyXG52YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHJcbnZhciBzdHlsZSA9IHNjcm9sbERpdi5zdHlsZTtcclxuXHJcbnN0eWxlLndpZHRoID0gJzEwMHB4Jztcclxuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4Jztcclxuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcclxuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5zdHlsZS50b3AgPSAnLTk5OTlweCc7XHJcblxyXG5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcclxuXHJcbi8vIHRoZSBzY3JvbGxiYXIgd2lkdGhcclxubW9kdWxlLmV4cG9ydHMgPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XHJcblxyXG4vLyBEZWxldGUgZmFrZSBESVZcclxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL211Y3NzL3Njcm9sbGJhci5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXHJcbiAqIERldGVjdCB3aGV0aGVyIGVsZW1lbnQgaXMgcGxhY2VkIHRvIGZpeGVkIGNvbnRhaW5lciBvciBpcyBmaXhlZCBpdHNlbGYuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbXVjc3MvaXMtZml4ZWRcclxuICpcclxuICogQHBhcmFtIHsoRWxlbWVudHxPYmplY3QpfSBlbCBFbGVtZW50IHRvIGRldGVjdCBmaXhlZG5lc3MuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZWxlbWVudCBpcyBuZXN0ZWQuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbCkge1xyXG5cdHZhciBwYXJlbnRFbCA9IGVsO1xyXG5cclxuXHQvL3dpbmRvdyBpcyBmaXhlZCwgYnR3XHJcblx0aWYgKGVsID09PSB3aW5kb3cpIHJldHVybiB0cnVlO1xyXG5cclxuXHQvL3VubGlrZSB0aGUgZG9jXHJcblx0aWYgKGVsID09PSBkb2N1bWVudCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHR3aGlsZSAocGFyZW50RWwpIHtcclxuXHRcdGlmIChnZXRDb21wdXRlZFN0eWxlKHBhcmVudEVsKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykgcmV0dXJuIHRydWU7XHJcblx0XHRwYXJlbnRFbCA9IHBhcmVudEVsLm9mZnNldFBhcmVudDtcclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9tdWNzcy9pcy1maXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi92ZW5kb3IvdGFibGlzdCcpLmluaXQoKTtcblxuLy8gSW1wbGVtZW50aW5nIGEgcG9seWZpbGwgZm9yIGpzIG5hdGl2ZSBXZWFrTWFwXG4vLyBpbiBvcmRlciB0byBwYXRjaCBmdW5jdGlvbmFsaXR5IGluIGFuIGluY2x1ZGVkIGxpYnJhcnlcbnJlcXVpcmUoJ2VzNi13ZWFrLW1hcC9pbXBsZW1lbnQnKTtcblxudmFyIEFjY29yZGlvbiA9IHJlcXVpcmUoJ2FyaWEtYWNjb3JkaW9uJykuQWNjb3JkaW9uO1xudmFyIEdsb3NzYXJ5ID0gcmVxdWlyZSgnZ2xvc3NhcnktcGFuZWwnKTtcblxudmFyIHRlcm1zID0gcmVxdWlyZSgnLi9kYXRhL3Rlcm1zJyk7XG52YXIgZmVlZGJhY2sgPSByZXF1aXJlKCcuL21vZHVsZXMvZmVlZGJhY2snKTtcbnZhciBza2lwTmF2ID0gcmVxdWlyZSgnLi9tb2R1bGVzL3NraXAtbmF2Jyk7XG52YXIgc2l0ZU5hdiA9IHJlcXVpcmUoJy4vbW9kdWxlcy9zaXRlLW5hdicpO1xudmFyIGRyb3Bkb3duID0gcmVxdWlyZSgnLi9tb2R1bGVzL2Ryb3Bkb3ducycpO1xudmFyIHRvYyA9IHJlcXVpcmUoJy4vbW9kdWxlcy90b2MnKTtcbnZhciB0eXBlYWhlYWQgPSByZXF1aXJlKCcuL21vZHVsZXMvdHlwZWFoZWFkJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9oZWxwZXJzJyk7XG5cbi8vIEhhY2s6IEFwcGVuZCBqUXVlcnkgdG8gYHdpbmRvd2AgZm9yIHVzZSBieSBsZWdhY3kgbGlicmFyaWVzXG53aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSAkO1xuXG52YXIgU3RpY2t5ID0gcmVxdWlyZSgnY29tcG9uZW50LXN0aWNreScpO1xudmFyIEZvcm1OYXYgPSByZXF1aXJlKCcuL21vZHVsZXMvZm9ybS1uYXYnKS5Gb3JtTmF2O1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAvLyBJbml0aWFsaXplIGdsb3NzYXJ5XG4gIG5ldyBHbG9zc2FyeSh0ZXJtcywge30sIHtcbiAgICB0ZXJtQ2xhc3M6ICdnbG9zc2FyeV9fdGVybSBhY2NvcmRpb25fX2J1dHRvbicsXG4gICAgZGVmaW5pdGlvbkNsYXNzOiAnZ2xvc3NhcnlfX2RlZmluaXRpb24gYWNjb3JkaW9uX19jb250ZW50J1xuICB9KTtcblxuICAvLyBJbml0aWFsaXplIG5ldyBhY2NvcmRpb25zXG4gICQoJy5qcy1hY2NvcmRpb24nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZW50UHJlZml4ID0gJCh0aGlzKS5kYXRhKCdjb250ZW50LXByZWZpeCcpIHx8ICdhY2NvcmRpb24nO1xuICAgIHZhciBvcGVuRmlyc3QgPSAkKHRoaXMpLmRhdGEoJ29wZW4tZmlyc3QnKSB8fCBmYWxzZTtcbiAgICB2YXIgc2VsZWN0b3JzID0ge1xuICAgICAgdHJpZ2dlcjogJy5qcy1hY2NvcmRpb24tdHJpZ2dlcidcbiAgICB9O1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29udGVudFByZWZpeDogY29udGVudFByZWZpeCxcbiAgICAgIG9wZW5GaXJzdDogb3BlbkZpcnN0XG4gICAgfTtcbiAgICBuZXcgQWNjb3JkaW9uKHRoaXMsIHNlbGVjdG9ycywgb3B0cyk7XG4gIH0pO1xuXG4gIG5ldyBza2lwTmF2LlNraXBuYXYoJy5za2lwLW5hdicsICdtYWluJyk7XG4gIG5ldyBzaXRlTmF2LlNpdGVOYXYoJy5qcy1zaXRlLW5hdicpO1xuXG4gIC8vIEluaXRpYWxpemUgdGFibGUgb2YgY29udGVudHNcbiAgbmV3IHRvYy5UT0MoJy5qcy10b2MnKTtcblxuICAvLyBJbml0aWFsaXplIHN0aWNreSBlbGVtZW50c1xuICAkKCcuanMtc3RpY2t5LXNpZGUnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMpLmRhdGEoJ3N0aWNreS1jb250YWluZXInKTtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIHdpdGhpbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyKVxuICAgIH07XG4gICAgaWYgKGhlbHBlcnMuaXNMYXJnZVNjcmVlbigpKSB7XG4gICAgICBuZXcgU3RpY2t5KHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjaGVja2JveCBkcm9wZG93bnNcbiAgJCgnLmpzLWRyb3Bkb3duJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICBuZXcgZHJvcGRvd24uRHJvcGRvd24odGhpcyk7XG4gIH0pO1xuXG4gIC8vIEluaXRpYWxpemUgZmVlZGJhY2sgd2lkZ2V0XG4gIG5ldyBmZWVkYmFjay5GZWVkYmFjaygnL2RhdGEvaXNzdWUvJyk7XG5cbiAgJCgnLmpzLWZvcm0tbmF2JykuZWFjaChmdW5jdGlvbigpIHtcbiAgICBuZXcgRm9ybU5hdih0aGlzKTtcbiAgfSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBoZWFkZXIgdHlwZWFoZWFkcyAobW9iaWxlIGFuZCBkZXNrdG9wKVxuICAkKCcuanMtc2l0ZS1zZWFyY2gnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIG5ldyB0eXBlYWhlYWQuVHlwZWFoZWFkKCQodGhpcyksICdhbGwnLCAnL2RhdGEvJyk7XG4gIH0pO1xuXG4gIC8vIEZvciBhbnkgbGluayB0aGF0IHNob3VsZCBzY3JvbGwgdG8gYSBzZWN0aW9uIG9uIHRoZSBwYWdlIGFwcGx5IC5qcy1zY3JvbGwgdG8gPGE+XG4gICQoJy5qcy1zY3JvbGwnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciAkbGluayA9ICQoZS50YXJnZXQpO1xuICAgIHZhciBzZWN0aW9uID0gJGxpbmsuYXR0cignaHJlZicpO1xuICAgIHZhciBzZWN0aW9uVG9wID0gJChzZWN0aW9uKS5vZmZzZXQoKS50b3A7XG4gICAgJCgnYm9keSwgaHRtbCcpLmFuaW1hdGUoe1xuICAgICAgc2Nyb2xsVG9wOiBzZWN0aW9uVG9wXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFBvc3QgZmVlZFxuICAvLyBNb3ZlIHRoZSByZWFkIG1vcmUgbGlua3MgdG8gYmUgaW5saW5lIHdpdGggdGhlIHNuaXBwZXQgZnJvbSB0aGUgcG9zdFxuICAkKCcuanMtcG9zdC1jb250ZW50JykuZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgJHAgPSAkKHRoaXMpLmZpbmQoJ3A6Zmlyc3Qtb2YtdHlwZScpO1xuICAgIHZhciAkbGluayA9ICQodGhpcykuZmluZCgnLmpzLXJlYWQtbW9yZScpO1xuICAgIGlmICgkcC50ZXh0KCkgIT09ICdQREYnKSB7XG4gICAgICAkcC5hcHBlbmQoJGxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICAkbGluay5yZW1vdmUoKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ZlYy9zdGF0aWMvanMvaW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIid1c2Ugc3RyaWN0JztcblxuLyogRm9ybU5hdlxuICogU3VibWl0cyB0aGUgZm9ybSBvbiBzZWxlY3QgY2hhbmdlIGFuZCBjbGVhcnMgb3V0IHVubmVjZXNzYXJ5IHBhcmFtc1xuICovXG5cbmZ1bmN0aW9uIEZvcm1OYXYoZm9ybSkge1xuICB0aGlzLmZvcm0gPSBmb3JtO1xuICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG59XG5cbkZvcm1OYXYucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYWxsU2VsZWN0cyA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QsaW5wdXQnKTtcbiAgLy8gUmVtb3ZlIG5hbWVzIGZyb20gYWxsIHNlbGVjdHMgd2l0aCBubyB2YWx1ZXNcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFsbFNlbGVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VsZWN0ID0gYWxsU2VsZWN0c1tpXTtcbiAgICBpZihzZWxlY3QuZ2V0QXR0cmlidXRlKCduYW1lJykgJiYgIXNlbGVjdC52YWx1ZSkge1xuICAgICAgc2VsZWN0LnNldEF0dHJpYnV0ZSgnbmFtZScsICcnKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmZvcm0uc3VibWl0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtGb3JtTmF2OiBGb3JtTmF2fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZmVjL3N0YXRpYy9qcy9tb2R1bGVzL2Zvcm0tbmF2LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==